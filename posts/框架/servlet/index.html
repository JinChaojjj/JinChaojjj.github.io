<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Servlet | King&#39;s Blog</title>
<meta name="keywords" content="Servlet">
<meta name="description" content="Servlet">
<meta name="author" content="King">
<link rel="canonical" href="https://jinchaojjj.github.io/posts/%E6%A1%86%E6%9E%B6/servlet/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://jinchaojjj.github.io/img/Q.gif">
<link rel="icon" type="image/png" sizes="16x16" href="https://jinchaojjj.github.io/img/Q.gif">
<link rel="icon" type="image/png" sizes="32x32" href="https://jinchaojjj.github.io/img/Q.gif">
<link rel="apple-touch-icon" href="https://jinchaojjj.github.io/Q.gif">
<link rel="mask-icon" href="https://jinchaojjj.github.io/Q.gif">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Servlet" />
<meta property="og:description" content="Servlet" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jinchaojjj.github.io/posts/%E6%A1%86%E6%9E%B6/servlet/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-05T00:18:23+08:00" />
<meta property="article:modified_time" content="2023-04-05T00:18:23+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Servlet"/>
<meta name="twitter:description" content="Servlet"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "📚文章",
      "item": "https://jinchaojjj.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "Servlet",
      "item": "https://jinchaojjj.github.io/posts/%E6%A1%86%E6%9E%B6/servlet/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Servlet",
  "name": "Servlet",
  "description": "Servlet",
  "keywords": [
    "Servlet"
  ],
  "articleBody": "Servlet Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。\n使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。\nJava Servlet 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。但是相比于 CGI，Servlet 有以下几点优势：\n性能明显更好。 Servlet 在 Web 服务器的地址空间内执行。这样它就没有必要再创建一个单独的进程来处理每个客户端请求。 Servlet 是独立于平台的，因为它们是用 Java 编写的。 服务器上的 Java 安全管理器执行了一系列限制，以保护服务器计算机上的资源。因此，Servlet 是可信的。 Java 类库的全部功能对 Servlet 来说都是可用的。它可以通过 sockets 和 RMI 机制与 applets、数据库或其他软件进行交互。 Servlet 架构 下图显示了 Servlet 在 Web 应用程序中的位置。\nServlet 任务 Servlet 执行以下主要任务：\n读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。 读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。 处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。 发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。 发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。 Servlet 包 Java Servlet 是运行在带有支持 Java Servlet 规范的解释器的 web 服务器上的 Java 类。\nServlet 可以使用 javax.servlet 和 javax.servlet.http 包创建，它是 Java 企业版的标准组成部分，Java 企业版是支持大型开发项目的 Java 类库的扩展版本。\n这些类实现 Java Servlet 和 JSP 规范。在写本教程的时候，二者相应的版本分别是 Java Servlet 2.5 和 JSP 2.1。\nJava Servlet 就像任何其他的 Java 类一样已经被创建和编译。在您安装 Servlet 包并把它们添加到您的计算机上的 Classpath 类路径中之后，您就可以通过 JDK 的 Java 编译器或任何其他编译器来编译 Servlet。\nServlet是什么 Servlet对象是用于处理请求的实体，首先Web服务器在接受到请求后，会根据请求类型（通常是Http请求）封装为一个ServletRequest对象（Http请求对应的就是HttpServletRequest对象，是ServletRequest的子类）；然后根据请求路径判断处理该请求的Servlet类是哪个，首先判断该类型是否已经创建了对象，若该类型还没有创建实例对象则创建一个对象，在创建对象后将ServletRequest、ServletResponse对象传递给Servlet方法，Servlet方法根据编写好的代码对请求进行处理，在处理完成后将需要的数据放入一并传输过来的ServletResponse对象中即可，Web服务器根据ServletResponse中设置的返回信息将信息封装为Http响应发送给前段。\nServlet需要学的东西 Servlet中比较重要的东西：一次请求、一次会话、一次运行、过滤器、监听器\n一次请求指的是一次HTTP请求，其中涉及到啦HttpServlet、HttpServletRequest、HttpServletResponse\n一次会话指的是浏览器打开期间一直在这个网站中访问的过程，涉及到Cookie、Session\n一次运行指的是服务器从开始运行到关闭这段时间，涉及到：ServletContext\n过滤器用于对发送往服务器的请求进行过滤：Filter\n监听器主要作用是对一些行为进行监听：Listener\nHttpServletRequest 讲述HttpServletRequest中的内容其实应该先对Http请求做介绍，不过这部分在计算机网络再进行介绍。\nHttpServletRequest 接口，它继承自 ServletRequest 接口。HttpServletRequest 对象专门用于封装 HTTP 请求消息，简称 request 对象。\nHTTP 请求消息分为请求行、请求消息头和请求消息体三部分，所以 HttpServletRequest 接口中定义了获取请求行、请求头和请求消息体的相关方法。\n获取请求行信息 HTTP 请求的请求行中包含请求方法、请求资源名、请求路径等信息，HttpServletRequest 接口定义了一系列获取请求行信息的方法，如下表。\n返回值类型 方法声明 描述 String getMethod() 该方法用于获取 HTTP 请求方式（如 GET、POST 等）。 String getRequestURI() 该方法用于获取请求行中的资源名称部分，即位于 URL 的主机和端口之后，参数部分之前的部分。 String getQueryString() 该方法用于获取请求行中的参数部分，也就是 URL 中“?”以后的所有内容。 String getContextPath() 返回当前 Servlet 所在的应用的名字（上下文）。对于默认（ROOT）上下文中的 Servlet，此方法返回空字符串\"\"。 String getServletPath() 该方法用于获取 Servlet 所映射的路径。 String getRemoteAddr() 该方法用于获取客户端的 IP 地址。 String getRemoteHost() 该方法用于获取客户端的完整主机名，如果无法解析出客户机的完整主机名，则该方法将会返回客户端的 IP 地址。 获取请求头信息 当浏览器发送请求时，需要通过请求头向服务器传递一些附加信息，例如客户端可以接收的数据类型、压缩方式、语言等。为了获取请求头中的信息， HttpServletRequest 接口定义了一系列用于获取 HTTP 请求头字段的方法，如下表所示。\n返回值类型 方法声明 描述 String getHeader(String name) 该方法用于获取一个指定头字段的值。 如果请求消息中包含多个指定名称的头字段，则该方法返回其中第一个头字段的值。 Enumeration getHeaders(String name) 该方法返回指定头字段的所有值的枚举集合， 在多数情况下，一个头字段名在请求消息中只出现一次，但有时可能会出现多次。 Enumeration getHeaderNames() 该方法返回请求头中所有头字段的枚举集合。 String getContentType() 该方法用于获取 Content-Type 头字段的值。 int getContentLength() 该方法用于获取 Content-Length 头字段的值 。 String getCharacterEncoding() 该方法用于返回请求消息的字符集编码 。 获取 form 表单的数据 在实际开发中，我们经常需要获取用户提交的表单数据，例如用户名和密码等。为了方便获取表单中的请求参数，ServletRequest 定义了一系列获取请求参数的方法，如下表所示。\n返回值类型 方法声明 功能描述 String getParameter(String name) 返回指定参数名的参数值。 String [ ] getParameterValues (String name) 以字符串数组的形式返回指定参数名的所有参数值（HTTP 请求中可以有多个相同参数名的参数）。 Enumeration getParameterNames() 以枚举集合的形式返回请求中所有参数名。 Map getParameterMap() 用于将请求中的所有参数名和参数值装入一个 Map 对象中返回。 HttpServlet HttpServlet继承自Servlet，其中Servlet的框架的核心是javax.servlet.Servlet接口,所有的Servlet都必须实现这一接口。在Servlet接口中定义了5个方法,其中有3个方法代表了Servlet的声明周期:\ninit方法,负责初始化Servlet对象 service方法,负责相应客户的请求 destory方法,当Servlet对象退出声明周期时,负责释放占有的资源\n当Web容器接收到某个Servlet请求时,Servlet把请求封装成一个HttpServletRequest对象,然后把对象传给Servlet的对应的服务方法.\nHTTP的请求方式包括DELETE,GET,OPTIONS,POST,PUT和TRACE,在HttpServlet类中分别提供了相应的服务方法,它们是,doDelete(),doGet(),doOptions(),doPost(), doPut()和doTrace().\n在没有重写service方法时，Http Servlet的做法是判断http请求的请求方式，然后调用对应请求方式的方法。\nHttpServletResponse Servlet 中的 doXXX 方法的目的就是根据请求计算得到响应, 然后把响应的数据设置到HttpServletResponse 对象中， 然后 Tomcat 就会把这个 HttpServletResponse 对象按照 HTTP 协议的格式, 转成一个字符串, 并通过Socket 写回给浏览器；\n核心方法 方法 描述 void setStatus(int sc) 设置响应状态码 void setHeader(String name,String value) 设置一个带有给定的名称和值的Header，如果name已经存在，则覆盖旧的值 void addHeader(int sc) 设置一个带有给定的名称和值的Header，如果name存在，不会覆盖旧的值，并列添加新的值 void setContentType(String type) 设置被发送到客户端的响应的内容类型 void setCharacterEncoding( String charset) 设置被发送到客户端的响应的字符编码(MIME 字符集) void sendRedirect(String location) 使用指定的重定向位置 URL 发送临时重定向响应到客户端 PrintWriter getWriter() 用于往 body 中写入文本格式数据 OutputStream getOutStream() 用于往 body 中写入二进制格式数据 Cookie \u0026 Session cookie其实就是一些记录在浏览器中的键值对（这些键值对在浏览器中保存时存在时间限制），并且请求时这些cookie的值就会带过来，后端并不会对cookie中的值进行保存（在不就行主动保存的情况下）。\nSession可以的主要作用就是根据cookie中的JSESSIONID创建一个用于保存本次会话期间一直存在的对象，比如保存了登陆的信息啊等等等，因为cookie信息是保存在前端可以篡改的，不要直接在cookie中保存信息用于校验。而session信息是保存在后端的，虽然用户可以更改JSESSIONID用于骗取信息，但是由于是随机生成的，相对来说更加安全一点，并且session的信息是存储在后端的。\nsession对象在后端中保存的时间存在限制，通常是30分钟，虽然有时候前段网页关闭后JSESSIONID值就已经消失了，但是后端的session还是存在的，要等到超时后才会删除。\nFilter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import javax.servlet.*; import javax.servlet.annotation.WebFilter; import java.io.IOException; @WebFilter(\"/*\") public class MyFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\"对request进行过滤\"); //下面这行代码就是放行 filterChain.doFilter(servletRequest,servletResponse); System.out.println(\"对response进行过滤\"); } } 主要通过上述的方式进行过滤，通常是判断请求路径是否合规，是否对相关信息处理等。\n",
  "wordCount" : "3941",
  "inLanguage": "en",
  "datePublished": "2023-04-05T00:18:23+08:00",
  "dateModified": "2023-04-05T00:18:23+08:00",
  "author":[{
    "@type": "Person",
    "name": "King"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://jinchaojjj.github.io/posts/%E6%A1%86%E6%9E%B6/servlet/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "King's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://jinchaojjj.github.io/img/Q.gif"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://jinchaojjj.github.io" accesskey="h" title="King&#39;s Blog (Alt + H)">
                <img src="https:/jinchaojjj.github.io/Q.gif" alt="" aria-label="logo"
                    height="35">King&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://jinchaojjj.github.io/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="https://jinchaojjj.github.io/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://jinchaojjj.github.io/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://jinchaojjj.github.io/archives/" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://jinchaojjj.github.io/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="https://jinchaojjj.github.io/about" title="🙋🏻‍♂️关于">
                    <span>🙋🏻‍♂️关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://jinchaojjj.github.io">Home</a>&nbsp;»&nbsp;<a href="https://jinchaojjj.github.io/posts/">📚文章</a></div>
    <h1 class="post-title">
      Servlet
    </h1>
    <div class="post-description">
      Servlet
    </div>
    <div class="post-meta"><span title='2023-04-05 00:18:23 +0800 CST'>2023-04-05</span>&nbsp;·&nbsp;8 min&nbsp;·&nbsp;King

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#servlet" aria-label="Servlet">Servlet</a><ul>
                        
                <li>
                    <a href="#servlet-%e6%9e%b6%e6%9e%84" aria-label="Servlet 架构">Servlet 架构</a></li>
                <li>
                    <a href="#servlet-%e4%bb%bb%e5%8a%a1" aria-label="Servlet 任务">Servlet 任务</a></li>
                <li>
                    <a href="#servlet-%e5%8c%85" aria-label="Servlet 包">Servlet 包</a><ul>
                        
                <li>
                    <a href="#servlet%e6%98%af%e4%bb%80%e4%b9%88" aria-label="Servlet是什么">Servlet是什么</a></li>
                <li>
                    <a href="#servlet%e9%9c%80%e8%a6%81%e5%ad%a6%e7%9a%84%e4%b8%9c%e8%a5%bf" aria-label="Servlet需要学的东西">Servlet需要学的东西</a></li></ul>
                </li>
                <li>
                    <a href="#httpservletrequest" aria-label="HttpServletRequest">HttpServletRequest</a><ul>
                        
                <li>
                    <a href="#%e8%8e%b7%e5%8f%96%e8%af%b7%e6%b1%82%e8%a1%8c%e4%bf%a1%e6%81%af" aria-label="获取请求行信息">获取请求行信息</a></li>
                <li>
                    <a href="#%e8%8e%b7%e5%8f%96%e8%af%b7%e6%b1%82%e5%a4%b4%e4%bf%a1%e6%81%af" aria-label="获取请求头信息">获取请求头信息</a></li>
                <li>
                    <a href="#%e8%8e%b7%e5%8f%96-form-%e8%a1%a8%e5%8d%95%e7%9a%84%e6%95%b0%e6%8d%ae" aria-label="获取 form 表单的数据">获取 form 表单的数据</a></li></ul>
                </li>
                <li>
                    <a href="#httpservlet" aria-label="HttpServlet">HttpServlet</a></li>
                <li>
                    <a href="#httpservletresponse" aria-label="HttpServletResponse">HttpServletResponse</a><ul>
                        
                <li>
                    <a href="#%e6%a0%b8%e5%bf%83%e6%96%b9%e6%b3%95" aria-label="核心方法">核心方法</a></li></ul>
                </li>
                <li>
                    <a href="#cookie--session" aria-label="Cookie &amp;amp; Session">Cookie &amp; Session</a></li>
                <li>
                    <a href="#filter" aria-label="Filter">Filter</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="servlet">Servlet<a hidden class="anchor" aria-hidden="true" href="#servlet">#</a></h1>
<p>Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。</p>
<p>使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。</p>
<p>Java Servlet 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。但是相比于 CGI，Servlet 有以下几点优势：</p>
<ul>
<li>性能明显更好。</li>
<li>Servlet 在 Web 服务器的地址空间内执行。这样它就没有必要再创建一个单独的进程来处理每个客户端请求。</li>
<li>Servlet 是独立于平台的，因为它们是用 Java 编写的。</li>
<li>服务器上的 Java 安全管理器执行了一系列限制，以保护服务器计算机上的资源。因此，Servlet 是可信的。</li>
<li>Java 类库的全部功能对 Servlet 来说都是可用的。它可以通过 sockets 和 RMI 机制与 applets、数据库或其他软件进行交互。</li>
</ul>
<h2 id="servlet-架构">Servlet 架构<a hidden class="anchor" aria-hidden="true" href="#servlet-架构">#</a></h2>
<p>下图显示了 Servlet 在 Web 应用程序中的位置。</p>
<p><img loading="lazy" src="https://www.runoob.com/wp-content/uploads/2014/07/servlet-arch.jpg" alt="Servlet 架构"  />
</p>
<h2 id="servlet-任务">Servlet 任务<a hidden class="anchor" aria-hidden="true" href="#servlet-任务">#</a></h2>
<p>Servlet 执行以下主要任务：</p>
<ul>
<li>读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。</li>
<li>读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。</li>
<li>处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。</li>
<li>发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。</li>
<li>发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。</li>
</ul>
<h2 id="servlet-包">Servlet 包<a hidden class="anchor" aria-hidden="true" href="#servlet-包">#</a></h2>
<p>Java Servlet 是运行在带有支持 Java Servlet 规范的解释器的 web 服务器上的 Java 类。</p>
<p>Servlet 可以使用 <strong>javax.servlet</strong> 和 <strong>javax.servlet.http</strong> 包创建，它是 Java 企业版的标准组成部分，Java 企业版是支持大型开发项目的 Java 类库的扩展版本。</p>
<p>这些类实现 Java Servlet 和 JSP 规范。在写本教程的时候，二者相应的版本分别是 Java Servlet 2.5 和 JSP 2.1。</p>
<p>Java Servlet 就像任何其他的 Java 类一样已经被创建和编译。在您安装 Servlet 包并把它们添加到您的计算机上的 Classpath 类路径中之后，您就可以通过 JDK 的 Java 编译器或任何其他编译器来编译 Servlet。</p>
<h3 id="servlet是什么">Servlet是什么<a hidden class="anchor" aria-hidden="true" href="#servlet是什么">#</a></h3>
<p>Servlet对象是用于处理请求的实体，首先Web服务器在接受到请求后，会根据请求类型（通常是Http请求）封装为一个ServletRequest对象（Http请求对应的就是HttpServletRequest对象，是ServletRequest的子类）；然后根据请求路径判断处理该请求的Servlet类是哪个，首先判断该类型是否已经创建了对象，若该类型还没有创建实例对象则创建一个对象，在创建对象后将ServletRequest、ServletResponse对象传递给Servlet方法，Servlet方法根据编写好的代码对请求进行处理，在处理完成后将需要的数据放入一并传输过来的ServletResponse对象中即可，Web服务器根据ServletResponse中设置的返回信息将信息封装为Http响应发送给前段。</p>
<p><img loading="lazy" src="https://king-super.oss-cn-nanjing.aliyuncs.com/20230307211636.png" alt=""  />
</p>
<h3 id="servlet需要学的东西">Servlet需要学的东西<a hidden class="anchor" aria-hidden="true" href="#servlet需要学的东西">#</a></h3>
<p>Servlet中比较重要的东西：一次请求、一次会话、一次运行、过滤器、监听器</p>
<p>一次请求指的是一次HTTP请求，其中涉及到啦HttpServlet、HttpServletRequest、HttpServletResponse</p>
<p>一次会话指的是浏览器打开期间一直在这个网站中访问的过程，涉及到Cookie、Session</p>
<p>一次运行指的是服务器从开始运行到关闭这段时间，涉及到：ServletContext</p>
<p>过滤器用于对发送往服务器的请求进行过滤：Filter</p>
<p>监听器主要作用是对一些行为进行监听：Listener</p>
<h2 id="httpservletrequest">HttpServletRequest<a hidden class="anchor" aria-hidden="true" href="#httpservletrequest">#</a></h2>
<p>讲述HttpServletRequest中的内容其实应该先对Http请求做介绍，不过这部分在计算机网络再进行介绍。</p>
<p>HttpServletRequest 接口，它继承自 ServletRequest 接口。HttpServletRequest 对象专门用于封装 HTTP 请求消息，简称 request 对象。</p>
<p>HTTP 请求消息分为请求行、请求消息头和请求消息体三部分，所以 HttpServletRequest 接口中定义了获取请求行、请求头和请求消息体的相关方法。</p>
<h3 id="获取请求行信息">获取请求行信息<a hidden class="anchor" aria-hidden="true" href="#获取请求行信息">#</a></h3>
<p>HTTP 请求的请求行中包含请求方法、请求资源名、请求路径等信息，HttpServletRequest 接口定义了一系列获取请求行信息的方法，如下表。</p>
<table>
<thead>
<tr>
<th>返回值类型</th>
<th>方法声明</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>getMethod()</td>
<td>该方法用于获取 HTTP 请求方式（如 GET、POST 等）。</td>
</tr>
<tr>
<td>String</td>
<td>getRequestURI()</td>
<td>该方法用于获取请求行中的资源名称部分，即位于 URL 的主机和端口之后，参数部分之前的部分。</td>
</tr>
<tr>
<td>String</td>
<td>getQueryString()</td>
<td>该方法用于获取请求行中的参数部分，也就是 URL 中“?”以后的所有内容。</td>
</tr>
<tr>
<td>String</td>
<td>getContextPath()</td>
<td>返回当前 Servlet 所在的应用的名字（上下文）。对于默认（ROOT）上下文中的 Servlet，此方法返回空字符串&quot;&quot;。</td>
</tr>
<tr>
<td>String</td>
<td>getServletPath()</td>
<td>该方法用于获取 Servlet 所映射的路径。</td>
</tr>
<tr>
<td>String</td>
<td>getRemoteAddr()</td>
<td>该方法用于获取客户端的 IP 地址。</td>
</tr>
<tr>
<td>String</td>
<td>getRemoteHost()</td>
<td>该方法用于获取客户端的完整主机名，如果无法解析出客户机的完整主机名，则该方法将会返回客户端的 IP 地址。</td>
</tr>
</tbody>
</table>
<h3 id="获取请求头信息">获取请求头信息<a hidden class="anchor" aria-hidden="true" href="#获取请求头信息">#</a></h3>
<p>当浏览器发送请求时，需要通过请求头向服务器传递一些附加信息，例如客户端可以接收的数据类型、压缩方式、语言等。为了获取请求头中的信息， HttpServletRequest 接口定义了一系列用于获取 HTTP 请求头字段的方法，如下表所示。</p>
<table>
<thead>
<tr>
<th>返回值类型</th>
<th>方法声明</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>getHeader(String name)</td>
<td>该方法用于获取一个指定头字段的值。 如果请求消息中包含多个指定名称的头字段，则该方法返回其中第一个头字段的值。</td>
</tr>
<tr>
<td>Enumeration</td>
<td>getHeaders(String name)</td>
<td>该方法返回指定头字段的所有值的枚举集合， 在多数情况下，一个头字段名在请求消息中只出现一次，但有时可能会出现多次。</td>
</tr>
<tr>
<td>Enumeration</td>
<td>getHeaderNames()</td>
<td>该方法返回请求头中所有头字段的枚举集合。</td>
</tr>
<tr>
<td>String</td>
<td>getContentType()</td>
<td>该方法用于获取 Content-Type 头字段的值。</td>
</tr>
<tr>
<td>int</td>
<td>getContentLength()</td>
<td>该方法用于获取 Content-Length 头字段的值 。</td>
</tr>
<tr>
<td>String</td>
<td>getCharacterEncoding()</td>
<td>该方法用于返回请求消息的字符集编码 。</td>
</tr>
</tbody>
</table>
<h3 id="获取-form-表单的数据">获取 form 表单的数据<a hidden class="anchor" aria-hidden="true" href="#获取-form-表单的数据">#</a></h3>
<p>在实际开发中，我们经常需要获取用户提交的表单数据，例如用户名和密码等。为了方便获取表单中的请求参数，ServletRequest 定义了一系列获取请求参数的方法，如下表所示。</p>
<table>
<thead>
<tr>
<th>返回值类型</th>
<th>方法声明</th>
<th>功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>getParameter(String name)</td>
<td>返回指定参数名的参数值。</td>
</tr>
<tr>
<td>String [ ]</td>
<td>getParameterValues (String name)</td>
<td>以字符串数组的形式返回指定参数名的所有参数值（HTTP 请求中可以有多个相同参数名的参数）。</td>
</tr>
<tr>
<td>Enumeration</td>
<td>getParameterNames()</td>
<td>以枚举集合的形式返回请求中所有参数名。</td>
</tr>
<tr>
<td>Map</td>
<td>getParameterMap()</td>
<td>用于将请求中的所有参数名和参数值装入一个 Map 对象中返回。</td>
</tr>
</tbody>
</table>
<h2 id="httpservlet">HttpServlet<a hidden class="anchor" aria-hidden="true" href="#httpservlet">#</a></h2>
<p>HttpServlet继承自Servlet，其中Servlet的框架的核心是javax.servlet.Servlet接口,所有的Servlet都必须实现这一接口。在Servlet接口中定义了5个方法,其中有3个方法代表了Servlet的声明周期:</p>
<p>init方法,负责初始化Servlet对象
service方法,负责相应客户的请求
destory方法,当Servlet对象退出声明周期时,负责释放占有的资源</p>
<p>当Web容器接收到某个Servlet请求时,Servlet把请求封装成一个HttpServletRequest对象,然后把对象传给Servlet的对应的服务方法.</p>
<p>HTTP的请求方式包括DELETE,GET,OPTIONS,POST,PUT和TRACE,在HttpServlet类中分别提供了相应的服务方法,它们是,doDelete(),doGet(),doOptions(),doPost(), doPut()和doTrace().</p>
<p>在没有重写service方法时，Http Servlet的做法是判断http请求的请求方式，然后调用对应请求方式的方法。</p>
<h2 id="httpservletresponse">HttpServletResponse<a hidden class="anchor" aria-hidden="true" href="#httpservletresponse">#</a></h2>
<p>Servlet 中的 doXXX 方法的目的就是根据请求计算得到响应, 然后把响应的数据设置到HttpServletResponse 对象中，
然后 Tomcat 就会把这个 HttpServletResponse 对象按照 HTTP 协议的格式, 转成一个字符串, 并通过Socket 写回给浏览器；</p>
<h3 id="核心方法">核心方法<a hidden class="anchor" aria-hidden="true" href="#核心方法">#</a></h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>void setStatus(int sc)</td>
<td>设置响应状态码</td>
</tr>
<tr>
<td>void setHeader(String name,String value)</td>
<td>设置一个带有给定的名称和值的<code>Header</code>，如果<code>name</code>已经存在，则覆盖旧的值</td>
</tr>
<tr>
<td>void addHeader(int sc)</td>
<td>设置一个带有给定的名称和值的<code>Header</code>，如果<code>name</code>存在，不会覆盖旧的值，并列添加新的值</td>
</tr>
<tr>
<td>void setContentType(String type)</td>
<td>设置被发送到客户端的响应的内容类型</td>
</tr>
<tr>
<td>void setCharacterEncoding( String charset)</td>
<td>设置被发送到客户端的响应的字符编码(<code>MIME</code> 字符集)</td>
</tr>
<tr>
<td>void sendRedirect(String location)</td>
<td>使用指定的重定向位置 <code>URL</code> 发送临时重定向响应到客户端</td>
</tr>
<tr>
<td>PrintWriter getWriter()</td>
<td>用于往 <code>body</code> 中写入文本格式数据</td>
</tr>
<tr>
<td>OutputStream getOutStream()</td>
<td>用于往 <code>body</code> 中写入二进制格式数据</td>
</tr>
</tbody>
</table>
<h2 id="cookie--session">Cookie &amp; Session<a hidden class="anchor" aria-hidden="true" href="#cookie--session">#</a></h2>
<p>cookie其实就是一些记录在浏览器中的键值对（这些键值对在浏览器中保存时存在时间限制），并且请求时这些cookie的值就会带过来，后端并不会对cookie中的值进行保存（在不就行主动保存的情况下）。</p>
<p>Session可以的主要作用就是根据cookie中的JSESSIONID创建一个用于保存本次会话期间一直存在的对象，比如保存了登陆的信息啊等等等，因为cookie信息是保存在前端可以篡改的，不要直接在cookie中保存信息用于校验。而session信息是保存在后端的，虽然用户可以更改JSESSIONID用于骗取信息，但是由于是随机生成的，相对来说更加安全一点，并且session的信息是存储在后端的。</p>
<p>session对象在后端中保存的时间存在限制，通常是30分钟，虽然有时候前段网页关闭后JSESSIONID值就已经消失了，但是后端的session还是存在的，要等到超时后才会删除。</p>
<h2 id="filter">Filter<a hidden class="anchor" aria-hidden="true" href="#filter">#</a></h2>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">import</span> javax.servlet.*;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">import</span> javax.servlet.annotation.WebFilter;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">import</span> java.io.IOException;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>@WebFilter(<span style="color:#0ff;font-weight:bold">&#34;/*&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> MyFilter <span style="color:#fff;font-weight:bold">implements</span> Filter {
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    @Override
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) <span style="color:#fff;font-weight:bold">throws</span> IOException, ServletException {
</span></span><span style="display:flex;"><span>        System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;对request进行过滤&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">//下面这行代码就是放行
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        filterChain.<span style="color:#007f7f">doFilter</span>(servletRequest,servletResponse);
</span></span><span style="display:flex;"><span>        System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;对response进行过滤&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>主要通过上述的方式进行过滤，通常是判断请求路径是否合规，是否对相关信息处理等。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://jinchaojjj.github.io/tags/servlet/">Servlet</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://jinchaojjj.github.io/posts/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/docker/">
    <span class="title">« Prev</span>
    <br>
    <span>Docker</span>
  </a>
  <a class="next" href="https://jinchaojjj.github.io/posts/%E6%A1%86%E6%9E%B6/spring/">
    <span class="title">Next »</span>
    <br>
    <span>Spring</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://jinchaojjj.github.io">King&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
