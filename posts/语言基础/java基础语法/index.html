<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Java基本语法 | King&#39;s Blog</title>
<meta name="keywords" content="基础">
<meta name="description" content="Java基本语法">
<meta name="author" content="King">
<link rel="canonical" href="https://jinchaojjj.github.io/posts/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://jinchaojjj.github.io/img/a.jpeg">
<link rel="icon" type="image/png" sizes="16x16" href="https://jinchaojjj.github.io/img/a.jpeg">
<link rel="icon" type="image/png" sizes="32x32" href="https://jinchaojjj.github.io/img/a.jpeg">
<link rel="apple-touch-icon" href="https://jinchaojjj.github.io/a.jpeg">
<link rel="mask-icon" href="https://jinchaojjj.github.io/a.jpeg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript><meta property="og:title" content="Java基本语法" />
<meta property="og:description" content="Java基本语法" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jinchaojjj.github.io/posts/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-05T00:18:23+08:00" />
<meta property="article:modified_time" content="2023-04-05T00:18:23+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java基本语法"/>
<meta name="twitter:description" content="Java基本语法"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "📚文章",
      "item": "https://jinchaojjj.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  4 ,
      "name": "Java基本语法",
      "item": "https://jinchaojjj.github.io/posts/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java基本语法",
  "name": "Java基本语法",
  "description": "Java基本语法",
  "keywords": [
    "基础"
  ],
  "articleBody": "Java基本语法 1. 注释 Java中存在三种注释：单行注释、多行注释、文档注释\n单行注释采用//的方式进行，在本行中的所有内容在编译时都将忽略 多行注释采用/* 内容 */的方式进行，在中间的部分都认为是注释，通常用于注释多行代码 文档注释采用/** 内容 */的方式，一般在类上、方法上使用，其中可以html语法，并且在生成Java开发文档时将自动将注释部分作为文档中的内容 在开发过程中多写注释是一个好习惯，当代码量非常巨大的时候，往往注释可以很方便的告知使用者类、方法的具体含义，以此减少沟通成本、提高系统的开发效率\n1 2 3 4 5 6 7 8 9 10 11 // 单行注释 /* * 多行注释 */ /** * 文档注释 * 可以采用html格式 * @author King */ 2. 标识符和关键字 标识符就是在Java程序中设置的各种类、方法、变量等的名字，同时还有一些标识符例如if、for等是Java已经赋予了特殊含义的标识符称为关键字。各种关键字有哪些可以在官网上查看：官网\n3. 基本数据类型以及包装类 八大基本数据类型：boolean、byte、char、short、int、long、floet、double\n对应的包装类：Boolean、Byte、Character、Short、Integer、Long、Float、Double\n4. 类型转换和判断 类型转化分为两种方式：隐式类型转化和强制类型转化\n隐式类型转化 在Java基础数据类型中byte -\u003e short -\u003e char -\u003e int -\u003e long -\u003e float -\u003e double可以进行隐式的类型转化，前面的类型可以直接赋值给后面的类型 基本数据类型可以与包装类互相转化 子类对象可以赋值给父类对象使用 强制类型转化 基本数据类型从大类型到小类型的转换，需要使用强制转换符。在 Java 中，强制类型转换的格式为 (type)value 类对象也可以采用这种方法进行强制类型转换，通常是某些方法返回值是Object类型此时需要强制类型转换 类型判断 可以使用 instanceof 运算符来判断一个对象是否为一个类的实例。instanceof 运算符通过返回一个布尔值来指出，这个对象是否是这个特定类或者是它的子类的一个实例。\ninstanceof 运算符的语法格式为：object instanceof class，其中 object 是要测试的对象，class 是类或接口类型。如果 object 是 class 的一个实例，则 instanceof 运算符返回 true；否则返回 false\n5. 变量、常量和作用域 作用域根据变量定义时的外侧的大括号进行判断。\n6. 基本运算符 自增自减运算符（++、--） 自增、自减运算符可以用于整型数据以及浮点数据上，其中也包括char类型。\n++ 位于变量名之前，则优先运算++的值，并将结果用于外部等式的运算。\n若位于变量名之后，则优先进行外部等式的运算，在计算完成后变量再进行加减计算。\n1 2 3 4 5 6 7 8 9 int a = 5; int b = a++; System.out.println(a); System.out.println(b); System.out.println(--a); // 6 // 5 // 5 位移运算符 位移运算法有\u003e\u003e\u003e 、\u003e\u003e 和 \u003c\u003c 三种，操作都是针对二进制数，同时只对整型类型有效。\n移位操作符实际上支持的类型只有int和long，编译器在对short、byte、char类型进行移位前，都会将其转换为int类型再操作\n对于int类型当位移次数大于32次时会首先对位移数向32求余，类似于a \u003e\u003e\u003e 33等价于a \u003e\u003e\u003e 1，对于long类型是向64求余。其中\u003e\u003e在位移时会按照有符号的方式进行补位，而\u003e\u003e\u003e是直接补0。\n1 2 3 4 5 6 7 int a = 5; // 0000 0101 System.out.println(a \u003e\u003e 1);// 0000 0010 = 2 System.out.println(a \u003c\u003c 1);// 0000 1010 = 10 System.out.println(-5 \u003e\u003e\u003e 1); //1111 1111 1111 1111 1111 1111 1111 1010 = -5 //0111 1111 1111 1111 1111 1111 1111 1101 = 2147483645 System.out.println(5 \u003e\u003e\u003e 1);// 2 位运算 与\u0026：1010 \u0026 0001 = 0000 或|：1010 | 0001 = 1011 非~：~0001 = 1110 异或^：1010 ^ 1001 = 0011 同或：在Java中并没有同或的实现，但是可以通过先异或再取反的方式实现：~ (1010 ^ 1001) = 1100或者(1010 ^ 1001) ^ -1 = 1100；第二种方法中的-1是对应数据类型的-1，idea也提示两种方法的作用是相同的，建议还是使用第一种 Math Java中的Math类提供了很多有用的方法来执行基本数学运算。以下是一些常用的方法：\nabs()：返回一个数的绝对值。 ceil()：返回大于或等于参数的最小double值，等于一个整数。 floor()：返回小于或等于参数的最大double值，等于一个整数。 max()：返回两个参数中的最大值。 min()：返回两个参数中的最小值。 pow()：返回第一个参数的第二个参数次幂。 random()：返回一个随机数。 round()：返回一个四舍五入的整数。 7. 包结构 主要涉及到的是packing关键词。 8. 顺序结构 9. if 10. switch 11. while 12. for 13. foreach 14. break、continue 15. 方法 16. 命令行的参数传递 当你使用Java命令行来运行程序时，如果在后面带上参数，Java的虚拟机就直接把这些参数存放到args数组中了，完成了命令行传参。\n例如，你可以在命令行中输入以下命令来运行一个名为Main的Java类，并传递一个参数：java Main arg1\n在Main类中，你可以通过以下方式访问该参数：\n1 2 3 public static void main(String[] args) { System.out.println(args[0]); } 这将输出：arg1\n17. 可变参数 1 2 3 4 5 public static void main(String[] args) { } public static void main(String... args) { } 上述两种传参数方式是相同的，使用第二种时会在编译阶段重新封装为第一种。因此在使用可变参数的时候有以下几种限制：\n一个方法的形参中只能有一个可变参数 可变参数必须是最后一个形参 18. 数组 19. Arrays Java中的Arrays类提供了很多有用的方法来操作数组。以下是一些常用的方法：\nfill()：给数组赋值。 sort()：对数组进行排序。 equals()：比较两个数组是否相等。 binarySearch()：对排序好的数组进行二分查找。 asList()：将数组转换为List。 copyOf()：复制数组。 copyOfRange()：复制数组的一部分。 toString()：将数组转换为字符串。 20. 类和对象 21. 构造函数 与类同名\n22. 继承 extends、implements\n23. super 24. 重写 继承后将父类的方法重新实现，根据里氏替换原则这是不建议的。\n25. static 26. 抽象类 abstract\n27. 接口 interface\n28. 内部类 Java中的内部类分为四种：成员内部类、静态内部类、局部内部类和匿名内部类。\n成员内部类：定义在一个类的内部，且在该类的外部可以通过实例化对象来访问。 静态内部类：定义在一个类的内部，且在该类的外部可以直接通过“外部类.静态内部类”来访问。 局部内部类：定义在方法或作用域内，且只能在该方法或作用域内使用。 匿名内部类：没有名字的局部内部类。 下面是一些例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class Outer { private int x = 10; // 成员内部类 class Inner { void print() { System.out.println(\"x = \" + x); } } } public class Outer { private static int x = 10; // 静态内部类 static class Inner { void print() { System.out.println(\"x = \" + x); } } } public class Outer { public void method() { // 局部内部类 class Inner { void print() { System.out.println(\"Hello World!\"); } } Inner inner = new Inner(); inner.print(); } } public class Outer { public void method() { new Thread( // 匿名内部类 new Runnable() { @Override public void run() { System.out.println(\"Hello World!\"); } }).start(); } } 29. 异常 在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类:\nException :程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。 Error ：Error 属于程序无法处理的错误 ，我们没办法通过 catch 来进行捕获 。例如 Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。 Checked Exception Checked Exception 即受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 catch或者throws 关键字处理的话，就没办法通过编译。\n除了RuntimeException及其子类以外，其他的Exception类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、ClassNotFoundException 、SQLException\n所有的异常都继承自Exception类，若继承自RuntimeException则是不受检查的，若直接继承自Exception则是受检查的异常。\n异常可以在发生时告知发生的原因和内容。\nThrowable 类常用方法有哪些？ String getMessage(): 返回异常发生时的简要描述 String toString(): 返回异常发生时的详细信息 String getLocalizedMessage(): 返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage()返回的结果相同 void printStackTrace(): 在控制台上打印 Throwable 对象封装的异常信息 try-catch-finally 如何使用？ try块 ： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。 catch块 ： 用于处理 try 捕获到的异常。 finally 块 ： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。 在对象实现AutoCloseable接口的情况下，可以使用 try-with-resources语法进行简化，不必再使用finally语句进行关闭操作，不过该部分执行的也只是关闭操作，如果需要执行额外的操作还是需要使用finally。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // try-catch-finally InputStream stream = null; try { stream = new FileInputStream(\"test.txt\"); } catch (FileNotFoundException e) { throw new RuntimeException(e); } finally { try { stream.close(); } catch (IOException e) { throw new RuntimeException(e); } } // try-with-resources 这看起来就清爽很多了 // 不过使用的前提是要实现Closeable接口 try(InputStream stream1 = new FileInputStream(\"test.txt\")){ } catch (FileNotFoundException e) { throw new RuntimeException(e); } catch (IOException e) { throw new RuntimeException(e); } 30. 反射 何谓反射？ 如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。\n反射的优缺点？ 反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。\n不过，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。\n优点 ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利\n缺点 ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的\n使用反射机制主要分为两部分：获取Class对象、同Class对象对对象进行操作，下面会根据这两部分进行介绍\n反射的应用场景？ 像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。但是！这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。\n这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。\n比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 Method 来调用指定的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class DebugInvocationHandler implements InvocationHandler { /** * 代理类中的真实对象 */ private final Object target; public DebugInvocationHandler(Object target) { this.target = target; } public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException { System.out.println(\"before method \" + method.getName()); Object result = method.invoke(target, args); System.out.println(\"after method \" + method.getName()); return result; } } 另外，像 Java 中的一大利器 注解 的实现也用到了反射。\n为什么你使用 Spring 的时候 ，一个@Component注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 @Value注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？\n这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。\n获取Class对象对四种方法 通过具体的类获取对象\n1 Class\u003c?\u003e clazz = TargetObject.Class; 通过Class.forName()方法传入类的全路径获取\n1 Class\u003c?\u003e clazz = Class.forName(\"cn.king.TargetObject\"); 通过类对象实例的.getClass()方法获取\n1 2 TargetObject object = new TargetObject(); Class\u003c?\u003e clazz = object.getClass(); 通过类加载器传入类路径获取\n1 ClassLoader.getSystemClassLoader().loadClass(\"cn.king.TargetObject\"); 上述是四种获取Class对象的方法，其中前面两种方法都会进行类对象的初始化（静态代码块和静态对象的初始化），第三种已经创建了对象，此时是一定会进行初始化的，但是第四种获取的方式不会引起初始化，这是需要值得注意的，在有些特殊的场景下需要注意。\n反射的基本操作 这部分主要是学习Class类中所具有的方法，一个类中主要有以下几部分组成：类成员变量、方法、类本身\n1. Class类 获得类相关的方法 方法 用途 asSubclass(Class clazz) 把传递的类的对象转换成代表其子类的对象 Cast 把对象转换成代表类或是接口的对象 getClassLoader() 获得类的加载器 getClasses() 返回一个数组，数组中包含该类中所有公共类和接口类的对象 getDeclaredClasses() 返回一个数组，数组中包含该类中所有类和接口类的对象 forName(String className) 根据类名返回类的对象 getName() 获得类的完整路径名字 newInstance() 创建类的实例 getPackage() 获得类的包 getSimpleName() 获得类的名字 getSuperclass() 获得当前类继承的父类的名字 getInterfaces() 获得当前类实现的类或是接口 获得类中属性相关的方法 方法 用途 getField(String name) 获得某个公有的属性对象 getFields() 获得所有公有的属性对象 getDeclaredField(String name) 获得某个属性对象 getDeclaredFields() 获得所有属性对象 获得类中注解相关的方法 方法 用途 getAnnotation(Class annotationClass) 返回该类中与参数类型匹配的公有注解对象 getAnnotations() 返回该类所有的公有注解对象 getDeclaredAnnotation(Class annotationClass) 返回该类中与参数类型匹配的所有注解对象 getDeclaredAnnotations() 返回该类所有的注解对象 获得类中构造器相关的方法 方法 用途 getConstructor(Class…\u003c?\u003e parameterTypes) 获得该类中与参数类型匹配的公有构造方法 getConstructors() 获得该类的所有公有构造方法 getDeclaredConstructor(Class…\u003c?\u003e parameterTypes) 获得该类中与参数类型匹配的构造方法 getDeclaredConstructors() 获得该类所有构造方法 获得类中方法相关的方法 方法 用途 getMethod(String name, Class…\u003c?\u003e parameterTypes) 获得该类某个公有的方法 getMethods() 获得该类所有公有的方法 getDeclaredMethod(String name, Class…\u003c?\u003e parameterTypes) 获得该类某个方法 getDeclaredMethods() 获得该类所有方法 类中其他重要的方法 方法 用途 isAnnotation() 如果是注解类型则返回true isAnnotationPresent(Class\u003c? extends Annotation\u003e annotationClass) 如果是指定类型注解类型则返回true isAnonymousClass() 如果是匿名类则返回true isArray() 如果是一个数组类则返回true isEnum() 如果是枚举类则返回true isInstance(Object obj) 如果obj是该类的实例则返回true isInterface() 如果是接口类则返回true isLocalClass() 如果是局部类则返回true isMemberClass() 如果是内部类则返回true 2. Field类 Field代表类的成员变量（成员变量也称为类的属性）。\n方法 用途 equals(Object obj) 属性与obj相等则返回true get(Object obj) 获得obj中对应的属性值 set(Object obj, Object value) 设置obj中对应属性值 3. Method类 Method代表类的方法。\n方法 用途 invoke(Object obj, Object… args) 传递object对象及参数调用该对象对应的方法 4. Constructor类 Constructor代表类的构造方法。\n方法 用途 newInstance(Object… initargs) 根据传递的参数创建类的对象 31. 多线程 32. 动态代理 33. IO介绍 一个程序可以分为内部与外部，内部通常是这个程序在CPU、内存上运行的，而外部可以是显示器、控制台、硬盘、其他电脑等等，在冯诺依曼的计算机结构中内部就是运算器、控制器、存储器，外部是输入设备与输出设备。将内部的数据输出到外部就是Output，将外部的数据输入内部就是Input。\n将程序分为内部与外部是我自己的理解，其他人一般不会这么将，那为什么要将程序分为内部与外部呢？其实计算机（我们能接触到的设备）本质上就是处理数据的设备，如果只是将数据在程序内进行处理那么得到的这些数据是毫无作用的（因为你看不到这些数据），所以计算得到的数据需要通过Output展现在我们面前（我们一般看见的显示器、控制台、窗口都是通过Output实现的），有时候程序的运行以来外部的数据此时需要通过Input将数据给到程序。\n分类 在UNIX系统中IO模型一共分为五种：同步阻塞IO、同步非阻塞IO、IO多路复用、信号驱动IO、异步IO\n在Java中有三种常见的IO\nBIO BIO- blocking IO 属于同步阻塞IO，同步阻塞IO模型中程序发起read调用后会一直阻塞，直到数据被拷贝到内存中。\nNIO (Non-blocking/New I/O) ava 中的 NIO 于 Java 1.4 中引入，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它是支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。\nJava 中的 NIO 可以看作是 I/O 多路复用模型。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。\n同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。\n相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。\n但是，这种 IO 模型同样存在问题：应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。\nIO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -\u003e 用户空间）还是阻塞的。\nAIO (Asynchronous I/O) AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。\n异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。\nIO IO 即 Input/Output，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。\nJava IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。\nInputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。 OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。 InputStream用于从源头（通常是文件）读取数据（字节信息）到内存中，java.io.InputStream抽象类是所有字节输入流的父类。\n需要注意的是InputStream、Reader、OutputStream、Writer四种类都是抽象类无法直接使用。\n其中四种类最常用的子类是FileInputStream、FileReader、FileOutputStream、FileWriter\n字节流 InputStream（字节输入流） InputStream 常用方法 ：\nread() ：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 -1 ，表示文件结束。 read(byte b[ ]) : 从输入流中读取一些字节存储到数组 b 中。如果数组 b 的长度为零，则不读取。如果没有可用字节读取，返回 -1。如果有可用字节读取，则最多读取的字节数最多等于 b.length ， 返回读取的字节数。这个方法等价于 read(b, 0, b.length)。 read(byte b[], int off, int len) ：在read(byte b[ ]) 方法的基础上增加了 off 参数（偏移量）和 len参数（要读取的最大字节数）。 skip(long n) ：忽略输入流中的 n 个字节 ,返回实际忽略的字节数。 available() ：返回输入流中可以读取的字节数。 close() ：关闭输入流释放相关的系统资源。 从 Java 9 开始，InputStream 新增加了多个实用的方法：\nreadAllBytes() ：读取输入流中的所有字节，返回字节数组。 readNBytes(byte[] b, int off, int len) ：阻塞直到读取 len 个字节。 transferTo(OutputStream out) ： 将所有字节从一个输入流传递到一个输出流。 FileInputStream 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。\nFileInputStream 代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 try (InputStream fis = new FileInputStream(\"input.txt\")) { System.out.println(\"Number of remaining bytes:\" + fis.available()); int content; long skip = fis.skip(2); System.out.println(\"The actual number of bytes skipped:\" + skip); System.out.print(\"The content read from file:\"); while ((content = fis.read()) != -1) { System.out.print((char) content); } } catch (IOException e) { e.printStackTrace(); } OutputStream（字节输出流） OutputStream用于将数据（字节信息）写入到目的地（通常是文件），java.io.OutputStream抽象类是所有字节输出流的父类。\nOutputStream 常用方法 ：\nwrite(int b) ：将特定字节写入输出流。 write(byte b[]) : 将数组b 写入到输出流，等价于 write(b, 0, b.length) 。 write(byte[] b, int off, int len) : 在write(byte b[ ]) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字节数）。 flush() ：刷新此输出流并强制写出所有缓冲的输出字节。 close() ：关闭输出流释放相关的系统资源。 FileOutputStream 是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。\nFileOutputStream 代码示例：\n1 2 3 4 5 6 try (FileOutputStream output = new FileOutputStream(\"output.txt\")) { byte[] array = \"King\".getBytes(); output.write(array); } catch (IOException e) { e.printStackTrace(); } 字符流 不管是文件读写还是网络发送接收，信息的最小存储单元都是字节。 那为什么 I/O 流操作要分为字节流操作和字符流操作呢？\n个人认为主要有两点原因：\n字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时。 如果我们不知道编码类型就很容易出现乱码问题。 乱码问题这个很容易就可以复现，我们只需要将上面提到的 FileInputStream 代码示例中的 input.txt 文件内容改为中文即可，原代码不需要改动。\n因此，I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。字符流默认采用的是 Unicode 编码，我们可以通过构造方法自定义编码。\nReader（字符输入流） Reader用于从源头（通常是文件）读取数据（字符信息）到内存中，java.io.Reader抽象类是所有字符输入流的父类。\nReader 用于读取文本， InputStream 用于读取原始字节。\nReader 常用方法 ：\nread() : 从输入流读取一个字符。 read(char[] cbuf) : 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中，等价于 read(cbuf, 0, cbuf.length) 。 read(char[] cbuf, int off, int len) ：在read(char[] cbuf) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字符数）。 skip(long n) ：忽略输入流中的 n 个字符 ,返回实际忽略的字符数。 close() : 关闭输入流并释放相关的系统资源。 InputStreamReader 是字节流转换为字符流的桥梁，其子类 FileReader 是基于该基础上的封装，可以直接操作字符文件。InputStreamReader实质是对InputStream的一次封装，根据不同的编码方式将字节转化为字符。从这也可以看出真正具备读取、书写能力的是字节流，字符流是对字节流的一层封装使得流更加好用了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 字节流转换为字符流的桥梁 public class InputStreamReader extends Reader { public InputStreamReader(InputStream in) { // 构造时就需要一个InputStream ... 省略 } ... 省略 } // 用于读取字符文件 public class FileReader extends InputStreamReader { public FileReader(String fileName) throws FileNotFoundException { super(new FileInputStream(fileName));// 创建了一个InputStream传递给InputStreamReader的构造函数 } ... 省略 } FileReader 代码示例：FileReader继承自InputStreamReader，使用InputStreamReader将字节转化为字符的能力进行字符的读取。\n1 2 3 4 5 6 7 8 9 10 11 try (FileReader fileReader = new FileReader(\"input.txt\");) { int content; long skip = fileReader.skip(3); System.out.println(\"The actual number of bytes skipped:\" + skip); System.out.print(\"The content read from file:\"); while ((content = fileReader.read()) != -1) { System.out.print((char) content); } } catch (IOException e) { e.printStackTrace(); } Writer（字符输出流） Writer用于将数据（字符信息）写入到目的地（通常是文件），java.io.Writer抽象类是所有字符输出流的父类。\nWriter 常用方法 ：\nwrite(int c) : 写入单个字符。 write(char[] cbuf) ：写入字符数组 cbuf，等价于write(cbuf, 0, cbuf.length)。 write(char[] cbuf, int off, int len) ：在write(char[] cbuf) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字符数）。 write(String str) ：写入字符串，等价于 write(str, 0, str.length()) 。 write(String str, int off, int len) ：在write(String str) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字符数）。 append(CharSequence csq) ：将指定的字符序列附加到指定的 Writer 对象并返回该 Writer 对象。 append(char c) ：将指定的字符附加到指定的 Writer 对象并返回该 Writer 对象。 flush() ：刷新此输出流并强制写出所有缓冲的输出字符。 close():关闭输出流释放相关的系统资源。 OutputStreamWriter 是字符流转换为字节流的桥梁，其子类 FileWriter 是基于该基础上的封装，可以直接将字符写入到文件。其中转化的调用不再做介绍了与Reader相同。\n1 2 3 4 5 6 // 字符流转换为字节流的桥梁 public class OutputStreamWriter extends Writer { } // 用于写入字符到文件 public class FileWriter extends OutputStreamWriter { } FileWriter 代码示例：\n1 2 3 4 5 try (Writer output = new FileWriter(\"output.txt\")) { output.write(\"你好，我是King。\"); } catch (IOException e) { e.printStackTrace(); } InputStreamReader、OutputStreamWriter两者也被称为转换流，这两个流是Reader和Writer实现的基础。下面两者的作用是相同的（源码中也是这么实现的）并且InputStreamReader就是Reader的子类，后面在外层嵌套装饰流时作为Reader（不要弄错了）。\n1 2 FileReader reader = new FileReader(\"XXX\"); InputStreamReader reader2 = new InputStreamReader(new FileInputStream(\"XXX\")); 并且存在的字符流都存在对应的字节流（基本都是通过字节流实现的）。\n装饰流 FilterInputStream、FilterOutputStream、FilterReader、FilterWriter\n这四种流分别继承自上述的四种流，知道装饰者模式的朋友对这四个流应该就非常熟悉了，这四种流的作用也十分简单：就是为基础流提供扩展时以这些流作为基础。这四个基本的装饰流没有提供任何额外的功能，继承自对应的流，并且重写了对应的方法，但是方法中没有进行过多的处理，之间调用了四种基础流的内容。\n用法就是在创建装饰流时用已经创建好的基础流或者基础流的子类作为对象进行传入，装饰流相当对基础流的方法进行了扩展。下面要讲的缓冲流、打印流、数据流、对象流都是继承自这四种装饰流。\n其实最基础的功能均由基础的四种流提供。\n缓冲流 缓冲流的主要作用就是减少IO次数以提高性能，在大数据流读取的环境下建议使用。\n字节缓冲流 IO 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取/写入多个字节，从而避免频繁的 IO 操作，提高流的传输效率。\n字节缓冲流这里采用了装饰器模式来增强 InputStream 和OutputStream子类对象的功能。\n举个例子，我们可以通过 BufferedInputStream（字节缓冲输入流）来增强 FileInputStream 的功能。\n1 2 // 新建一个 BufferedInputStream 对象 BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\"input.txt\")); 在读取大文件时建议使用缓冲流套一层，效果会比较好。\nBufferedInputStream（字节缓冲输入流） BufferedInputStream 从源头（通常是文件）读取数据（字节信息）到内存的过程中不会一个字节一个字节的读取，而是会先将读取到的字节存放在缓存区，并从内部缓冲区中单独读取字节。这样大幅减少了 IO 次数，提高了读取效率。BufferedInputStream 内部维护了一个缓冲区，这个缓冲区实际就是一个字节数组。\n缓冲区的大小默认为 8192 字节，可以通过 BufferedInputStream(InputStream in, int size) 这个构造方法来指定缓冲区的大小。\nBufferedOutputStream（字节缓冲输出流） BufferedOutputStream 将数据（字节信息）写入到目的地（通常是文件）的过程中不会一个字节一个字节的写入，而是会先将要写入的字节存放在缓存区，并从内部缓冲区中单独写入字节。这样大幅减少了 IO 次数，提高了读取效率\n1 2 3 4 5 6 try (BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"output.txt\"))) { byte[] array = \"King\".getBytes(); bos.write(array); } catch (IOException e) { e.printStackTrace(); } 类似于 BufferedInputStream ，BufferedOutputStream 内部也维护了一个缓冲区，并且，这个缓存区的大小也是 8192 字节。\n字符缓冲流 BufferedReader （字符缓冲输入流）和 BufferedWriter（字符缓冲输出流）类似于 BufferedInputStream（字节缓冲输入流）和BufferedOutputStream（字节缓冲输入流），内部都维护了一个字节数组作为缓冲区。不过，前者主要是用来操作字符信息。\n打印流 这里需要介绍的两个打印流就是我们常用的Scanner与PrintStream。\nScanner 这个类更像是一个工具类，其本质就是在初始化时接受一个InputStream对象，然后从这个对象中接受数据，并且提供了非常多的方法使你读取对象中的数据，我们常常将System.in对象传入，这个是控制台我们并不能主动创建，是通过c++实现的，我们只能从System类中取出来用。\n想要读取控制台的数据其实还可以使用其他方式：\n1 2 3 4 byte[] x = new byte[10]; BufferedInputStream inputStream1 = new BufferedInputStream(System.in); inputStream1.read(x); System.in.read(x); 只不过通过这种方法读取的数据是byte，需要自己进行类型转化十分的不方便，而Scanner就是封装好了各种类型转化的方法咱们直接拿来用就好。\nPrintStream 本质是个装饰类，需要设置真正读取数据的OutputStream对象，System.out中的这个对象是通过C++实现的可以直接拿来用。通过反射我们可以看到底层还是通过FileOutputStream实现，但是在FileOutputStream是使用了FileDescriptor进行实现，该对象已经通过默认句柄封装好了，还有兴趣往下探索的可以看jvm的源码。\nPrintStream存在自动刷新机制，例如当向PrintStream流中写入一个字节数组后自动调用flush()方法。PrintStream也永远不会抛出异常，而是使用内部检查机制checkError()方法进行错误检查。最方便的是，它能够格式化任意的类型，将它们以字符串的形式写入到输出流。\n数据流 DataInputStream和DataOutputStream可以直接将字节转化为需要的类型，通常是基本类型。\n对象流 ObjectOutputStream、ObjectOInputStream通常用于序列化与反序列化（Java原生的序列号与反序列化）。\nNIO 缓冲区 Buffer中共定义了四个变量，用于控制缓冲区内数据的位置：mark-用于标记位置，在读时用到、position-标记现在处在的位置用于存放读取数据、limit-用于现实position的最大位置、capacity-标记缓冲区大小。\nBuffer类是缓冲区的实现，类似于Java中的数组，也是用于存放和获取数据的。但是Buffer相比Java中的数组，功能就非常强大了，它包含一系列对于数组的快捷操作。\nBuffer是一个抽象类，它的核心内容：（除了capacity其余的变量都是可以通过方法直接设置位置的）\n1 2 3 4 5 6 7 8 9 10 public abstract class Buffer { // 这四个变量的关系: mark \u003c= position \u003c= limit \u003c= capacity // 这些变量就是Buffer操作的核心了，之后我们学习的过程中可以看源码是如何操作这些变量的 private int mark = -1; private int position = 0; private int limit; private int capacity; // 直接缓冲区实现子类的数据内存地址（之后会讲解） long address; } 我们来看看Buffer类的子类，包括我们认识到的所有基本类型（除了boolean类型之外）：\nIntBuffer - int类型的缓冲区。\nShortBuffer - short类型的缓冲区。\nLongBuffer - long类型的缓冲区。\nFloatBuffer - float类型的缓冲区。\nDoubleBuffer - double类型的缓冲区。\nByteBuffer - byte类型的缓冲区。\nCharBuffer - char类型的缓冲区。\n缓冲区构造 构造缓冲区有两个方法：\n1 2 3 4 5 6 7 8 public static void main(String[] args) { //创建一个缓冲区不能直接new，而是需要使用静态方法去生成，有两种方式： //1. 申请一个容量为10的int缓冲区 IntBuffer buffer = IntBuffer.allocate(10); //2. 可以将现有的数组直接转换为缓冲区（包括数组中的数据） int[] arr = new int[]{1, 2, 3, 4, 5, 6}; IntBuffer buffer = IntBuffer.wrap(arr); } 下面以IntBuffer为例分别看一下两个方法的内容，其中会用到的类的一个继承关系：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // allocate // IntBuffer public static IntBuffer allocate(int capacity) { if (capacity \u003c 0) throw new IllegalArgumentException(); return new HeapIntBuffer(capacity, capacity); } // HeapIntBuffer HeapIntBuffer(int cap, int lim) { super(-1, 0, lim, cap, new int[cap], 0); } // IntBuffer IntBuffer(int mark, int pos, int lim, int cap, int[] hb, int offset){ super(mark, pos, lim, cap); this.hb = hb; this.offset = offset; } // Buffer Buffer(int mark, int pos, int lim, int cap) { if (cap \u003c 0) throw new IllegalArgumentException(\"Negative capacity: \" + cap); this.capacity = cap; limit(lim); position(pos); if (mark \u003e= 0) { if (mark \u003e pos) throw new IllegalArgumentException(\"mark \u003e position: (\" + mark + \" \u003e \" + pos + \")\"); this.mark = mark; } } 上述方法有一点需要注意：这些构造方法的修饰权限是默认的，所以我们无法直接使用构造函数进行创建。\n在IntBuffer方法中创建了数组用于存放缓冲数据，这就是缓冲区的底层实现，然后对刚刚提到的Buffer中的四个标志进行了初始化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // wrap // IntBuffer public static IntBuffer wrap(int[] array) { return wrap(array, 0, array.length); } public static IntBuffer wrap(int[] array, int offset, int length){ try { return new HeapIntBuffer(array, offset, length); } catch (IllegalArgumentException x) { throw new IndexOutOfBoundsException(); } } // HeapintBuffer HeapIntBuffer(int[] buf, int off, int len) { super(-1, off, off + len, buf.length, buf, 0); } 缓冲区写操作 数据的存放包括以下四个方法：\npublic abstract IntBuffer put(int i); - 在当前position位置插入数据，由具体子类实现\npublic abstract IntBuffer put(int index, int i); - 在指定位置存放数据，也是由具体子类实现\npublic final IntBuffer put(int[] src); - 直接存放所有数组中的内容（数组长度不能超出缓冲区大小）\npublic IntBuffer put(int[] src, int offset, int length); - 直接存放数组中的内容，同上，但是可以指定存放一段范围\npublic IntBuffer put(IntBuffer src); - 直接存放另一个缓冲区中的内容\nput操作实际就是在position的位置插入一个数据，然后向后移动一位，并且会检查是否超多了限制limit：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public IntBuffer put(int x) { hb[ix(nextPutIndex())] = x; //这个ix和nextPutIndex()很灵性，我们来看看具体实现 return this; } protected int ix(int i) { return i + offset; //将i的值加上我们之前设定的offset偏移量值，但是默认是0（非0的情况后面会介绍） } final int nextPutIndex() { int p = position; //获取Buffer类中的position位置（一开始也是0） if (p \u003e= limit) //位置肯定不能超过底层数组最大长度，否则越界 throw new BufferOverflowException(); position = p + 1; //获取之后会使得Buffer类中的position+1 return p; //返回当前的位置 }\t第二种put方法就是直接在指定位置写入数据（若原先存在数据也是直接覆盖）\n1 2 3 4 5 6 7 8 9 10 public IntBuffer put(int i, int x) { hb[ix(checkIndex(i))] = x; //这里依然会使用ix，但是会检查位置是否合法 return this; } final int checkIndex(int i) { // package-private if ((i \u003c 0) || (i \u003e= limit)) //插入的位置不能小于0并且不能大于等于底层数组最大长度 throw new IndexOutOfBoundsException(); return i; //没有问题就把i返回 } 第三种put\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public IntBuffer put(int[] src, int offset, int length) { checkBounds(offset, length, src.length); //检查截取范围是否合法，给offset、调用者指定长度、数组实际长度 if (length \u003e remaining()) //接着判断要插入的数据量在缓冲区是否容得下，装不下也不行 throw new BufferOverflowException(); int end = offset + length; //计算出最终读取位置，下面开始for for (int i = offset; i \u003c end; i++) this.put(src[i]); return this; } static void checkBounds(int off, int len, int size) { if ((off | len | (off + len) | (size - (off + len))) \u003c 0) throw new IndexOutOfBoundsException(); } public final int remaining() { //计算并获取当前缓冲区的剩余空间 int rem = limit - position; //最大容量减去当前位置，就是剩余空间 return rem \u003e 0 ? rem : 0; //没容量就返回0 }\t第四种put，方法内会将形参缓冲区position到limit之间的数据存入当前缓冲区，get方法会将position继续向后推！！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public IntBuffer put(IntBuffer src) { if (src == this) throw new IllegalArgumentException(); if (isReadOnly()) throw new ReadOnlyBufferException(); int n = src.remaining(); //给进来的src看看容量 if (n \u003e remaining()) //这里判断当前剩余容量是否小于src容量 throw new BufferOverflowException(); for (int i = 0; i \u003c n; i++) //也是从position位置开始继续写入 put(src.get()); //通过get方法一个一个读取数据出来 return this; } public int get() { return hb[ix(nextGetIndex())]; } final int nextGetIndex() { int p = position; if (p \u003e= limit) throw new BufferUnderflowException(); position = p + 1; return p; } 所以这第四种put方式存在一些陷阱，通过allocate创建缓冲区并且在缓冲区内添加数据后position处在下一个可以添加的位置，limit指向最后，因此这两者中间的数据是还未被添加的默认值0，这时候使用第四种put并不能起到效果，解决方法是在put前flip一下。或者使用wrap进行创建，这种方法创建得到的缓冲区内的默认值是创建时传入的形参，但是几个标记变量的值还是和allocate一样的，当你插入过数据后到底想要什么数据就需要注意了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static void main(String[] args) { IntBuffer src = IntBuffer.allocate(5); for (int i = 0; i \u003c 5; i++) src.put(i); //手动插入数据 IntBuffer buffer = IntBuffer.allocate(10); buffer.put(src); System.out.println(Arrays.toString(buffer.array())); } public final Buffer flip() { limit = position; //修改limit值，当前写到哪里，下次读的最终位置就是这里 position = 0; //position归零 mark = -1; //标记还原为-1 return this; } 缓冲区读操作 前面我们看完了写操作，现在我们接着来看看读操作。读操作有四个方法：\npublic abstract int get(); - 直接获取当前position位置的数据，由子类实现\npublic abstract int get(int index); - 获取指定位置的数据，也是子类实现\npublic IntBuffer get(int[] dst) - 将数据读取到给定的数组中\npublic IntBuffer get(int[] dst, int offset, int length) - 同上，加了个范围\n第一种在上面已经看到过了\n1 2 3 4 5 6 7 8 9 10 11 public int get() { return hb[ix(nextGetIndex())]; } final int nextGetIndex() { int p = position; if (p \u003e= limit) throw new BufferUnderflowException(); position = p + 1; return p; } 第二种\n1 2 3 public int get(int i) { return hb[ix(checkIndex(i))]; //这里依然是使用checkIndex来检查位置是否非法 } 第三四种\n1 2 3 4 5 6 7 8 9 10 11 12 13 public IntBuffer get(int[] dst, int offset, int length) { checkBounds(offset, length, dst.length); //跟put操作一样，也是需要检查是否越界 if (length \u003e remaining()) //如果读取的长度比可以读的长度大，那肯定是不行的 throw new BufferUnderflowException(); int end = offset + length; //计算出最终读取位置 for (int i = offset; i \u003c end; i++) dst[i] = get(); //开始从position把数据读到数组中，注意是在数组的offset位置开始 return this; } public IntBuffer get(int[] dst) { return get(dst, 0, dst.length); //不指定范围的话，那就直接用上面的 } 还能直接获取底层实现的数组\n1 2 3 4 5 6 7 public final int[] array() { if (hb == null) //为空那说明底层不是数组实现的，肯定就没法转换了 throw new UnsupportedOperationException(); if (isReadOnly) //只读也是不让直接取出的，因为一旦取出去岂不是就能被修改了 throw new ReadOnlyBufferException(); return hb; //直接返回hb } 还可以使用mark、reset进行position的跳转\npublic final Buffer mark() - 标记当前位置\npublic final Buffer reset() - 让当前的position位置跳转到mark当时标记的位置\n1 2 3 4 5 6 7 8 9 10 11 public final Buffer mark() { mark = position; return this; } public final Buffer reset() { int m = mark; //存一下当前的mark位置 if (m \u003c 0) //因为mark默认是-1 throw new InvalidMarkException(); position = m; //直接让position变成mark位置 return this; } 缓冲区其他操作 前面我们大致了解了一下缓冲区的读写操作，除了常规的读写操作之外，还有哪些其他的操作：\npublic abstract IntBuffer compact() - 压缩缓冲区，由具体实现类实现\npublic IntBuffer duplicate() - 复制缓冲区，会直接创建一个新的数据相同的缓冲区\npublic abstract IntBuffer slice() - 划分缓冲区，会将原本的容量大小的缓冲区划分为更小的出来进行操作\npublic final Buffer rewind() - 重绕缓冲区，其实就是把position归零，然后mark变回-1\npublic final Buffer clear() - 将缓冲区清空，所有的变量变回最初的状态\n我们先从压缩缓冲区开始看起，它会将整个缓冲区的大小和数据内容变成position位置到limit之间的数据，并移动到数组头部：\n1 2 3 4 5 6 7 8 9 10 11 public IntBuffer compact() { int pos = position(); //获取当前位置 int lim = limit(); //获取当前最大position位置 assert (pos \u003c= lim); //断言表达式，position必须小于最大位置，肯定的 int rem = (pos \u003c= lim ? lim - pos : 0); //计算pos距离最大位置的长度 System.arraycopy(hb, ix(pos), hb, ix(0), rem); //直接将hb数组当前position位置的数据拷贝到头部去，然后长度改成刚刚计算出来的空间 position(rem); //直接将position移动到rem位置 limit(capacity()); //pos最大位置修改为最大容量 discardMark(); //mark变回-1 return this; } 复制缓冲区，原来的改变新创建的缓冲区中的数据也会改变，因为hb用的是一个\n1 2 3 4 5 6 7 8 public IntBuffer duplicate() { //直接new一个新的，但是是吧hb给丢进去了，而不是拷贝一个新的 return new HeapIntBuffer(hb, this.markValue(), this.position(), this.limit(), this.capacity(), offset); } 划分缓冲区，和复制类似都用的是旧的hb\n1 2 3 4 5 6 7 8 9 10 11 public IntBuffer slice() { int pos = this.position(); //获取当前position int lim = this.limit(); //获取position最大位置 int rem = (pos \u003c= lim ? lim - pos : 0); //求得剩余空间 return new HeapIntBuffer(hb, //返回一个新的划分出的缓冲区，但是底层的数组用的还是同一个 -1, 0, rem, //新的容量变成了剩余空间的大小 rem, pos + offset); //可以看到offset的地址不再是0了，而是当前的position加上原有的offset值 } 缓冲区的比较 equals、compateTo都是比较两个缓冲区从当前position开始的内容是否一致。\n只读缓冲区 所有的put方法不能用了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public IntBuffer asReadOnlyBuffer() { return new HeapIntBufferR(hb, //注意这里并不是直接创建了HeapIntBuffer，而是HeapIntBufferR，并且直接复制的hb数组 this.markValue(), this.position(), this.limit(), this.capacity(), offset); } // HeapIntBufferR public IntBuffer put(int x) { throw new ReadOnlyBufferException(); } public IntBuffer put(int i, int x) { throw new ReadOnlyBufferException(); } public IntBuffer put(int[] src, int offset, int length) { throw new ReadOnlyBufferException(); } public IntBuffer put(IntBuffer src) { throw new ReadOnlyBufferException(); } 通道 在传统IO中，我们都是通过流进行传输，数据会源源不断从流中传出；而在NIO中，数据是放在缓冲区中进行管理，再使用通道将缓冲区中的数据传输到目的地。\n通道接口层次 通道的根基接口是Channel，所以的派生接口和类都是从这里开始的，我们来看看它定义了哪些基本功能：\n1 2 3 4 5 6 7 public interface Channel extends Closeable { //通道是否处于开启状态 public boolean isOpen(); //因为通道开启也需要关闭，所以实现了Closeable接口 public void close() throws IOException; } 我们接着来看看它的一些子接口，首先是最基本的读写操作：\n1 2 3 4 public interface ReadableByteChannel extends Channel { //将通道中的数据读取到给定的缓冲区中 public int read(ByteBuffer dst) throws IOException; } 1 2 3 4 public interface WritableByteChannel extends Channel { //将给定缓冲区中的数据写入到通道中 public int write(ByteBuffer src) throws IOException; } 有了读写功能后，最后整合为了一个ByteChannel接口：\n1 2 public interface ByteChannel extends ReadableByteChannel, WritableByteChannel{ } 比如现在我们要实现从输入流中读取数据然后打印出来，那么之前传统IO的写法：\n1 2 3 4 5 6 7 8 9 10 11 12 public static void main(String[] args) throws IOException { //数组创建好，一会用来存放从流中读取到的数据 byte[] data = new byte[10]; //直接使用输入流 InputStream in = System.in; while (true) { int len; while ((len = in.read(data)) \u003e= 0) { //将输入流中的数据一次性读取到数组中 System.out.print(\"读取到一批数据：\"+new String(data, 0, len)); //读取了多少打印多少 } } } 而现在我们使用通道之后：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public static void main(String[] args) throws IOException { //缓冲区创建好，一会就靠它来传输数据 ByteBuffer buffer = ByteBuffer.allocate(10); //将System.in作为输入源，一会Channel就可以从这里读取数据，然后通过缓冲区装载一次性传递数据 ReadableByteChannel readChannel = Channels.newChannel(System.in); while (true) { //将通道中的数据写到缓冲区中，缓冲区最多一次装10个 readChannel.read(buffer); //写入操作结束之后，需要进行翻转，以便接下来的读取操作 buffer.flip(); //最后转换成String打印出来康康 System.out.println(\"读取到一批数据：\"+new String(buffer.array(), 0, buffer.remaining())); //回到最开始的状态 buffer.clear(); } } 乍一看，好像感觉也没啥区别，不就是把数组换成缓冲区了吗，效果都是一样的，数据也是从Channel中读取得到，并且通过缓冲区进行数据装载然后得到结果，但是，Channel不像流那样是单向的，它就像它的名字一样，一个通道可以从一端走到另一端，也可以从另一端走到这一端，我们后面进行介绍。\n文件传输FileChannel 前面我们介绍了通道的基本情况，这里我们就来尝试实现一下文件的读取和写入，在传统IO中，文件的写入和输出都是依靠FileOutputStream和FileInputStream来完成的：\n1 2 3 4 5 6 7 8 9 10 11 12 public static void main(String[] args) throws IOException { try(FileOutputStream out = new FileOutputStream(\"test.txt\"); FileInputStream in = new FileInputStream(\"test.txt\")){ String data = \"King\"; out.write(data.getBytes()); //向文件的输出流中写入数据，也就是把数据写到文件中 out.flush(); byte[] bytes = new byte[in.available()]; in.read(bytes); //从文件的输入流中读取文件的信息 System.out.println(new String(bytes)); } } 而现在，我们只需要通过一个FileChannel就可以完成这两者的操作，获取文件通道的方式有以下几种：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static void main(String[] args) throws IOException { //1. 直接通过输入或输出流获取对应的通道 FileInputStream in = new FileInputStream(\"test.txt\"); //但是这里的通道只支持读取或是写入操作 FileChannel channel = in.getChannel(); //创建一个容量为128的缓冲区 ByteBuffer buffer = ByteBuffer.allocate(128); //从通道中将数据读取到缓冲区中 channel.read(buffer); //翻转一下，接下来要读取了 buffer.flip(); System.out.println(new String(buffer.array(), 0, buffer.remaining())); } 1 2 3 4 5 6 7 8 public static void main(String[] args) throws IOException { //1. 直接通过输入或输出流获取对应的通道 FileInputStream in = new FileInputStream(\"test.txt\"); //但是这里的通道只支持读取或是写入操作 FileChannel channel = in.getChannel(); //尝试写入一下 channel.write(ByteBuffer.wrap(\"King\".getBytes())); } 从FileInputStream获得的通道无法进行写操作，同样的FileOutputStream获得的通道只能进行写操作，无法进行读操作。\n可以看到输出流生成的Channel又不支持读取，所以说本质上还是保持着输入输出流的特性，但是之前不是说Channel又可以输入又可以输出吗？这里我们来看看第二种方式：\n1 2 //RandomAccessFile能够支持文件的随机访问，并且实现了数据流 public class RandomAccessFile implements DataOutput, DataInput, Closeable { 我们可以通过RandomAccessFile来创建通道：\n1 2 3 4 5 6 7 8 9 10 11 12 public static void main(String[] args) throws IOException { /* 通过RandomAccessFile进行创建，注意后面的mode有几种： r 以只读的方式使用 rw 读操作和写操作都可以 rws 每当进行写操作，同步的刷新到磁盘，刷新内容和元数据 rwd 每当进行写操作，同步的刷新到磁盘，刷新内容 */ try(RandomAccessFile f = new RandomAccessFile(\"test.txt\", \"\")){ } } 现在我们来测试一下它的读写操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public static void main(String[] args) throws IOException { /* 通过RandomAccessFile进行创建，注意后面的mode有几种： r 以只读的方式使用 rw 读操作和写操作都可以 rws 每当进行写操作，同步的刷新到磁盘，刷新内容和元数据 rwd 每当进行写操作，同步的刷新到磁盘，刷新内容 */ try(RandomAccessFile f = new RandomAccessFile(\"test.txt\", \"rw\"); //这里设定为支持读写，这样创建的通道才能具有这些功能 FileChannel channel = f.getChannel()){ //通过RandomAccessFile创建一个通道 channel.write(ByteBuffer.wrap(\"King\".getBytes())); System.out.println(\"写操作完成之后文件访问位置：\"+channel.position()); //注意读取也是从现在的位置开始 channel.position(0); //需要将位置变回到最前面，这样下面才能从文件的最开始进行读取 ByteBuffer buffer = ByteBuffer.allocate(128); channel.read(buffer); buffer.flip(); System.out.println(new String(buffer.array(), 0, buffer.remaining())); } } 可以看到，一个FileChannel既可以完成文件读取，也可以完成文件的写入。\n除了基本的读写操作，我们也可以直接对文件进行截断：\n1 2 3 4 5 6 7 8 9 10 11 12 public static void main(String[] args) throws IOException { try(RandomAccessFile f = new RandomAccessFile(\"test.txt\", \"rw\"); FileChannel channel = f.getChannel()){ //截断文件，只留前20个字节 channel.truncate(20); ByteBuffer buffer = ByteBuffer.allocate(128); channel.read(buffer); buffer.flip(); System.out.println(new String(buffer.array(), 0, buffer.remaining())); } } 可以看到文件的内容直接被截断了，文件内容就只剩一半了。\n当然，如果我们要进行文件的拷贝，也是很方便的，只需要使用通道就可以，比如我们现在需要将一个通道的数据写入到另一个通道，就可以直接使用transferTo方法：\n1 2 3 4 5 6 7 8 public static void main(String[] args) throws IOException { try(FileOutputStream out = new FileOutputStream(\"test2.txt\"); FileInputStream in = new FileInputStream(\"test.txt\")){ FileChannel inChannel = in.getChannel(); //获取到test文件的通道 inChannel.transferTo(0, inChannel.size(), out.getChannel()); //直接将test文件通道中的数据转到test2文件的通道中 } } 可以看到执行后，文件的内容全部被复制到另一个文件了。\n当然，反向操作也是可以的：\n1 2 3 4 5 6 7 8 public static void main(String[] args) throws IOException { try(FileOutputStream out = new FileOutputStream(\"test2.txt\"); FileInputStream in = new FileInputStream(\"test.txt\")){ FileChannel inChannel = in.getChannel(); //获取到test文件的通道 out.getChannel().transferFrom(inChannel, 0, inChannel.size()); //直接将从test文件通道中传来的数据转给test2文件的通道 } } 当我们要编辑某个文件时，通过使用MappedByteBuffer类，可以将其映射到内存中进行编辑，编辑的内容会同步更新到文件中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //注意一定要是可写的，不然无法进行修改操作 try(RandomAccessFile f = new RandomAccessFile(\"test.txt\", \"rw\"); FileChannel channel = f.getChannel()){ //通过map方法映射文件的某一段内容，创建MappedByteBuffer对象 //比如这里就是从第四个字节开始，映射10字节内容到内存中 //注意这里需要使用MapMode.READ_WRITE模式，其他模式无法保存数据到文件 MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 4, 10); //我们可以直接对在内存中的数据进行编辑，也就是编辑Buffer中的内容 //注意这里写入也是从pos位置开始的，默认是从0开始，相对于文件就是从第四个字节开始写 //注意我们只映射了10个字节，也就是写的内容不能超出10字节了 buffer.put(\"yyds\".getBytes()); //编辑完成后，通过force方法将数据写回文件的映射区域 buffer.force(); } 可以看到，文件的某一个区域已经被我们修改了，并且这里实际上使用的就是DirectByteBuffer直接缓冲区，效率还是很高的。\n文件锁FileLock 我们可以创建一个跨进程文件锁来防止多个进程之间的文件争抢操作（注意这里是进程，不是线程）FileLock是文件锁，它能保证同一时间只有一个进程（程序）能够修改它，或者都只可以读，这样就解决了多进程间的同步文件，保证了安全性。但是需要注意的是，它进程级别的，不是线程级别的，他可以解决多个进程并发访问同一个文件的问题，但是它不适用于控制同一个进程中多个线程对一个文件的访问。\n那么我们来看看如何使用文件锁：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public static void main(String[] args) throws IOException, InterruptedException { //创建RandomAccessFile对象，并拿到Channel RandomAccessFile f = new RandomAccessFile(\"test.txt\", \"rw\"); FileChannel channel = f.getChannel(); System.out.println(new Date() + \" 正在尝试获取文件锁...\"); //接着我们直接使用lock方法进行加锁操作（如果其他进程已经加锁，那么会一直阻塞在这里） //加锁操作支持对文件的某一段进行加锁，比如这里就是从0开始后的6个字节加锁，false代表这是一把独占锁 //范围锁甚至可以提前加到一个还未写入的位置上 FileLock lock = channel.lock(0, 6, false); System.out.println(new Date() + \" 已获取到文件锁！\"); Thread.sleep(5000); //假设要处理5秒钟 System.out.println(new Date() + \" 操作完毕，释放文件锁！\"); //操作完成之后使用release方法进行锁释放 lock.release(); } 有关共享锁和独占锁：\n进程对文件加独占锁后，当前进程对文件可读可写，独占此文件，其它进程是不能读该文件进行读写操作的。\n进程对文件加共享锁后，进程可以对文件进行读操作，但是无法进行写操作，共享锁可以被多个进程添加，但是只要存在共享锁，就不能添加独占锁。\n当然，除了直接使用lock()方法进行加锁之外，我们也可以使用tryLock()方法以非阻塞方式获取文件锁，但是如果获取锁失败会得到null。\n选择器 Selector 一般称 为选择器 ，当然你也可以翻译为 多路复用器 。它是Java NIO核心组件中的一个，用于检查一个或多个NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个channels,也就是可以管理多个网络链接。\n使用Selector的好处在于： 使用更少的线程来就可以来处理通道了， 相比使用多个线程，避免了线程上下文切换带来的开销。\nSelector的使用方法介绍 1. Selector的创建 通过调用Selector.open()方法创建一个Selector对象，如下：\n1 Selector selector = Selector.open(); 这里需要说明一下\n2. 注册Channel到Selector 1 2 channel.configureBlocking(false); SelectionKey key = channel.register(selector, Selectionkey.OP_READ); Channel必须是非阻塞的。 所以FileChannel不适用Selector，因为FileChannel不能切换为非阻塞模式，更准确的来说是因为FileChannel没有继承SelectableChannel。Socket channel可以正常使用。\nSelectableChannel抽象类 有一个 configureBlocking（） 方法用于使通道处于阻塞模式或非阻塞模式。\n1 abstract SelectableChannel configureBlocking(boolean block) 注意：\nSelectableChannel抽象类的configureBlocking（） 方法是由 AbstractSelectableChannel抽象类实现的，SocketChannel、ServerSocketChannel、DatagramChannel都是直接继承了 AbstractSelectableChannel抽象类 。 大家有兴趣可以看看NIO的源码，各种抽象类和抽象类上层的抽象类。我本人暂时不准备研究NIO源码，因为还有很多事情要做，需要研究的同学可以自行看看。\nregister() 方法的第二个参数。这是一个“ interest集合 ”，意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件：\nConnect Accept Read Write 通道触发了一个事件意思是该事件已经就绪。比如某个Channel成功连接到另一个服务器称为“ 连接就绪 ”。一个Server Socket Channel准备好接收新进入的连接称为“ 接收就绪 ”。一个有数据可读的通道可以说是“ 读就绪 ”。等待写数据的通道可以说是“ 写就绪 ”。\n这四种事件用SelectionKey的四个常量来表示：\n1 2 3 4 SelectionKey.OP_CONNECT SelectionKey.OP_ACCEPT SelectionKey.OP_READ SelectionKey.OP_WRITE 如果你对不止一种事件感兴趣，使用或运算符即可，如下：\n1 int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE; 3. SelectionKey介绍 一个SelectionKey键表示了一个特定的通道对象和一个特定的选择器对象之间的注册关系。\n1 2 3 4 5 key.attachment(); //返回SelectionKey的attachment，attachment可以在注册channel的时候指定。 key.channel(); // 返回该SelectionKey对应的channel。 key.selector(); // 返回该SelectionKey对应的Selector。 key.interestOps(); //返回代表需要Selector监控的IO操作的bit mask key.readyOps(); // 返回一个bit mask，代表在相应channel上可以进行的IO操作。 key.interestOps():\n我们可以通过以下方法来判断Selector是否对Channel的某种事件感兴趣\n1 2 3 4 5 int interestSet = selectionKey.interestOps(); boolean isInterestedInAccept = (interestSet \u0026 SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT； boolean isInterestedInConnect = interestSet \u0026 SelectionKey.OP_CONNECT; boolean isInterestedInRead = interestSet \u0026 SelectionKey.OP_READ; boolean isInterestedInWrite = interestSet \u0026 SelectionKey.OP_WRITE; key.readyOps()\nready 集合是通道已经准备就绪的操作的集合。JAVA中定义以下几个方法用来检查这些操作是否就绪.\n1 2 3 4 5 6 7 //创建ready集合的方法 int readySet = selectionKey.readyOps(); //检查这些操作是否就绪的方法 key.isAcceptable();//是否可读，是返回 true boolean isWritable()：//是否可写，是返回 true boolean isConnectable()：//是否可连接，是返回 true boolean isAcceptable()：//是否可接收，是返回 true 从SelectionKey访问Channel和Selector很简单。如下：\n1 2 3 Channel channel = key.channel(); Selector selector = key.selector(); key.attachment(); 可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：\n1 2 key.attach(theObject); Object attachedObj = key.attachment(); 还可以在用register()方法向Selector注册Channel的时候附加对象。如：\n1 SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject); 4. 从Selector中选择channel(Selecting Channels via a Selector) 选择器维护注册过的通道的集合，并且这种注册关系都被封装在SelectionKey当中.\nSelector维护的三种类型SelectionKey集合：\n已注册的键的集合(Registered key set)\n所有与选择器关联的通道所生成的键的集合称为已经注册的键的集合。并不是所有注册过的键都仍然有效。这个集合通过 keys() 方法返回，并且可能是空的。这个已注册的键的集合不是可以直接修改的；试图这么做的话将引发java.lang.UnsupportedOperationException。\n已选择的键的集合(Selected key set)\n所有与选择器关联的通道所生成的键的集合称为已经注册的键的集合。并不是所有注册过的键都仍然有效。这个集合通过 keys() 方法返回，并且可能是空的。这个已注册的键的集合不是可以直接修改的；试图这么做的话将引发java.lang.UnsupportedOperationException。\n已取消的键的集合(Cancelled key set)\n已注册的键的集合的子集，这个集合包含了 cancel() 方法被调用过的键(这个键已经被无效化)，但它们还没有被注销。这个集合是选择器对象的私有成员，因而无法直接访问。\n注意： 当键被取消（ 可以通过isValid( ) 方法来判断）时，它将被放在相关的选择器的已取消的键的集合里。注册不会立即被取消，但键会立即失效。当再次调用 select( ) 方法时（或者一个正在进行的select()调用结束时），已取消的键的集合中的被取消的键将被清理掉，并且相应的注销也将完成。通道会被注销，而新的SelectionKey将被返回。当通道关闭时，所有相关的键会自动取消（记住，一个通道可以被注册到多个选择器上）。当选择器关闭时，所有被注册到该选择器的通道都将被注销，并且相关的键将立即被无效化（取消）。一旦键被无效化，调用它的与选择相关的方法就将抛出CancelledKeyException。\nselect()方法介绍：\n在刚初始化的Selector对象中，这三个集合都是空的。 通过Selector的select（）方法可以选择已经准备就绪的通道 （这些通道包含你感兴趣的的事件）。比如你对读就绪的通道感兴趣，那么select（）方法就会返回读事件已经就绪的那些通道。下面是Selector几个重载的select()方法：\nint select()：阻塞到至少有一个通道在你注册的事件上就绪了。 int select(long timeout)：和select()一样，但最长阻塞时间为timeout毫秒。 int selectNow()：非阻塞，只要有通道就绪就立刻返回。 select()方法返回的int值表示有多少通道已经就绪,是自上次调用select()方法后有多少通道变成就绪状态。之前在select（）调用时进入就绪的通道不会在本次调用中被记入，而在前一次select（）调用进入就绪但现在已经不在处于就绪的通道也不会被记入。例如：首次调用select()方法，如果有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道，但在每次select()方法调用之间，只有一个通道就绪了。\n一旦调用select()方法，并且返回值不为0时，则 可以通过调用Selector的selectedKeys()方法来访问已选择键集合 。如下： Set selectedKeys=selector.selectedKeys(); 进而可以放到和某SelectionKey关联的Selector和Channel。如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Set selectedKeys = selector.selectedKeys(); Iterator keyIterator = selectedKeys.iterator(); while(keyIterator.hasNext()) { SelectionKey key = keyIterator.next(); if(key.isAcceptable()) { // a connection was accepted by a ServerSocketChannel. } else if (key.isConnectable()) { // a connection was established with a remote server. } else if (key.isReadable()) { // a channel is ready for reading } else if (key.isWritable()) { // a channel is ready for writing } keyIterator.remove(); } 5. 停止选择的方法 选择器执行选择的过程，系统底层会依次询问每个通道是否已经就绪，这个过程可能会造成调用线程进入阻塞状态,那么我们有以下三种方式可以唤醒在select（）方法中阻塞的线程。\nwakeup()方法 ：通过调用Selector对象的wakeup（）方法让处在阻塞状态的select()方法立刻返回 该方法使得选择器上的第一个还没有返回的选择操作立即返回。如果当前没有进行中的选择操作，那么下一次对select()方法的一次调用将立即返回。 close()方法 ：通过close（）方法关闭Selector， 该方法使得任何一个在选择操作中阻塞的线程都被唤醒（类似wakeup（）），同时使得注册到该Selector的所有Channel被注销，所有的键将被取消，但是Channel本身并不会关闭。 35. 序列化 序列化：指的就是通过某种技术将数据结构或者对象转化为二进制字节流的过程（通常是二进制的形式，也可以采用类似XML或者JSON的方式，但是这样虽然提高了可读性但是降低的性能）\n反序列化：指的将二进制字节流转化为数据结构或者对象的过程。（序列化相对的步骤）\n通常序列化与反序列化的作用是\n将当前程序中的数据实现持久化的存储 将对象通过网络进行传输，在远程的设备上需要本地设备的对象 存储到数据库中也需要序列化 （一般就是需要将对象取出来使用的场景，此时就需要通过序列化的方式来实现这些功能）\nJDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。\nJDK自带的序列化实现 1 2 3 4 5 6 7 8 9 @Getter @Setter @NoArgsConstructor @AllArgsConstructor public class People implements Serializable { private static final long serialVersionUID = 1905122041950251207L; private int anInt; private String string; } 使用Java自带的序列化只需要实现Serializable接口最好是自己创建serialVersionUID，UID的作用是在反序列化时检测版本是否一致，若不一致则无法进行反序列化。\n对于不想进行序列化的变量，可以使用 transient 关键字修饰，关键字只可用于修饰变量，不可以用于修饰方法。\nKryo Kryo 是一个快速序列化/反序列化工具，其使用了字节码生成机制（底层依赖了 ASM 库），因此具有比较好的运行速度。\nKryo 序列化出来的结果，是其自定义的、独有的一种格式，不再是 JSON 或者其他现有的通用格式；而且，其序列化出来的结果是二进制的（即 byte[]；而 JSON 本质上是字符串 String）；二进制数据显然体积更小，序列化、反序列化时的速度也更快。\nKryo 一般只用来进行序列化（然后作为缓存，或者落地到存储设备之中）、反序列化，而不用于在多个系统、甚至多种语言间进行数据交换 —— 目前 kryo 也只有 java 实现。\n像 Redis 这样的存储工具，是可以安全地存储二进制数据的，所以可以直接把 Kryo 序列化出来的数据存进去。\n当然，如果你希望用 String 的形式存储、传输 Kryo 序列化之后的数据，也可以通过 Base64 等编码方式来实现。但这会降低程序的运行速度，一定程度上违背了使用 kryo 的初衷。\n相较于Java提供的序列化工具，Kryo可以序列化任意类型的对象（不包括匿名内部类，对非静态内部类的支持一般），这使得许多已经开发好的工具包中的类但是没有实现@Serializable接口的对象可以实现序列化，通常序列化所需的时间都纳秒级别的。 线程不安全，Kryo没有在序列化时对对象进行上锁，所以理论上存在数据出错的可能性大，可以通过ThreadLocal保证线程安全性 注册，在Kryo中可以进行注册，注册后每种类型会获得一个编号，但是在现实环境中（重启虚拟机后注册顺序不同、多设备部署）同一个类型具有两种不同的编号，会使得反序列化失败，一般情况下不使用注册的方式实现序列化，通过如下设置关闭注册: kryo.setRegistrationRequired(false); 循环引用问题，默认情况下是支持循环引用问题的，例如A引用了B，在B中同样引用了A。有特殊需求可以关闭循环引用: kryo.setReferences(false); KryoUtil 对 Kryo 进行了一定的封装，能够满足分布式系统的一般需求，而无需进行任何额外的配置。\n除了用于获得当前线程的 kryo 实例的 getInstance() 方法之外，KryoUtil 内共有 8 个 public 方法，分为两组：\nbyte[] writeToByteArray(T obj);\nString writeToString(T obj);\nT readFromByteArray(byte[] byteArray);\nT readFromString(String str);\n及：\nbyte[] writeObjectToByteArray(T obj)\nString writeObjectToString(T obj)\nT readObjectFromByteArray(byte[] byteArray, Class clazz)\nT readObjectFromString(String str, Class clazz)\n其中第一组序列化的结果里包含了类型信息，第二组不包含 —— 因此，可以看到，在使用第二组方法进行反序列化的时候，需要提供原始对象的 Class 。但我们建议使用第一组方法，原因见第 3.2 节。\n另外，必须注意，第一组方法和第二组方法不能混用，第一组序列化出来的结果，只能由第一组的方法进行反序列化；第二组亦然。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 public class KryoUtil { private static final String DEFAULT_ENCODING = \"UTF-8\"; private static final ThreadLocal kryoLocal = new ThreadLocal() { @Override protected Kryo initialValue() { Kryo kryo = new Kryo(); kryo.setReferences(true); kryo.setRegistrationRequired(false); ((Kryo.DefaultInstantiatorStrategy) kryo.getInstantiatorStrategy()).setFallbackInstantiatorStrategy(new StdInstantiatorStrategy()); return kryo; } }; public static Kryo getInstance() { return kryoLocal.get(); } public static byte[] writeToByteArray(T obj) { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); Output output = new Output(byteArrayOutputStream); Kryo kryo = getInstance(); kryo.writeClassAndObject(output, obj); output.flush(); return byteArrayOutputStream.toByteArray(); } public static String writeToString(T obj) { try { return new String(Base64.encodeBase64(writeToByteArray(obj)), DEFAULT_ENCODING); } catch (UnsupportedEncodingException e) { throw new IllegalStateException(e); } } @SuppressWarnings(\"unchecked\") public static T readFromByteArray(byte[] byteArray) { ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArray); Input input = new Input(byteArrayInputStream); Kryo kryo = getInstance(); return (T) kryo.readClassAndObject(input); } public static T readFromString(String str) { try { return readFromByteArray(Base64.decodeBase64(str.getBytes(DEFAULT_ENCODING))); } catch (UnsupportedEncodingException e) { throw new IllegalStateException(e); } } public static byte[] writeObjectToByteArray(T obj) { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); Output output = new Output(byteArrayOutputStream); Kryo kryo = getInstance(); kryo.writeObject(output, obj); output.flush(); return byteArrayOutputStream.toByteArray(); } public static String writeObjectToString(T obj) { try { return new String(Base64.encodeBase64(writeObjectToByteArray(obj)), DEFAULT_ENCODING); } catch (UnsupportedEncodingException e) { throw new IllegalStateException(e); } } @SuppressWarnings(\"unchecked\") public static T readObjectFromByteArray(byte[] byteArray, Class clazz) { ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArray); Input input = new Input(byteArrayInputStream); Kryo kryo = getInstance(); return kryo.readObject(input, clazz); } public static T readObjectFromString(String str, Class clazz) { try { return readObjectFromByteArray(Base64.decodeBase64(str.getBytes(DEFAULT_ENCODING)), clazz); } catch (UnsupportedEncodingException e) { throw new IllegalStateException(e); } } } 36. SPI SPI机制指的是由调用方定义接口，实现方根据调用方提供的接口进行实现。\n调用的示意图如上，那么这套机制是如何实现的呢？\n调用方 在调用方从ServiceLoader中获取接口的实现对象，当然调用方需要对ServiceLoader中不存在实现对象，或存在多个实例对象的情况进行考虑（ServiceLoader中对象从何而来将在实现方进行讲解）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private LoggerService() { ServiceLoader loader = ServiceLoader.load(Logger.class); List list = new ArrayList\u003c\u003e(); for (Logger log : loader) { list.add(log); } // LoggerList 是所有 ServiceProvider loggerList = list; if (!list.isEmpty()) { // Logger 只取一个 logger = list.get(0); } else { logger = null; } } 调用方通过ServiceLoader.load方法获取实例对象，该对象就是调用方提供的接口。\n实现方 实现方直接对接口进行实现即可，那么实现方在实现完成后如何将实现对象放入ServiceLoader呢，这就需要讲到SPI的实现机制了。\n在Java中调用方通过会定义好接口在一个包中，实现方会实现该接口在另一个包中，Java在引入jar包时提供了SPI的机制，设置配置文件META-INF/services，文件名为接口的全路径，文件内容是实现类的全路径。jdk在加载jar包时会读取该文件，并创建对象，将对象存放到ServiceLoader中。\n这就有非常多的事情可以做了，因为这种方式可以自动加载配置文件中写的类，会触发类加载，所以可以在类加载中、初始化方法中做很多想做的事情。\n37. 范型 什么是泛型？有什么作用？ Java 泛型（Generics） 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。\n编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 ArrayList persons = new ArrayList() 这行代码就指明了该 ArrayList 对象只能传入 Person 对象，如果传入其他类型的对象就会报错。\n1 ArrayList extends AbstractList 并且，原生 List 返回类型是 Object ，需要手动转换类型才能使用，使用泛型后编译器自动转换。\n泛型的使用方式有哪几种？ 泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。\n1.泛型类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型 //在实例化泛型类时，必须指定T的具体类型 public class Generic{ private T key; public Generic(T key) { this.key = key; } public T getKey(){ return key; } } 如何实例化泛型类：\n1 Generic genericInteger = new Generic(123456); 2.泛型接口 ：\n1 2 3 public interface Generator { public T method(); } 实现泛型接口，不指定类型：\n1 2 3 4 5 6 class GeneratorImpl implements Generator{ @Override public T method() { return null; } } 实现泛型接口，指定类型：\n1 2 3 4 5 6 class GeneratorImpl implements Generator{ @Override public String method() { return \"hello\"; } } 3.泛型方法 ：\n1 2 3 4 5 6 public static void printArray(E[] inputArray){ for (E element : inputArray){ System.out.printf(\"%s\", element); } System.out.println(); } 使用：\n1 2 3 4 5 // 创建不同类型数组： Integer, Double 和 Character Integer[] intArray = {1, 2, 3}; String[] stringArray = {\"Hello\", \"World\"}; printArray(intArray); printArray(stringArray); 注意: public static void printArray(E[] inputArray) 一般被称为静态泛型方法;在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的 泛型类、泛型接口、泛型方法 1 2 3 4 5 6 7 8 9 10 11 public class Test1{ private T t; public void setT (T t) { this.t = t; } public T getT(){ return t; } } 上面是一个基本的泛型类的实现，其实现方式是在类名后增加\u003c\u003e符号来表示泛型，可以使用例如T、E、K、V等形式常见的参数表示泛型。\n实例化代码是：Test1 t = new Test1\u003c\u003e();在new时后面尖括号中的类型可以省略。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public interface TestInt { public T method(); } public class Test2 implements TestInt{ @Override public T method() { return null; } } public class Test3 implements TestInt{ @Override public Integer method() { return null; } } 上述代码中定义了泛型接口并且在其中定义了一个方法，在实现这个接口时，可以直接在实现中制定泛型的类型，此时在实现具体方法时实现的方法已经是具体类型的了，也可以不指定，继续使用泛型由使用者来确定。\n1 2 public void mathod(List list){ } 泛型方法可以在void前侧定义泛型，然后在形参或者返回值中使用。\n泛型擦除 泛型擦除指的是在编译后的字节码中是没有泛型的信息的，这点可以通过反编译进行验证。其中泛型T、K等被擦除为Object，T extends XXX被擦除为XXX。\n因为泛型擦除的存在会导致一个新问题，泛型怎么办，例如在一个类实现了另一个泛型类，并且确定了泛型的类型，此时实现的方式是具体类型的，但是在父类中的方法中类型是Object的，但是实现的方法却是具体类型的，此时多态就遇到了问题，因此编译器做了桥方法。\n1 2 3 4 5 6 7 8 9 10 11 12 class Test4 { public void method(T t) {} } class Test5 extends Test4{ public void method(Integer t){} // 桥方法，编译器自动生成，不需要用户实现 public void method(Object t){ method((Integer) t); } } 泛型的限制 只能申明但不能实例化T 泛型参数不能是基本类型，因为需要是Object的子类 不能实例化泛型参数的数组 不能实例化泛型数组 泛型不能使用Instance of 和getClass()进行判断 不能使用static修饰泛型变量 可以从类型擦除的角度思考，很多不确定的东西是不能实现的。\n通配符 在定义泛型时可以使用entends确定泛型的最高类型\n在使用范型时可以使用？、extends、super对对象类型的范围进行限制。\n使用extends和super进行限制后存在使用时的限制需要注意。\n38. stream流 Java 8中的Stream是一种新的抽象层，用于对集合对象进行处理。Stream API可以让我们更方便地对集合进行操作，而不需要使用for循环等传统方式。Stream API提供了一种高效且易于使用的处理数据的方式。\nStream流在管道中传输，并且可以在管道的节点上进行处理，比如筛选、排序、聚合等。Stream流的操作可以分为中间操作和终端操作两种，其中中间操作返回一个新的Stream对象，终端操作则返回一个非Stream对象。\n下面是一些Java Stream流的例子：\n通过 java.util.Collection.stream () 方法用集合创建流 1 2 3 4 5 List list = Arrays.asList(\"a\", \"b\", \"c\"); // 创建一个顺序流 Stream stream = list.stream(); // 创建一个并行流 Stream parallelStream = list.parallelStream(); 使用 java.util.Arrays.stream (T [] array) 方法用数组创建流 1 2 int [] array ={1,3,5,7,9}; IntStream stream = Arrays.stream(array); 使用 Stream.of() 方法创建流 1 Stream strStream = Stream.of (\"hello\", \"java8\", \"stream\"); 39. 大数 在计算机程序中进行浮点运算时是存在精度丢失的情况的 ，如下代码就是精度问题导致的：\n1 2 3 4 5 float a = 2.0f - 1.9f; float b = 1.8f - 1.7f; System.out.println(a);// 0.100000024 System.out.println(b);// 0.099999905 System.out.println(a == b);// false 按照现实中的计算来看a和b都应该是0.1，但是由于计算机对浮点数进行存储是使用的二进制的缘故，无法保证结果的精确性，在《阿里巴巴Java开发手册》中就建议为了避免精度丢失，进行浮点运算时采用BigDecimal进行。\nBigDecimal介绍 《阿里巴巴 Java 开发手册》中提到：浮点数之间的等值判断，基本数据类型不能用 == 来比较，包装数据类型不能用 equals 来判断。（由于精度的原因）\n创建 我们在使用 BigDecimal 时，为了防止精度丢失，推荐使用它的BigDecimal(String val)构造方法或者 BigDecimal.valueOf(double val) 静态方法来创建对象。\n加减乘除操作 1 2 3 4 5 6 7 BigDecimal a = new BigDecimal(\"1.0\"); BigDecimal b = new BigDecimal(\"0.9\"); System.out.println(a.add(b));// 1.9 System.out.println(a.subtract(b));// 0.1 System.out.println(a.multiply(b));// 0.90 System.out.println(a.divide(b));// 无法除尽，抛出 ArithmeticException 异常 System.out.println(a.divide(b, 2, RoundingMode.HALF_UP));// 1.11 这里需要注意的是，在我们使用 divide 方法的时候尽量使用 3 个参数版本，并且RoundingMode 不要选择 UNNECESSARY，否则很可能会遇到 ArithmeticException（无法除尽出现无限循环小数的时候），其中 scale 表示要保留几位小数，roundingMode 代表保留规则。\n大小比较 a.compareTo(b) : 返回 -1 表示 a 小于 b，0 表示 a 等于 b ， 1 表示 a 大于 b。\n1 2 3 BigDecimal a = new BigDecimal(\"1.0\"); BigDecimal b = new BigDecimal(\"0.9\"); System.out.println(a.compareTo(b));// 1 保留几位小数 通过 setScale方法设置保留几位小数以及保留规则。保留规则有挺多种，不需要记，IDEA 会提示。\n1 2 3 BigDecimal m = new BigDecimal(\"1.255433\"); BigDecimal n = m.setScale(3,RoundingMode.HALF_DOWN); System.out.println(n);// 1.255 等值比较问题 1 2 3 4 BigDecimal a = new BigDecimal(\"1\"); BigDecimal b = new BigDecimal(\"1.0\"); System.out.println(a.equals(b));//false System.out.println(a.compareTo(b));//0 40. 集合 Java集合也称为容器，所有容器都由两大接口派生而来，分别是Collection、Map。Collection接口的实现类只要用于存放单一的元素，Map接口的实现类主要用于存放键值对，其中Collection接口有三个主要的子接口：List、Set、Queue。\n四种主要容器的区别 List：存放有序的、可重复的元素（处理有序的元素） Set：存放无序的、不可重复的元素（主要用于处理不可重复的场景） Queue：存放有序的、可重复的元素，但是会根据要求限制先后顺序（例如排队等功能） Map：存储键值对，其中key是无序的、不可重复的 如何选用集合? 主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 Map 接口下的集合，需要排序时选择 TreeMap,不需要排序时就选择 HashMap,需要保证线程安全就选用 ConcurrentHashMap。\n当我们只需要存放元素值时，就选择实现Collection 接口的集合，需要保证元素唯一时选择实现 Set 接口的集合比如 TreeSet 或 HashSet，不需要就选择实现 List 接口的比如 ArrayList 或 LinkedList，然后再根据实现这些接口的集合的特点来选用。\n为什么要使用集合？ 当我们需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，这个容器就是数组，但是，使用数组存储对象具有一定的弊端， 因为我们在实际开发中，存储的数据的类型是多种多样的，于是，就出现了“集合”，集合同样也是用来存储多个数据的。\n数组的缺点是一旦声明之后，长度就不可变了；同时，声明数组时的数据类型也决定了该数组存储的数据的类型；而且，数组存储的数据是有序的、可重复的，特点单一。 但是集合提高了数据存储的灵活性，Java 集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据。\n集合的使用方法 我们在使用集合的时候通常都是使用四种接口然后指向其子类，所以下面主要介绍几个接口总提供的方法进行介绍。\nCollection 方法 作用 int size() 容器中存放的对象数量 boolean contains(Object) 容器中是否包含形参对象 boolean containsAll(Collection\u003c?\u003e c) 若容器中包含形参容器中的所有元素，返回true iterator() 迭代器 T[] toArray() 将容器中的对象转化为一个数组进行返回 T[] toArray(T[] a) 控制返回类型的数组，作用同上 boolean add(E e) 向容器中添加元素 boolean addAll(Collection\u003c? extends E\u003e c) 将形参容器中的所有元素添加到容器中 boolean remove(Object o) 从容器中移除元素 boolean removeAll(Collection\u003c?\u003e c) 从容器中移除形参容器中的所以元素 boolean retainAll(Collection\u003c?\u003e c) 保留容器中存在与形参容器中的元素 void clear() 清空容器 List 方法 作用 boolean addAll(int index, Collection\u003c? extends E\u003e c) 在index下表开始添加形参中的元素 default void replaceAll(UnaryOperator operator) 将容器中的每一个元素替换为operator运算后的结果 void sort(Comparator\u003c? super E\u003e c) 根据比较器对容器中的元素进行排 E get(int index) 获取下标为index的元素 E set(int index, E element) 设置下表为index的元素为element void add(int index, E element) 在下标为index的地方插入元素element E remove(int index) 移除下标为index的元素 int indexOf(Object o) 获取元素在容器中的下标 int lastIndexOf(Object o) 获取元素在容器中最后一次出现的索引 ListIterator listIterator() 返回词容器的列表迭代器 ListIterator listIterator(int index) 返回从index开始的列表迭代器 List subList(int fromIndex, int toIndex) 返回子序列（前闭后开，相同时返回为空） 大部分方法通过方法名就可以知道其作用，通常这些方法也是最常用的。\nSet Set中的方法都继承自Collection，其通过Map实现，因为Map中的Key是唯一的，因此满足Set不重复、乱序的特点。\nQueue 方法 作用 boolean offer(E e) 在不违反容量限制的条件下，立即将指定的元素插入队列中 E remove() 删除队列的头元素，若队列为空将抛出异常 E poll() 退出队列的头元素，队列为空则返回null E element() 检查队列的头元素，若队列为空抛出异常 E peek() 检测队列的头元素，若队列为空返回null Map 方法 作用 int size() 返回映射中的键值对数量 boolean containsKey(Object key) 映射中是否包含键为key的键值对 boolean containsValue(Object value) 映射中是否有键值对映射到该value上 V get(Object key) 根据提供的key获得value V put(K key, V value) 向映射中添加键值对，若原来已经存在则替换value V remove(Object key) 根据value从映射中移除键值对 void putAll(Map\u003c? extends K, ? extends V\u003e m) 将形参映射中所有的键值对添加到映射中 void clear() 清空映射 Set keySet() 返回映射中key构成的Set类型对象 Collection values() 返回映射中value构成的Collection对象 Set",
  "wordCount" : "29870",
  "inLanguage": "en",
  "datePublished": "2023-04-05T00:18:23+08:00",
  "dateModified": "2023-04-05T00:18:23+08:00",
  "author":[{
    "@type": "Person",
    "name": "King"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://jinchaojjj.github.io/posts/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "King's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://jinchaojjj.github.io/img/a.jpeg"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://jinchaojjj.github.io" accesskey="h" title="King&#39;s Blog (Alt + H)">
                <img src="https:/jinchaojjj.github.io/a.jpeg" alt="" aria-label="logo"
                    height="35">King&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://jinchaojjj.github.io/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="https://jinchaojjj.github.io/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://jinchaojjj.github.io/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://jinchaojjj.github.io/archives/" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://jinchaojjj.github.io/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="https://jinchaojjj.github.io/about" title="🙋🏻‍♂️关于">
                    <span>🙋🏻‍♂️关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://jinchaojjj.github.io">Home</a>&nbsp;»&nbsp;<a href="https://jinchaojjj.github.io/posts/">📚文章</a></div>
    <h1 class="post-title">
      Java基本语法
    </h1>
    <div class="post-description">
      Java基本语法
    </div>
    <div class="post-meta"><span title='2023-04-05 00:18:23 +0800 CST'>2023-04-05</span>&nbsp;·&nbsp;60 min&nbsp;·&nbsp;King

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#java%e5%9f%ba%e6%9c%ac%e8%af%ad%e6%b3%95" aria-label="Java基本语法">Java基本语法</a></li>
                <li>
                    <a href="#1-%e6%b3%a8%e9%87%8a" aria-label="1. 注释">1. 注释</a></li>
                <li>
                    <a href="#2-%e6%a0%87%e8%af%86%e7%ac%a6%e5%92%8c%e5%85%b3%e9%94%ae%e5%ad%97" aria-label="2. 标识符和关键字">2. 标识符和关键字</a></li>
                <li>
                    <a href="#3-%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e4%bb%a5%e5%8f%8a%e5%8c%85%e8%a3%85%e7%b1%bb" aria-label="3. 基本数据类型以及包装类">3. 基本数据类型以及包装类</a></li>
                <li>
                    <a href="#4-%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%e5%92%8c%e5%88%a4%e6%96%ad" aria-label="4. 类型转换和判断">4. 类型转换和判断</a><ul>
                        
                <li>
                    <a href="#%e9%9a%90%e5%bc%8f%e7%b1%bb%e5%9e%8b%e8%bd%ac%e5%8c%96" aria-label="隐式类型转化">隐式类型转化</a></li>
                <li>
                    <a href="#%e5%bc%ba%e5%88%b6%e7%b1%bb%e5%9e%8b%e8%bd%ac%e5%8c%96" aria-label="强制类型转化">强制类型转化</a></li>
                <li>
                    <a href="#%e7%b1%bb%e5%9e%8b%e5%88%a4%e6%96%ad" aria-label="类型判断">类型判断</a></li></ul>
                </li>
                <li>
                    <a href="#5-%e5%8f%98%e9%87%8f%e5%b8%b8%e9%87%8f%e5%92%8c%e4%bd%9c%e7%94%a8%e5%9f%9f" aria-label="5. 变量、常量和作用域">5. 变量、常量和作用域</a></li>
                <li>
                    <a href="#6-%e5%9f%ba%e6%9c%ac%e8%bf%90%e7%ae%97%e7%ac%a6" aria-label="6. 基本运算符">6. 基本运算符</a><ul>
                        
                <li>
                    <a href="#%e8%87%aa%e5%a2%9e%e8%87%aa%e5%87%8f%e8%bf%90%e7%ae%97%e7%ac%a6--" aria-label="自增自减运算符（&#43;&#43;、--）">自增自减运算符（<code>++</code>、<code>--</code>）</a></li>
                <li>
                    <a href="#%e4%bd%8d%e7%a7%bb%e8%bf%90%e7%ae%97%e7%ac%a6" aria-label="位移运算符">位移运算符</a></li>
                <li>
                    <a href="#%e4%bd%8d%e8%bf%90%e7%ae%97" aria-label="位运算">位运算</a></li>
                <li>
                    <a href="#math" aria-label="Math">Math</a></li></ul>
                </li>
                <li>
                    <a href="#7-%e5%8c%85%e7%bb%93%e6%9e%84" aria-label="7. 包结构">7. 包结构</a></li>
                <li>
                    <a href="#8-%e9%a1%ba%e5%ba%8f%e7%bb%93%e6%9e%84" aria-label="8. 顺序结构">8. 顺序结构</a></li>
                <li>
                    <a href="#9-if" aria-label="9. if">9. if</a></li>
                <li>
                    <a href="#10-switch" aria-label="10. switch">10. switch</a></li>
                <li>
                    <a href="#11-while" aria-label="11. while">11. while</a></li>
                <li>
                    <a href="#12-for" aria-label="12. for">12. for</a></li>
                <li>
                    <a href="#13-foreach" aria-label="13. foreach">13. foreach</a></li>
                <li>
                    <a href="#14-breakcontinue" aria-label="14. break、continue">14. break、continue</a></li>
                <li>
                    <a href="#15-%e6%96%b9%e6%b3%95" aria-label="15. 方法">15. 方法</a></li>
                <li>
                    <a href="#16-%e5%91%bd%e4%bb%a4%e8%a1%8c%e7%9a%84%e5%8f%82%e6%95%b0%e4%bc%a0%e9%80%92" aria-label="16. 命令行的参数传递">16. 命令行的参数传递</a></li>
                <li>
                    <a href="#17-%e5%8f%af%e5%8f%98%e5%8f%82%e6%95%b0" aria-label="17. 可变参数">17. 可变参数</a></li>
                <li>
                    <a href="#18-%e6%95%b0%e7%bb%84" aria-label="18. 数组">18. 数组</a></li>
                <li>
                    <a href="#19-arrays" aria-label="19. Arrays">19. Arrays</a></li>
                <li>
                    <a href="#20-%e7%b1%bb%e5%92%8c%e5%af%b9%e8%b1%a1" aria-label="20. 类和对象">20. 类和对象</a></li>
                <li>
                    <a href="#21-%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0" aria-label="21. 构造函数">21. 构造函数</a></li>
                <li>
                    <a href="#22-%e7%bb%a7%e6%89%bf" aria-label="22. 继承">22. 继承</a></li>
                <li>
                    <a href="#23-super" aria-label="23. super">23. super</a></li>
                <li>
                    <a href="#24-%e9%87%8d%e5%86%99" aria-label="24. 重写">24. 重写</a></li>
                <li>
                    <a href="#25-static" aria-label="25. static">25. static</a></li>
                <li>
                    <a href="#26-%e6%8a%bd%e8%b1%a1%e7%b1%bb" aria-label="26. 抽象类">26. 抽象类</a></li>
                <li>
                    <a href="#27-%e6%8e%a5%e5%8f%a3" aria-label="27. 接口">27. 接口</a></li>
                <li>
                    <a href="#28-%e5%86%85%e9%83%a8%e7%b1%bb" aria-label="28. 内部类">28. 内部类</a></li>
                <li>
                    <a href="#29-%e5%bc%82%e5%b8%b8" aria-label="29. 异常">29. 异常</a><ul>
                        
                <li>
                    <a href="#checked-exception" aria-label="Checked Exception"><code>Checked Exception</code></a></li>
                <li>
                    <a href="#throwable-%e7%b1%bb%e5%b8%b8%e7%94%a8%e6%96%b9%e6%b3%95%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="Throwable 类常用方法有哪些？"><code>Throwable</code> 类常用方法有哪些？</a></li>
                <li>
                    <a href="#try-catch-finally-%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8" aria-label="try-catch-finally 如何使用？">try-catch-finally 如何使用？</a></li></ul>
                </li>
                <li>
                    <a href="#30-%e5%8f%8d%e5%b0%84" aria-label="30. 反射">30. 反射</a><ul>
                        
                <li>
                    <a href="#%e4%bd%95%e8%b0%93%e5%8f%8d%e5%b0%84" aria-label="何谓反射？">何谓反射？</a></li>
                <li>
                    <a href="#%e5%8f%8d%e5%b0%84%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9" aria-label="反射的优缺点？">反射的优缺点？</a></li>
                <li>
                    <a href="#%e5%8f%8d%e5%b0%84%e7%9a%84%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" aria-label="反射的应用场景？">反射的应用场景？</a></li>
                <li>
                    <a href="#%e8%8e%b7%e5%8f%96class%e5%af%b9%e8%b1%a1%e5%af%b9%e5%9b%9b%e7%a7%8d%e6%96%b9%e6%b3%95" aria-label="获取Class对象对四种方法">获取Class对象对四种方法</a></li>
                <li>
                    <a href="#%e5%8f%8d%e5%b0%84%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%93%8d%e4%bd%9c" aria-label="反射的基本操作">反射的基本操作</a><ul>
                        
                <li>
                    <a href="#1-class%e7%b1%bb" aria-label="1. Class类">1. Class类</a></li>
                <li>
                    <a href="#2-field%e7%b1%bb" aria-label="2. Field类">2. Field类</a></li>
                <li>
                    <a href="#3-method%e7%b1%bb" aria-label="3. Method类">3. Method类</a></li>
                <li>
                    <a href="#4-constructor%e7%b1%bb" aria-label="4. Constructor类">4. Constructor类</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#31-%e5%a4%9a%e7%ba%bf%e7%a8%8b" aria-label="31. 多线程">31. 多线程</a></li>
                <li>
                    <a href="#32-%e5%8a%a8%e6%80%81%e4%bb%a3%e7%90%86" aria-label="32. 动态代理">32. 动态代理</a></li>
                <li>
                    <a href="#33-io%e4%bb%8b%e7%bb%8d" aria-label="33. IO介绍">33. IO介绍</a><ul>
                        
                <li>
                    <a href="#%e5%88%86%e7%b1%bb" aria-label="分类">分类</a><ul>
                        
                <li>
                    <a href="#bio" aria-label="BIO">BIO</a></li>
                <li>
                    <a href="#nio-non-blockingnew-io" aria-label="NIO (Non-blocking/New I/O)">NIO (Non-blocking/New I/O)</a></li>
                <li>
                    <a href="#aio-asynchronous-io" aria-label="AIO (Asynchronous I/O)">AIO (Asynchronous I/O)</a></li></ul>
                </li>
                <li>
                    <a href="#io" aria-label="IO">IO</a><ul>
                        
                <li>
                    <a href="#%e5%ad%97%e8%8a%82%e6%b5%81" aria-label="字节流">字节流</a><ul>
                        
                <li>
                    <a href="#inputstream%e5%ad%97%e8%8a%82%e8%be%93%e5%85%a5%e6%b5%81" aria-label="InputStream（字节输入流）">InputStream（字节输入流）</a></li>
                <li>
                    <a href="#outputstream%e5%ad%97%e8%8a%82%e8%be%93%e5%87%ba%e6%b5%81" aria-label="OutputStream（字节输出流）">OutputStream（字节输出流）</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ad%97%e7%ac%a6%e6%b5%81" aria-label="字符流">字符流</a><ul>
                        
                <li>
                    <a href="#reader%e5%ad%97%e7%ac%a6%e8%be%93%e5%85%a5%e6%b5%81" aria-label="Reader（字符输入流）">Reader（字符输入流）</a></li>
                <li>
                    <a href="#writer%e5%ad%97%e7%ac%a6%e8%be%93%e5%87%ba%e6%b5%81" aria-label="Writer（字符输出流）">Writer（字符输出流）</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%a3%85%e9%a5%b0%e6%b5%81" aria-label="装饰流">装饰流</a></li>
                <li>
                    <a href="#%e7%bc%93%e5%86%b2%e6%b5%81" aria-label="缓冲流">缓冲流</a><ul>
                        
                <li>
                    <a href="#%e5%ad%97%e8%8a%82%e7%bc%93%e5%86%b2%e6%b5%81" aria-label="字节缓冲流">字节缓冲流</a><ul>
                        
                <li>
                    <a href="#bufferedinputstream%e5%ad%97%e8%8a%82%e7%bc%93%e5%86%b2%e8%be%93%e5%85%a5%e6%b5%81" aria-label="BufferedInputStream（字节缓冲输入流）">BufferedInputStream（字节缓冲输入流）</a></li>
                <li>
                    <a href="#bufferedoutputstream%e5%ad%97%e8%8a%82%e7%bc%93%e5%86%b2%e8%be%93%e5%87%ba%e6%b5%81" aria-label="BufferedOutputStream（字节缓冲输出流）">BufferedOutputStream（字节缓冲输出流）</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ad%97%e7%ac%a6%e7%bc%93%e5%86%b2%e6%b5%81" aria-label="字符缓冲流">字符缓冲流</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%89%93%e5%8d%b0%e6%b5%81" aria-label="打印流">打印流</a><ul>
                        
                <li>
                    <a href="#scanner" aria-label="Scanner">Scanner</a></li>
                <li>
                    <a href="#printstream" aria-label="PrintStream">PrintStream</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e6%b5%81" aria-label="数据流">数据流</a></li>
                <li>
                    <a href="#%e5%af%b9%e8%b1%a1%e6%b5%81" aria-label="对象流">对象流</a></li></ul>
                </li>
                <li>
                    <a href="#nio" aria-label="NIO">NIO</a><ul>
                        
                <li>
                    <a href="#%e7%bc%93%e5%86%b2%e5%8c%ba" aria-label="缓冲区">缓冲区</a><ul>
                        
                <li>
                    <a href="#%e7%bc%93%e5%86%b2%e5%8c%ba%e6%9e%84%e9%80%a0" aria-label="缓冲区构造">缓冲区构造</a></li>
                <li>
                    <a href="#%e7%bc%93%e5%86%b2%e5%8c%ba%e5%86%99%e6%93%8d%e4%bd%9c" aria-label="缓冲区写操作">缓冲区写操作</a></li>
                <li>
                    <a href="#%e7%bc%93%e5%86%b2%e5%8c%ba%e8%af%bb%e6%93%8d%e4%bd%9c" aria-label="缓冲区读操作">缓冲区读操作</a></li>
                <li>
                    <a href="#%e7%bc%93%e5%86%b2%e5%8c%ba%e5%85%b6%e4%bb%96%e6%93%8d%e4%bd%9c" aria-label="缓冲区其他操作">缓冲区其他操作</a></li>
                <li>
                    <a href="#%e7%bc%93%e5%86%b2%e5%8c%ba%e7%9a%84%e6%af%94%e8%be%83" aria-label="缓冲区的比较">缓冲区的比较</a></li>
                <li>
                    <a href="#%e5%8f%aa%e8%af%bb%e7%bc%93%e5%86%b2%e5%8c%ba" aria-label="只读缓冲区">只读缓冲区</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%80%9a%e9%81%93" aria-label="通道">通道</a><ul>
                        
                <li>
                    <a href="#%e9%80%9a%e9%81%93%e6%8e%a5%e5%8f%a3%e5%b1%82%e6%ac%a1" aria-label="通道接口层次">通道接口层次</a></li>
                <li>
                    <a href="#%e6%96%87%e4%bb%b6%e4%bc%a0%e8%be%93filechannel" aria-label="文件传输FileChannel">文件传输FileChannel</a></li>
                <li>
                    <a href="#%e6%96%87%e4%bb%b6%e9%94%81filelock" aria-label="文件锁FileLock">文件锁FileLock</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%80%89%e6%8b%a9%e5%99%a8" aria-label="选择器">选择器</a><ul>
                        
                <li>
                    <a href="#selector%e7%9a%84%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95%e4%bb%8b%e7%bb%8d" aria-label="Selector的使用方法介绍">Selector的使用方法介绍</a><ul>
                        
                <li>
                    <a href="#1-selector%e7%9a%84%e5%88%9b%e5%bb%ba" aria-label="1. Selector的创建">1. Selector的创建</a></li>
                <li>
                    <a href="#2-%e6%b3%a8%e5%86%8cchannel%e5%88%b0selector" aria-label="2. 注册Channel到Selector">2. 注册Channel到Selector</a></li>
                <li>
                    <a href="#3-selectionkey%e4%bb%8b%e7%bb%8d" aria-label="3. SelectionKey介绍">3. SelectionKey介绍</a></li>
                <li>
                    <a href="#4-%e4%bb%8eselector%e4%b8%ad%e9%80%89%e6%8b%a9channelselecting-channels-via-a-selector" aria-label="4. 从Selector中选择channel(Selecting Channels via a Selector)">4. 从Selector中选择channel(Selecting Channels via a Selector)</a></li>
                <li>
                    <a href="#5-%e5%81%9c%e6%ad%a2%e9%80%89%e6%8b%a9%e7%9a%84%e6%96%b9%e6%b3%95" aria-label="5. 停止选择的方法">5. 停止选择的方法</a></li></ul>
                </li></ul>
                </li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#35-%e5%ba%8f%e5%88%97%e5%8c%96" aria-label="35. 序列化">35. 序列化</a><ul>
                        
                <li>
                    <a href="#jdk%e8%87%aa%e5%b8%a6%e7%9a%84%e5%ba%8f%e5%88%97%e5%8c%96%e5%ae%9e%e7%8e%b0" aria-label="JDK自带的序列化实现">JDK自带的序列化实现</a></li>
                <li>
                    <a href="#kryo" aria-label="Kryo">Kryo</a></li></ul>
                </li>
                <li>
                    <a href="#36-spi" aria-label="36. SPI">36. SPI</a><ul>
                        
                <li>
                    <a href="#%e8%b0%83%e7%94%a8%e6%96%b9" aria-label="调用方">调用方</a></li>
                <li>
                    <a href="#%e5%ae%9e%e7%8e%b0%e6%96%b9" aria-label="实现方">实现方</a></li></ul>
                </li>
                <li>
                    <a href="#37-%e8%8c%83%e5%9e%8b" aria-label="37. 范型">37. 范型</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%b3%9b%e5%9e%8b%e6%9c%89%e4%bb%80%e4%b9%88%e4%bd%9c%e7%94%a8" aria-label="什么是泛型？有什么作用？">什么是泛型？有什么作用？</a></li>
                <li>
                    <a href="#%e6%b3%9b%e5%9e%8b%e7%9a%84%e4%bd%bf%e7%94%a8%e6%96%b9%e5%bc%8f%e6%9c%89%e5%93%aa%e5%87%a0%e7%a7%8d" aria-label="泛型的使用方式有哪几种？">泛型的使用方式有哪几种？</a></li>
                <li>
                    <a href="#%e6%b3%9b%e5%9e%8b%e7%b1%bb%e6%b3%9b%e5%9e%8b%e6%8e%a5%e5%8f%a3%e6%b3%9b%e5%9e%8b%e6%96%b9%e6%b3%95" aria-label="泛型类、泛型接口、泛型方法">泛型类、泛型接口、泛型方法</a></li>
                <li>
                    <a href="#%e6%b3%9b%e5%9e%8b%e6%93%a6%e9%99%a4" aria-label="泛型擦除">泛型擦除</a></li>
                <li>
                    <a href="#%e6%b3%9b%e5%9e%8b%e7%9a%84%e9%99%90%e5%88%b6" aria-label="泛型的限制">泛型的限制</a></li>
                <li>
                    <a href="#%e9%80%9a%e9%85%8d%e7%ac%a6" aria-label="通配符">通配符</a></li></ul>
                </li>
                <li>
                    <a href="#38-stream%e6%b5%81" aria-label="38. stream流">38. stream流</a></li>
                <li>
                    <a href="#39-%e5%a4%a7%e6%95%b0" aria-label="39. 大数">39. 大数</a><ul>
                        
                <li>
                    <a href="#bigdecimal%e4%bb%8b%e7%bb%8d" aria-label="BigDecimal介绍">BigDecimal介绍</a><ul>
                        
                <li>
                    <a href="#%e5%88%9b%e5%bb%ba" aria-label="创建">创建</a></li>
                <li>
                    <a href="#%e5%8a%a0%e5%87%8f%e4%b9%98%e9%99%a4%e6%93%8d%e4%bd%9c" aria-label="加减乘除操作">加减乘除操作</a></li>
                <li>
                    <a href="#%e5%a4%a7%e5%b0%8f%e6%af%94%e8%be%83" aria-label="大小比较">大小比较</a></li>
                <li>
                    <a href="#%e4%bf%9d%e7%95%99%e5%87%a0%e4%bd%8d%e5%b0%8f%e6%95%b0" aria-label="保留几位小数">保留几位小数</a></li>
                <li>
                    <a href="#%e7%ad%89%e5%80%bc%e6%af%94%e8%be%83%e9%97%ae%e9%a2%98" aria-label="等值比较问题">等值比较问题</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#40-%e9%9b%86%e5%90%88" aria-label="40. 集合">40. 集合</a><ul>
                        
                <li>
                    <a href="#%e5%9b%9b%e7%a7%8d%e4%b8%bb%e8%a6%81%e5%ae%b9%e5%99%a8%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="四种主要容器的区别">四种主要容器的区别</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e9%80%89%e7%94%a8%e9%9b%86%e5%90%88" aria-label="如何选用集合?">如何选用集合?</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%bd%bf%e7%94%a8%e9%9b%86%e5%90%88" aria-label="为什么要使用集合？">为什么要使用集合？</a></li>
                <li>
                    <a href="#%e9%9b%86%e5%90%88%e7%9a%84%e4%bd%bf%e7%94%a8%e6%96%b9%e6%b3%95" aria-label="集合的使用方法">集合的使用方法</a><ul>
                        <ul>
                        
                <li>
                    <a href="#collection" aria-label="Collection">Collection</a></li>
                <li>
                    <a href="#list" aria-label="List">List</a></li>
                <li>
                    <a href="#set" aria-label="Set">Set</a></li>
                <li>
                    <a href="#queue" aria-label="Queue">Queue</a></li>
                <li>
                    <a href="#map" aria-label="Map">Map</a>
                </li>
            </ul>
            </li>
            </ul>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="java基本语法">Java基本语法<a hidden class="anchor" aria-hidden="true" href="#java基本语法">#</a></h1>
<h1 id="1-注释">1. 注释<a hidden class="anchor" aria-hidden="true" href="#1-注释">#</a></h1>
<p>Java中存在三种注释：单行注释、多行注释、文档注释</p>
<ul>
<li>单行注释采用<code>//</code>的方式进行，在本行中的所有内容在编译时都将忽略</li>
<li>多行注释采用<code>/* 内容 */</code>的方式进行，在中间的部分都认为是注释，通常用于注释多行代码</li>
<li>文档注释采用<code>/** 内容 */</code>的方式，一般在类上、方法上使用，其中可以html语法，并且在生成Java开发文档时将自动将注释部分作为文档中的内容</li>
</ul>
<p>在开发过程中多写注释是一个好习惯，当代码量非常巨大的时候，往往注释可以很方便的告知使用者类、方法的具体含义，以此减少沟通成本、提高系统的开发效率</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">// 单行注释
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">/*
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">* 多行注释
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">*/</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">/**
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">* 文档注释
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">* &lt;p&gt; 可以采用html格式
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">* @author King
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">*/</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="2-标识符和关键字">2. 标识符和关键字<a hidden class="anchor" aria-hidden="true" href="#2-标识符和关键字">#</a></h1>
<p>标识符就是在Java程序中设置的各种类、方法、变量等的名字，同时还有一些标识符例如if、for等是Java已经赋予了特殊含义的标识符称为关键字。各种关键字有哪些可以在官网上查看：<a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html">官网</a></p>
<h1 id="3-基本数据类型以及包装类">3. 基本数据类型以及包装类<a hidden class="anchor" aria-hidden="true" href="#3-基本数据类型以及包装类">#</a></h1>
<p>八大基本数据类型：<code>boolean</code>、<code>byte</code>、<code>char</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>floet</code>、<code>double</code></p>
<p>对应的包装类：<code>Boolean</code>、<code>Byte</code>、<code>Character</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code></p>
<h1 id="4-类型转换和判断">4. 类型转换和判断<a hidden class="anchor" aria-hidden="true" href="#4-类型转换和判断">#</a></h1>
<p>类型转化分为两种方式：隐式类型转化和强制类型转化</p>
<h2 id="隐式类型转化">隐式类型转化<a hidden class="anchor" aria-hidden="true" href="#隐式类型转化">#</a></h2>
<ul>
<li>在Java基础数据类型中<code>byte</code> -&gt; <code>short</code> -&gt; <code>char</code> -&gt; <code>int</code> -&gt; <code>long</code> -&gt; <code>float</code> -&gt; <code>double</code>可以进行隐式的类型转化，前面的类型可以直接赋值给后面的类型</li>
<li>基本数据类型可以与包装类互相转化</li>
<li>子类对象可以赋值给父类对象使用</li>
</ul>
<h2 id="强制类型转化">强制类型转化<a hidden class="anchor" aria-hidden="true" href="#强制类型转化">#</a></h2>
<ul>
<li>基本数据类型从大类型到小类型的转换，需要使用强制转换符。在 <code>Java</code> 中，强制类型转换的格式为 <code>(type)value</code></li>
<li>类对象也可以采用这种方法进行强制类型转换，通常是某些方法返回值是<code>Object</code>类型此时需要强制类型转换</li>
</ul>
<h2 id="类型判断">类型判断<a hidden class="anchor" aria-hidden="true" href="#类型判断">#</a></h2>
<p>可以使用 <code>instanceof</code> 运算符来判断一个对象是否为一个类的实例。<code>instanceof</code> 运算符通过返回一个布尔值来指出，这个对象是否是这个特定类或者是它的子类的一个实例。</p>
<p><code>instanceof</code> 运算符的语法格式为：<code>object instanceof class</code>，其中 <code>object</code> 是要测试的对象，<code>class</code> 是类或接口类型。如果 <code>object</code> 是 <code>class</code> 的一个实例，则 <code>instanceof</code> 运算符返回 <code>true</code>；否则返回 <code>false</code></p>
<h1 id="5-变量常量和作用域">5. 变量、常量和作用域<a hidden class="anchor" aria-hidden="true" href="#5-变量常量和作用域">#</a></h1>
<p>作用域根据变量定义时的外侧的大括号进行判断。</p>
<h1 id="6-基本运算符">6. 基本运算符<a hidden class="anchor" aria-hidden="true" href="#6-基本运算符">#</a></h1>
<h2 id="自增自减运算符--">自增自减运算符（<code>++</code>、<code>--</code>）<a hidden class="anchor" aria-hidden="true" href="#自增自减运算符--">#</a></h2>
<p>自增、自减运算符可以用于整型数据以及浮点数据上，其中也包括<code>char</code>类型。</p>
<p><code>++</code> 位于变量名之前，则优先运算<code>++</code>的值，并将结果用于外部等式的运算。</p>
<p>若位于变量名之后，则优先进行外部等式的运算，在计算完成后变量再进行加减计算。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> a = <span style="color:#ff0;font-weight:bold">5</span>;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> b = a++;
</span></span><span style="display:flex;"><span>System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(a);
</span></span><span style="display:flex;"><span>System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(b);
</span></span><span style="display:flex;"><span>System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(--a);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 6
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">// 5
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">// 5
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="位移运算符">位移运算符<a hidden class="anchor" aria-hidden="true" href="#位移运算符">#</a></h2>
<p>位移运算法有<code>&gt;&gt;&gt; 、&gt;&gt;</code> 和 <code>&lt;&lt; </code>三种，操作都是针对二进制数，同时只对整型类型有效。</p>
<p>移位操作符实际上支持的类型只有<code>int</code>和<code>long</code>，编译器在对<code>short</code>、<code>byte</code>、<code>char</code>类型进行移位前，都会将其转换为<code>int</code>类型再操作</p>
<p>对于int类型当位移次数大于32次时会首先对位移数向32求余，类似于<code>a &gt;&gt;&gt; 33</code>等价于<code>a &gt;&gt;&gt; 1</code>，对于long类型是向64求余。其中<code>&gt;&gt;</code>在位移时会按照有符号的方式进行补位，而<code>&gt;&gt;&gt;</code>是直接补0。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> a = <span style="color:#ff0;font-weight:bold">5</span>; <span style="color:#007f7f">// 0000 0101
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(a &gt;&gt; <span style="color:#ff0;font-weight:bold">1</span>);<span style="color:#007f7f">// 0000 0010 = 2
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(a &lt;&lt; <span style="color:#ff0;font-weight:bold">1</span>);<span style="color:#007f7f">// 0000 1010 = 10
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(-<span style="color:#ff0;font-weight:bold">5</span> &gt;&gt;&gt; <span style="color:#ff0;font-weight:bold">1</span>);
</span></span><span style="display:flex;"><span><span style="color:#007f7f">//1111 1111 1111 1111 1111 1111 1111 1010 = -5
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">//0111 1111 1111 1111 1111 1111 1111 1101 = 2147483645
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#ff0;font-weight:bold">5</span> &gt;&gt;&gt; <span style="color:#ff0;font-weight:bold">1</span>);<span style="color:#007f7f">// 2
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="位运算">位运算<a hidden class="anchor" aria-hidden="true" href="#位运算">#</a></h2>
<ul>
<li>与<code>&amp;</code>：<code>1010 &amp; 0001 = 0000</code></li>
<li>或<code>|</code>：<code>1010 | 0001 = 1011</code></li>
<li>非<code>~</code>：<code>~0001 = 1110</code></li>
<li>异或<code>^</code>：<code>1010 ^ 1001 = 0011</code></li>
<li>同或：在Java中并没有同或的实现，但是可以通过先异或再取反的方式实现：<code>~ (1010 ^ 1001) = 1100</code>或者<code>(1010 ^ 1001) ^ -1 = 1100</code>；第二种方法中的<code>-1</code>是对应数据类型的<code>-1</code>，idea也提示两种方法的作用是相同的，建议还是使用第一种<img src="https://king-super.oss-cn-nanjing.aliyuncs.com/20230404145113.png" style="zoom: 50%;" /></li>
</ul>
<img src="https://king-super.oss-cn-nanjing.aliyuncs.com/20230404145025.png" style="zoom:50%;" />
<h2 id="math">Math<a hidden class="anchor" aria-hidden="true" href="#math">#</a></h2>
<p>Java中的Math类提供了很多有用的方法来执行基本数学运算。以下是一些常用的方法：</p>
<ul>
<li><code>abs()</code>：返回一个数的绝对值。</li>
<li><code>ceil()</code>：返回大于或等于参数的最小<code>double</code>值，等于一个整数。</li>
<li><code>floor()</code>：返回小于或等于参数的最大<code>double</code>值，等于一个整数。</li>
<li><code>max()</code>：返回两个参数中的最大值。</li>
<li><code>min()</code>：返回两个参数中的最小值。</li>
<li><code>pow()</code>：返回第一个参数的第二个参数次幂。</li>
<li><code>random()</code>：返回一个随机数。</li>
<li><code>round()</code>：返回一个四舍五入的整数。</li>
</ul>
<h1 id="7-包结构">7. 包结构<a hidden class="anchor" aria-hidden="true" href="#7-包结构">#</a></h1>
<p>主要涉及到的是<code>packing</code>关键词。<img loading="lazy" src="https://king-super.oss-cn-nanjing.aliyuncs.com/20230404145348.png" alt=""  />
</p>
<h1 id="8-顺序结构">8. 顺序结构<a hidden class="anchor" aria-hidden="true" href="#8-顺序结构">#</a></h1>
<h1 id="9-if">9. if<a hidden class="anchor" aria-hidden="true" href="#9-if">#</a></h1>
<h1 id="10-switch">10. switch<a hidden class="anchor" aria-hidden="true" href="#10-switch">#</a></h1>
<h1 id="11-while">11. while<a hidden class="anchor" aria-hidden="true" href="#11-while">#</a></h1>
<h1 id="12-for">12. for<a hidden class="anchor" aria-hidden="true" href="#12-for">#</a></h1>
<h1 id="13-foreach">13. foreach<a hidden class="anchor" aria-hidden="true" href="#13-foreach">#</a></h1>
<h1 id="14-breakcontinue">14. break、continue<a hidden class="anchor" aria-hidden="true" href="#14-breakcontinue">#</a></h1>
<h1 id="15-方法">15. 方法<a hidden class="anchor" aria-hidden="true" href="#15-方法">#</a></h1>
<h1 id="16-命令行的参数传递">16. 命令行的参数传递<a hidden class="anchor" aria-hidden="true" href="#16-命令行的参数传递">#</a></h1>
<p>当你使用<code>Java</code>命令行来运行程序时，如果在后面带上参数，<code>Java</code>的虚拟机就直接把这些参数存放到args数组中了，完成了命令行传参。</p>
<p>例如，你可以在命令行中输入以下命令来运行一个名为Main的Java类，并传递一个参数：<code>java Main arg1</code></p>
<p>在Main类中，你可以通过以下方式访问该参数：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> main(String[] args) {
</span></span><span style="display:flex;"><span>    System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(args[<span style="color:#ff0;font-weight:bold">0</span>]);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这将输出：<code>arg1</code></p>
<h1 id="17-可变参数">17. 可变参数<a hidden class="anchor" aria-hidden="true" href="#17-可变参数">#</a></h1>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> main(String[] args) {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> main(String... args) {
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述两种传参数方式是相同的，使用第二种时会在编译阶段重新封装为第一种。因此在使用可变参数的时候有以下几种限制：</p>
<ul>
<li>一个方法的形参中只能有一个可变参数</li>
<li>可变参数必须是最后一个形参</li>
</ul>
<h1 id="18-数组">18. 数组<a hidden class="anchor" aria-hidden="true" href="#18-数组">#</a></h1>
<h1 id="19-arrays">19. Arrays<a hidden class="anchor" aria-hidden="true" href="#19-arrays">#</a></h1>
<p>Java中的Arrays类提供了很多有用的方法来操作数组。以下是一些常用的方法：</p>
<ul>
<li>fill()：给数组赋值。</li>
<li>sort()：对数组进行排序。</li>
<li>equals()：比较两个数组是否相等。</li>
<li>binarySearch()：对排序好的数组进行二分查找。</li>
<li>asList()：将数组转换为List。</li>
<li>copyOf()：复制数组。</li>
<li>copyOfRange()：复制数组的一部分。</li>
<li>toString()：将数组转换为字符串。</li>
</ul>
<h1 id="20-类和对象">20. 类和对象<a hidden class="anchor" aria-hidden="true" href="#20-类和对象">#</a></h1>
<h1 id="21-构造函数">21. 构造函数<a hidden class="anchor" aria-hidden="true" href="#21-构造函数">#</a></h1>
<p>与类同名</p>
<h1 id="22-继承">22. 继承<a hidden class="anchor" aria-hidden="true" href="#22-继承">#</a></h1>
<p><code>extends</code>、<code>implements</code></p>
<h1 id="23-super">23. super<a hidden class="anchor" aria-hidden="true" href="#23-super">#</a></h1>
<h1 id="24-重写">24. 重写<a hidden class="anchor" aria-hidden="true" href="#24-重写">#</a></h1>
<p>继承后将父类的方法重新实现，根据里氏替换原则这是不建议的。</p>
<h1 id="25-static">25. static<a hidden class="anchor" aria-hidden="true" href="#25-static">#</a></h1>
<h1 id="26-抽象类">26. 抽象类<a hidden class="anchor" aria-hidden="true" href="#26-抽象类">#</a></h1>
<p><code>abstract</code></p>
<h1 id="27-接口">27. 接口<a hidden class="anchor" aria-hidden="true" href="#27-接口">#</a></h1>
<p><code>interface</code></p>
<h1 id="28-内部类">28. 内部类<a hidden class="anchor" aria-hidden="true" href="#28-内部类">#</a></h1>
<p>Java中的内部类分为四种：成员内部类、静态内部类、局部内部类和匿名内部类。</p>
<ul>
<li>成员内部类：定义在一个类的内部，且在该类的外部可以通过实例化对象来访问。</li>
<li>静态内部类：定义在一个类的内部，且在该类的外部可以直接通过“外部类.静态内部类”来访问。</li>
<li>局部内部类：定义在方法或作用域内，且只能在该方法或作用域内使用。</li>
<li>匿名内部类：没有名字的局部内部类。</li>
</ul>
<p>下面是一些例子：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">28
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">29
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">30
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">31
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">32
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">33
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">34
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">35
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">36
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">37
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">38
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">39
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">40
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">41
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">42
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">43
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">44
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">45
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> Outer {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">int</span> x = <span style="color:#ff0;font-weight:bold">10</span>;
</span></span><span style="display:flex;"><span>  	<span style="color:#007f7f">// 成员内部类
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">class</span> Inner {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">void</span> print() {
</span></span><span style="display:flex;"><span>            System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;x = &#34;</span> + x);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> Outer {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">int</span> x = <span style="color:#ff0;font-weight:bold">10</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#007f7f">// 静态内部类
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">class</span> Inner {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">void</span> print() {
</span></span><span style="display:flex;"><span>            System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;x = &#34;</span> + x);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> Outer {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> method() {
</span></span><span style="display:flex;"><span>				<span style="color:#007f7f">// 局部内部类
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">class</span> Inner {
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">void</span> print() {
</span></span><span style="display:flex;"><span>                System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;Hello World!&#34;</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        Inner inner = <span style="color:#fff;font-weight:bold">new</span> Inner();
</span></span><span style="display:flex;"><span>        inner.<span style="color:#007f7f">print</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> Outer {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> method() {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">new</span> Thread(   
</span></span><span style="display:flex;"><span>					<span style="color:#007f7f">// 匿名内部类
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>          <span style="color:#fff;font-weight:bold">new</span> Runnable() {
</span></span><span style="display:flex;"><span>            @Override
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> run() {
</span></span><span style="display:flex;"><span>                System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;Hello World!&#34;</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }).<span style="color:#007f7f">start</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="29-异常">29. 异常<a hidden class="anchor" aria-hidden="true" href="#29-异常">#</a></h1>
<p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p>
<ul>
<li><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 <code>Checked Exception</code> (受检查异常，必须处理) 和 <code>Unchecked Exception</code> (不受检查异常，可以不处理)。</li>
<li><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，<code>Java</code> 虚拟机（<code>JVM</code>）一般会选择线程终止。</li>
</ul>
<h2 id="checked-exception"><code>Checked Exception</code><a hidden class="anchor" aria-hidden="true" href="#checked-exception">#</a></h2>
<p><strong>Checked Exception</strong> 即<strong>受检查异常</strong> ，<code>Java</code> 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。</p>
<p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、<code>ClassNotFoundException</code> 、<code>SQLException</code></p>
<p>所有的异常都继承自<code>Exception</code>类，若继承自<code>RuntimeException</code>则是不受检查的，若直接继承自<code>Exception</code>则是受检查的异常。</p>
<p>异常可以在发生时告知发生的原因和内容。</p>
<h2 id="throwable-类常用方法有哪些"><code>Throwable</code> 类常用方法有哪些？<a hidden class="anchor" aria-hidden="true" href="#throwable-类常用方法有哪些">#</a></h2>
<ul>
<li><code>String getMessage()</code>: 返回异常发生时的简要描述</li>
<li><code>String toString()</code>: 返回异常发生时的详细信息</li>
<li><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li>
<li><code>void printStackTrace()</code>: 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li>
</ul>
<h2 id="try-catch-finally-如何使用">try-catch-finally 如何使用？<a hidden class="anchor" aria-hidden="true" href="#try-catch-finally-如何使用">#</a></h2>
<ul>
<li><code>try</code>块 ： 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li>
<li><code>catch</code>块 ： 用于处理 try 捕获到的异常。</li>
<li><code>finally</code> 块 ： 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li>
</ul>
<p>在对象实现AutoCloseable接口的情况下，可以使用 <code>try-with-resources</code>语法进行简化，不必再使用finally语句进行关闭操作，不过该部分执行的也只是关闭操作，如果需要执行额外的操作还是需要使用finally。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">// try-catch-finally
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>InputStream stream = <span style="color:#fff;font-weight:bold">null</span>;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>  	stream = <span style="color:#fff;font-weight:bold">new</span> FileInputStream(<span style="color:#0ff;font-weight:bold">&#34;test.txt&#34;</span>);
</span></span><span style="display:flex;"><span>} <span style="color:#fff;font-weight:bold">catch</span> (FileNotFoundException e) {
</span></span><span style="display:flex;"><span>  	<span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> RuntimeException(e);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">finally</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>      	stream.<span style="color:#007f7f">close</span>();
</span></span><span style="display:flex;"><span>    } <span style="color:#fff;font-weight:bold">catch</span> (IOException e) {
</span></span><span style="display:flex;"><span>      	<span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> RuntimeException(e);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// try-with-resources 这看起来就清爽很多了
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">// 不过使用的前提是要实现Closeable接口
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">try</span>(InputStream stream1 = <span style="color:#fff;font-weight:bold">new</span> FileInputStream(<span style="color:#0ff;font-weight:bold">&#34;test.txt&#34;</span>)){
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>} <span style="color:#fff;font-weight:bold">catch</span> (FileNotFoundException e) {
</span></span><span style="display:flex;"><span>  	<span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> RuntimeException(e);
</span></span><span style="display:flex;"><span>} <span style="color:#fff;font-weight:bold">catch</span> (IOException e) {
</span></span><span style="display:flex;"><span>  	<span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> RuntimeException(e);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="30-反射">30. 反射<a hidden class="anchor" aria-hidden="true" href="#30-反射">#</a></h1>
<h2 id="何谓反射">何谓反射？<a hidden class="anchor" aria-hidden="true" href="#何谓反射">#</a></h2>
<p>如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。</p>
<h2 id="反射的优缺点">反射的优缺点？<a hidden class="anchor" aria-hidden="true" href="#反射的优缺点">#</a></h2>
<p>反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。</p>
<p>不过，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。</p>
<p><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</p>
<p><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的</p>
<p>使用反射机制主要分为两部分：获取Class对象、同Class对象对对象进行操作，下面会根据这两部分进行介绍</p>
<h2 id="反射的应用场景">反射的应用场景？<a hidden class="anchor" aria-hidden="true" href="#反射的应用场景">#</a></h2>
<p>像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。但是！这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 <code>Spring</code>/Spring Boot、<code>MyBatis</code> 等等框架中都大量使用了反射机制。</p>
<p><strong>这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。</strong></p>
<p>比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 <code>Method</code> 来调用指定的方法。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> DebugInvocationHandler <span style="color:#fff;font-weight:bold">implements</span> InvocationHandler {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">/**
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">     * 代理类中的真实对象
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">final</span> Object target;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> DebugInvocationHandler(Object target) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">target</span> = target;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> Object invoke(Object proxy, Method method, Object[] args) <span style="color:#fff;font-weight:bold">throws</span> InvocationTargetException, IllegalAccessException {
</span></span><span style="display:flex;"><span>        System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;before method &#34;</span> + method.<span style="color:#007f7f">getName</span>());
</span></span><span style="display:flex;"><span>        Object result = method.<span style="color:#007f7f">invoke</span>(target, args);
</span></span><span style="display:flex;"><span>        System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;after method &#34;</span> + method.<span style="color:#007f7f">getName</span>());
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> result;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>另外，像 Java 中的一大利器 <strong>注解</strong> 的实现也用到了反射。</p>
<p>为什么你使用 <code>Spring</code> 的时候 ，一个@Component注解就声明了一个类为 <code>Spring Bean</code> 呢？为什么你通过一个 @Value注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？</p>
<p>这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。</p>
<h2 id="获取class对象对四种方法">获取Class对象对四种方法<a hidden class="anchor" aria-hidden="true" href="#获取class对象对四种方法">#</a></h2>
<ol>
<li>
<p>通过具体的类获取对象</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Class&lt;?&gt; clazz = TargetObject.<span style="color:#007f7f">Class</span>;
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>通过<code>Class.forName()</code>方法传入类的全路径获取</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Class&lt;?&gt; clazz = Class.<span style="color:#007f7f">forName</span>(<span style="color:#0ff;font-weight:bold">&#34;cn.king.TargetObject&#34;</span>);
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>通过类对象实例的<code>.getClass()</code>方法获取</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>TargetObject object = <span style="color:#fff;font-weight:bold">new</span> TargetObject();
</span></span><span style="display:flex;"><span>Class&lt;?&gt; clazz = object.<span style="color:#007f7f">getClass</span>();
</span></span></code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>通过类加载器传入类路径获取</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ClassLoader.<span style="color:#007f7f">getSystemClassLoader</span>().<span style="color:#007f7f">loadClass</span>(<span style="color:#0ff;font-weight:bold">&#34;cn.king.TargetObject&#34;</span>);
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ol>
<p>上述是四种获取Class对象的方法，其中前面两种方法都会进行类对象的初始化（静态代码块和静态对象的初始化），第三种已经创建了对象，此时是一定会进行初始化的，但是第四种获取的方式不会引起初始化，这是需要值得注意的，在有些特殊的场景下需要注意。</p>
<h2 id="反射的基本操作">反射的基本操作<a hidden class="anchor" aria-hidden="true" href="#反射的基本操作">#</a></h2>
<p>这部分主要是学习Class类中所具有的方法，一个类中主要有以下几部分组成：类成员变量、方法、类本身</p>
<h3 id="1-class类">1. Class类<a hidden class="anchor" aria-hidden="true" href="#1-class类">#</a></h3>
<ul>
<li><strong>获得类相关的方法</strong></li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>asSubclass(Class<U> clazz)</td>
<td>把传递的类的对象转换成代表其子类的对象</td>
</tr>
<tr>
<td>Cast</td>
<td>把对象转换成代表类或是接口的对象</td>
</tr>
<tr>
<td>getClassLoader()</td>
<td>获得类的加载器</td>
</tr>
<tr>
<td>getClasses()</td>
<td>返回一个数组，数组中包含该类中所有公共类和接口类的对象</td>
</tr>
<tr>
<td>getDeclaredClasses()</td>
<td>返回一个数组，数组中包含该类中所有类和接口类的对象</td>
</tr>
<tr>
<td>forName(String className)</td>
<td>根据类名返回类的对象</td>
</tr>
<tr>
<td>getName()</td>
<td>获得类的完整路径名字</td>
</tr>
<tr>
<td>newInstance()</td>
<td>创建类的实例</td>
</tr>
<tr>
<td>getPackage()</td>
<td>获得类的包</td>
</tr>
<tr>
<td>getSimpleName()</td>
<td>获得类的名字</td>
</tr>
<tr>
<td>getSuperclass()</td>
<td>获得当前类继承的父类的名字</td>
</tr>
<tr>
<td>getInterfaces()</td>
<td>获得当前类实现的类或是接口</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>获得类中属性相关的方法</strong></li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>getField(String name)</td>
<td>获得某个公有的属性对象</td>
</tr>
<tr>
<td>getFields()</td>
<td>获得所有公有的属性对象</td>
</tr>
<tr>
<td>getDeclaredField(String name)</td>
<td>获得某个属性对象</td>
</tr>
<tr>
<td>getDeclaredFields()</td>
<td>获得所有属性对象</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>获得类中注解相关的方法</strong></li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>getAnnotation(Class<A> annotationClass)</td>
<td>返回该类中与参数类型匹配的公有注解对象</td>
</tr>
<tr>
<td>getAnnotations()</td>
<td>返回该类所有的公有注解对象</td>
</tr>
<tr>
<td>getDeclaredAnnotation(Class<A> annotationClass)</td>
<td>返回该类中与参数类型匹配的所有注解对象</td>
</tr>
<tr>
<td>getDeclaredAnnotations()</td>
<td>返回该类所有的注解对象</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>获得类中构造器相关的方法</strong></li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>getConstructor(Class&hellip;<?> parameterTypes)</td>
<td>获得该类中与参数类型匹配的公有构造方法</td>
</tr>
<tr>
<td>getConstructors()</td>
<td>获得该类的所有公有构造方法</td>
</tr>
<tr>
<td>getDeclaredConstructor(Class&hellip;<?> parameterTypes)</td>
<td>获得该类中与参数类型匹配的构造方法</td>
</tr>
<tr>
<td>getDeclaredConstructors()</td>
<td>获得该类所有构造方法</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>获得类中方法相关的方法</strong></li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>getMethod(String name, Class&hellip;<?> parameterTypes)</td>
<td>获得该类某个公有的方法</td>
</tr>
<tr>
<td>getMethods()</td>
<td>获得该类所有公有的方法</td>
</tr>
<tr>
<td>getDeclaredMethod(String name, Class&hellip;<?> parameterTypes)</td>
<td>获得该类某个方法</td>
</tr>
<tr>
<td>getDeclaredMethods()</td>
<td>获得该类所有方法</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>类中其他重要的方法</strong></li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>isAnnotation()</td>
<td>如果是注解类型则返回true</td>
</tr>
<tr>
<td>isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</td>
<td>如果是指定类型注解类型则返回true</td>
</tr>
<tr>
<td>isAnonymousClass()</td>
<td>如果是匿名类则返回true</td>
</tr>
<tr>
<td>isArray()</td>
<td>如果是一个数组类则返回true</td>
</tr>
<tr>
<td>isEnum()</td>
<td>如果是枚举类则返回true</td>
</tr>
<tr>
<td>isInstance(Object obj)</td>
<td>如果obj是该类的实例则返回true</td>
</tr>
<tr>
<td>isInterface()</td>
<td>如果是接口类则返回true</td>
</tr>
<tr>
<td>isLocalClass()</td>
<td>如果是局部类则返回true</td>
</tr>
<tr>
<td>isMemberClass()</td>
<td>如果是内部类则返回true</td>
</tr>
</tbody>
</table>
<h3 id="2-field类">2. Field类<a hidden class="anchor" aria-hidden="true" href="#2-field类">#</a></h3>
<p>Field代表类的成员变量（成员变量也称为类的属性）。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>equals(Object obj)</td>
<td>属性与obj相等则返回true</td>
</tr>
<tr>
<td>get(Object obj)</td>
<td>获得obj中对应的属性值</td>
</tr>
<tr>
<td>set(Object obj, Object value)</td>
<td>设置obj中对应属性值</td>
</tr>
</tbody>
</table>
<h3 id="3-method类">3. Method类<a hidden class="anchor" aria-hidden="true" href="#3-method类">#</a></h3>
<p>Method代表类的方法。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>invoke(Object obj, Object&hellip; args)</td>
<td>传递object对象及参数调用该对象对应的方法</td>
</tr>
</tbody>
</table>
<h3 id="4-constructor类">4. Constructor类<a hidden class="anchor" aria-hidden="true" href="#4-constructor类">#</a></h3>
<p>Constructor代表类的构造方法。</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">newInstance(Object&hellip; initargs)</td>
<td style="text-align:left">根据传递的参数创建类的对象</td>
</tr>
</tbody>
</table>
<h1 id="31-多线程">31. 多线程<a hidden class="anchor" aria-hidden="true" href="#31-多线程">#</a></h1>
<h1 id="32-动态代理">32. 动态代理<a hidden class="anchor" aria-hidden="true" href="#32-动态代理">#</a></h1>
<h1 id="33-io介绍">33. IO介绍<a hidden class="anchor" aria-hidden="true" href="#33-io介绍">#</a></h1>
<p>一个程序可以分为<strong>内部</strong>与<strong>外部</strong>，内部通常是这个程序在CPU、内存上运行的，而外部可以是显示器、控制台、硬盘、其他电脑等等，在冯诺依曼的计算机结构中内部就是运算器、控制器、存储器，外部是输入设备与输出设备。将内部的数据输出到外部就是<strong>Output</strong>，将外部的数据输入内部就是<strong>Input</strong>。</p>
<p>将程序分为内部与外部是我自己的理解，其他人一般不会这么将，那为什么要将程序分为内部与外部呢？其实计算机（我们能接触到的设备）本质上就是处理数据的设备，如果只是将数据在程序内进行处理那么得到的这些数据是毫无作用的（因为你看不到这些数据），所以计算得到的数据需要通过Output展现在我们面前（我们一般看见的显示器、控制台、窗口都是通过Output实现的），有时候程序的运行以来外部的数据此时需要通过Input将数据给到程序。</p>
<img src="https://king-super.oss-cn-nanjing.aliyuncs.com/20230226132701.png" style="zoom: 33%;" />
<h2 id="分类">分类<a hidden class="anchor" aria-hidden="true" href="#分类">#</a></h2>
<p>在UNIX系统中IO模型一共分为五种：同步阻塞IO、同步非阻塞IO、IO多路复用、信号驱动IO、异步IO</p>
<p>在Java中有三种常见的IO</p>
<h3 id="bio">BIO<a hidden class="anchor" aria-hidden="true" href="#bio">#</a></h3>
<p>BIO- blocking IO 属于同步阻塞IO，同步阻塞IO模型中程序发起read调用后会一直阻塞，直到数据被拷贝到内存中。</p>
<img src="https://king-super.oss-cn-nanjing.aliyuncs.com/20230226133124.png" style="zoom: 33%;" />
<h3 id="nio-non-blockingnew-io">NIO (Non-blocking/New I/O)<a hidden class="anchor" aria-hidden="true" href="#nio-non-blockingnew-io">#</a></h3>
<p>ava 中的 NIO 于 Java 1.4 中引入，对应 <code>java.nio</code> 包，提供了 <code>Channel</code> , <code>Selector</code>，<code>Buffer</code> 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它是支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。</p>
<p>Java 中的 NIO 可以看作是 <strong>I/O 多路复用模型</strong>。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。</p>
<img src="https://king-super.oss-cn-nanjing.aliyuncs.com/20230226133233.png" style="zoom:33%;" />
<p>同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。</p>
<p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。</p>
<p>但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p>
<img src="https://king-super.oss-cn-nanjing.aliyuncs.com/20230226133354.png" style="zoom:33%;" />
<p>IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。</p>
<h3 id="aio-asynchronous-io">AIO (Asynchronous I/O)<a hidden class="anchor" aria-hidden="true" href="#aio-asynchronous-io">#</a></h3>
<p>AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。</p>
<p>异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p>
<img src="https://king-super.oss-cn-nanjing.aliyuncs.com/20230226133544.png" style="zoom:33%;" />
<h2 id="io">IO<a hidden class="anchor" aria-hidden="true" href="#io">#</a></h2>
<p>IO 即 <code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p>
<p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>
<ul>
<li><code>InputStream</code>/<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li><code>OutputStream</code>/<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<p><code>InputStream</code>用于从源头（通常是文件）读取数据（字节信息）到内存中，<code>java.io.InputStream</code>抽象类是所有字节输入流的父类。</p>
<p>需要注意的是<code>InputStream</code>、<code>Reader</code>、<code>OutputStream</code>、<code>Writer</code>四种类都是抽象类无法直接使用。</p>
<p>其中四种类最常用的子类是<code>FileInputStream</code>、<code>FileReader</code>、<code>FileOutputStream</code>、<code>FileWriter</code></p>
<h3 id="字节流">字节流<a hidden class="anchor" aria-hidden="true" href="#字节流">#</a></h3>
<h4 id="inputstream字节输入流">InputStream（字节输入流）<a hidden class="anchor" aria-hidden="true" href="#inputstream字节输入流">#</a></h4>
<p><code>InputStream</code> 常用方法 ：</p>
<ul>
<li><code>read()</code> ：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 <code>-1</code> ，表示文件结束。</li>
<li><code>read(byte b[ ])</code> : 从输入流中读取一些字节存储到数组 <code>b</code> 中。如果数组 <code>b</code> 的长度为零，则不读取。如果没有可用字节读取，返回 <code>-1</code>。如果有可用字节读取，则最多读取的字节数最多等于 <code>b.length</code> ， 返回读取的字节数。这个方法等价于 <code>read(b, 0, b.length)</code>。</li>
<li><code>read(byte b[], int off, int len)</code> ：在<code>read(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code>参数（要读取的最大字节数）。</li>
<li><code>skip(long n)</code> ：忽略输入流中的 n 个字节 ,返回实际忽略的字节数。</li>
<li><code>available()</code> ：返回输入流中可以读取的字节数。</li>
<li><code>close()</code> ：关闭输入流释放相关的系统资源。</li>
</ul>
<p>从 Java 9 开始，<code>InputStream</code> 新增加了多个实用的方法：</p>
<ul>
<li><code>readAllBytes()</code> ：读取输入流中的所有字节，返回字节数组。</li>
<li><code>readNBytes(byte[] b, int off, int len)</code> ：阻塞直到读取 <code>len</code> 个字节。</li>
<li><code>transferTo(OutputStream out)</code> ： 将所有字节从一个输入流传递到一个输出流。</li>
</ul>
<p><code>FileInputStream</code> 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。</p>
<p><code>FileInputStream</code> 代码示例：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">try</span> (InputStream fis = <span style="color:#fff;font-weight:bold">new</span> FileInputStream(<span style="color:#0ff;font-weight:bold">&#34;input.txt&#34;</span>)) {
</span></span><span style="display:flex;"><span>    System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;Number of remaining bytes:&#34;</span>
</span></span><span style="display:flex;"><span>            + fis.<span style="color:#007f7f">available</span>());
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> content;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">long</span> skip = fis.<span style="color:#007f7f">skip</span>(<span style="color:#ff0;font-weight:bold">2</span>);
</span></span><span style="display:flex;"><span>    System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;The actual number of bytes skipped:&#34;</span> + skip);
</span></span><span style="display:flex;"><span>    System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">print</span>(<span style="color:#0ff;font-weight:bold">&#34;The content read from file:&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">while</span> ((content = fis.<span style="color:#007f7f">read</span>()) != -<span style="color:#ff0;font-weight:bold">1</span>) {
</span></span><span style="display:flex;"><span>        System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">print</span>((<span style="color:#fff;font-weight:bold">char</span>) content);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>} <span style="color:#fff;font-weight:bold">catch</span> (IOException e) {
</span></span><span style="display:flex;"><span>    e.<span style="color:#007f7f">printStackTrace</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="outputstream字节输出流">OutputStream（字节输出流）<a hidden class="anchor" aria-hidden="true" href="#outputstream字节输出流">#</a></h4>
<p><code>OutputStream</code>用于将数据（字节信息）写入到目的地（通常是文件），<code>java.io.OutputStream</code>抽象类是所有字节输出流的父类。</p>
<p><code>OutputStream</code> 常用方法 ：</p>
<ul>
<li><code>write(int b)</code> ：将特定字节写入输出流。</li>
<li><code>write(byte b[])</code> : 将数组<code>b</code> 写入到输出流，等价于 <code>write(b, 0, b.length)</code> 。</li>
<li><code>write(byte[] b, int off, int len)</code> : 在<code>write(byte b[ ])</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字节数）。</li>
<li><code>flush()</code> ：刷新此输出流并强制写出所有缓冲的输出字节。</li>
<li><code>close()</code> ：关闭输出流释放相关的系统资源。</li>
</ul>
<p><code>FileOutputStream</code> 是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。</p>
<p><code>FileOutputStream</code> 代码示例：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">try</span> (FileOutputStream output = <span style="color:#fff;font-weight:bold">new</span> FileOutputStream(<span style="color:#0ff;font-weight:bold">&#34;output.txt&#34;</span>)) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">byte</span>[] array = <span style="color:#0ff;font-weight:bold">&#34;King&#34;</span>.<span style="color:#007f7f">getBytes</span>();
</span></span><span style="display:flex;"><span>    output.<span style="color:#007f7f">write</span>(array);
</span></span><span style="display:flex;"><span>} <span style="color:#fff;font-weight:bold">catch</span> (IOException e) {
</span></span><span style="display:flex;"><span>    e.<span style="color:#007f7f">printStackTrace</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="字符流">字符流<a hidden class="anchor" aria-hidden="true" href="#字符流">#</a></h3>
<p>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节。 <strong>那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p>
<p>个人认为主要有两点原因：</p>
<ul>
<li>字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时。</li>
<li>如果我们不知道编码类型就很容易出现乱码问题。</li>
</ul>
<p>乱码问题这个很容易就可以复现，我们只需要将上面提到的 <code>FileInputStream</code> 代码示例中的 <code>input.txt</code> 文件内容改为中文即可，原代码不需要改动。</p>
<p>因此，I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。字符流默认采用的是 <code>Unicode</code> 编码，我们可以通过构造方法自定义编码。</p>
<h4 id="reader字符输入流">Reader（字符输入流）<a hidden class="anchor" aria-hidden="true" href="#reader字符输入流">#</a></h4>
<p><code>Reader</code>用于从源头（通常是文件）读取数据（字符信息）到内存中，<code>java.io.Reader</code>抽象类是所有字符输入流的父类。</p>
<p><code>Reader</code> 用于读取文本， <code>InputStream</code> 用于读取原始字节。</p>
<p><code>Reader</code> 常用方法 ：</p>
<ul>
<li><code>read()</code> : 从输入流读取一个字符。</li>
<li><code>read(char[] cbuf)</code> : 从输入流中读取一些字符，并将它们存储到字符数组 <code>cbuf</code>中，等价于 <code>read(cbuf, 0, cbuf.length)</code> 。</li>
<li><code>read(char[] cbuf, int off, int len)</code> ：在<code>read(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li>
<li><code>skip(long n)</code> ：忽略输入流中的 n 个字符 ,返回实际忽略的字符数。</li>
<li><code>close()</code> : 关闭输入流并释放相关的系统资源。</li>
</ul>
<p><code>InputStreamReader</code> 是字节流转换为字符流的桥梁，其子类 <code>FileReader</code> 是基于该基础上的封装，可以直接操作字符文件。<code>InputStreamReader</code>实质是对<code>InputStream</code>的一次封装，根据不同的编码方式将字节转化为字符。从这也可以看出真正具备读取、书写能力的是字节流，字符流是对字节流的一层封装使得流更加好用了。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">// 字节流转换为字符流的桥梁
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> InputStreamReader <span style="color:#fff;font-weight:bold">extends</span> Reader {
</span></span><span style="display:flex;"><span>  	<span style="color:#fff;font-weight:bold">public</span> InputStreamReader(InputStream in) { <span style="color:#007f7f">// 构造时就需要一个InputStream
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>				... <span style="color:#f00">省略</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  	... <span style="color:#f00">省略</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 用于读取字符文件
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> FileReader <span style="color:#fff;font-weight:bold">extends</span> InputStreamReader {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> FileReader(String fileName) <span style="color:#fff;font-weight:bold">throws</span> FileNotFoundException {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">super</span>(<span style="color:#fff;font-weight:bold">new</span> FileInputStream(fileName));<span style="color:#007f7f">// 创建了一个InputStream传递给InputStreamReader的构造函数
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    }
</span></span><span style="display:flex;"><span>  	... <span style="color:#f00">省略</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>FileReader</code> 代码示例：<code>FileReader</code>继承自<code>InputStreamReader</code>，使用<code>InputStreamReader</code>将字节转化为字符的能力进行字符的读取。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">try</span> (FileReader fileReader = <span style="color:#fff;font-weight:bold">new</span> FileReader(<span style="color:#0ff;font-weight:bold">&#34;input.txt&#34;</span>);) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> content;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">long</span> skip = fileReader.<span style="color:#007f7f">skip</span>(<span style="color:#ff0;font-weight:bold">3</span>);
</span></span><span style="display:flex;"><span>    System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;The actual number of bytes skipped:&#34;</span> + skip);
</span></span><span style="display:flex;"><span>    System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">print</span>(<span style="color:#0ff;font-weight:bold">&#34;The content read from file:&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">while</span> ((content = fileReader.<span style="color:#007f7f">read</span>()) != -<span style="color:#ff0;font-weight:bold">1</span>) {
</span></span><span style="display:flex;"><span>        System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">print</span>((<span style="color:#fff;font-weight:bold">char</span>) content);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>} <span style="color:#fff;font-weight:bold">catch</span> (IOException e) {
</span></span><span style="display:flex;"><span>    e.<span style="color:#007f7f">printStackTrace</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="writer字符输出流">Writer（字符输出流）<a hidden class="anchor" aria-hidden="true" href="#writer字符输出流">#</a></h4>
<p><code>Writer</code>用于将数据（字符信息）写入到目的地（通常是文件），<code>java.io.Writer</code>抽象类是所有字符输出流的父类。</p>
<p><code>Writer</code> 常用方法 ：</p>
<ul>
<li><code>write(int c)</code> : 写入单个字符。</li>
<li><code>write(char[] cbuf)</code> ：写入字符数组 <code>cbuf</code>，等价于<code>write(cbuf, 0, cbuf.length)</code>。</li>
<li><code>write(char[] cbuf, int off, int len)</code> ：在<code>write(char[] cbuf)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li>
<li><code>write(String str)</code> ：写入字符串，等价于 <code>write(str, 0, str.length())</code> 。</li>
<li><code>write(String str, int off, int len)</code> ：在<code>write(String str)</code> 方法的基础上增加了 <code>off</code> 参数（偏移量）和 <code>len</code> 参数（要读取的最大字符数）。</li>
<li><code>append(CharSequence csq)</code> ：将指定的字符序列附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li>
<li><code>append(char c)</code> ：将指定的字符附加到指定的 <code>Writer</code> 对象并返回该 <code>Writer</code> 对象。</li>
<li><code>flush()</code> ：刷新此输出流并强制写出所有缓冲的输出字符。</li>
<li><code>close()</code>:关闭输出流释放相关的系统资源。</li>
</ul>
<p><code>OutputStreamWriter</code> 是字符流转换为字节流的桥梁，其子类 <code>FileWriter</code> 是基于该基础上的封装，可以直接将字符写入到文件。其中转化的调用不再做介绍了与Reader相同。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">// 字符流转换为字节流的桥梁
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> OutputStreamWriter <span style="color:#fff;font-weight:bold">extends</span> Writer {
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 用于写入字符到文件
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> FileWriter <span style="color:#fff;font-weight:bold">extends</span> OutputStreamWriter {
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>FileWriter</code> 代码示例：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">try</span> (Writer output = <span style="color:#fff;font-weight:bold">new</span> FileWriter(<span style="color:#0ff;font-weight:bold">&#34;output.txt&#34;</span>)) {
</span></span><span style="display:flex;"><span>    output.<span style="color:#007f7f">write</span>(<span style="color:#0ff;font-weight:bold">&#34;你好，我是King。&#34;</span>);
</span></span><span style="display:flex;"><span>} <span style="color:#fff;font-weight:bold">catch</span> (IOException e) {
</span></span><span style="display:flex;"><span>    e.<span style="color:#007f7f">printStackTrace</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>InputStreamReader、OutputStreamWriter两者也被称为转换流，这两个流是Reader和Writer实现的基础。下面两者的作用是相同的（源码中也是这么实现的）并且InputStreamReader就是Reader的子类，后面在外层嵌套装饰流时作为Reader（不要弄错了）。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>FileReader reader = <span style="color:#fff;font-weight:bold">new</span> FileReader(<span style="color:#0ff;font-weight:bold">&#34;XXX&#34;</span>);
</span></span><span style="display:flex;"><span>InputStreamReader reader2 = <span style="color:#fff;font-weight:bold">new</span> InputStreamReader(<span style="color:#fff;font-weight:bold">new</span> FileInputStream(<span style="color:#0ff;font-weight:bold">&#34;XXX&#34;</span>));
</span></span></code></pre></td></tr></table>
</div>
</div><p>并且存在的字符流都存在对应的字节流（基本都是通过字节流实现的）。</p>
<h3 id="装饰流">装饰流<a hidden class="anchor" aria-hidden="true" href="#装饰流">#</a></h3>
<p><code>FilterInputStream</code>、<code>FilterOutputStream</code>、<code>FilterReader</code>、<code>FilterWriter</code></p>
<p>这四种流分别继承自上述的四种流，知道装饰者模式的朋友对这四个流应该就非常熟悉了，这四种流的作用也十分简单：就是为基础流提供扩展时以这些流作为基础。这四个基本的装饰流没有提供任何额外的功能，继承自对应的流，并且重写了对应的方法，但是方法中没有进行过多的处理，之间调用了四种基础流的内容。</p>
<p>用法就是在创建装饰流时用已经创建好的基础流或者基础流的子类作为对象进行传入，装饰流相当对基础流的方法进行了扩展。下面要讲的缓冲流、打印流、数据流、对象流都是继承自这四种装饰流。</p>
<p>其实最基础的功能均由基础的四种流提供。</p>
<h3 id="缓冲流">缓冲流<a hidden class="anchor" aria-hidden="true" href="#缓冲流">#</a></h3>
<p>缓冲流的主要作用就是减少IO次数以提高性能，在大数据流读取的环境下建议使用。</p>
<h4 id="字节缓冲流">字节缓冲流<a hidden class="anchor" aria-hidden="true" href="#字节缓冲流">#</a></h4>
<p>IO 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取/写入多个字节，从而避免频繁的 IO 操作，提高流的传输效率。</p>
<p>字节缓冲流这里采用了装饰器模式来增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象的功能。</p>
<p>举个例子，我们可以通过 <code>BufferedInputStream</code>（字节缓冲输入流）来增强 <code>FileInputStream</code> 的功能。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">// 新建一个 BufferedInputStream 对象
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>BufferedInputStream bufferedInputStream = <span style="color:#fff;font-weight:bold">new</span> BufferedInputStream(<span style="color:#fff;font-weight:bold">new</span> FileInputStream(<span style="color:#0ff;font-weight:bold">&#34;input.txt&#34;</span>));
</span></span></code></pre></td></tr></table>
</div>
</div><p>在读取大文件时建议使用缓冲流套一层，效果会比较好。</p>
<h5 id="bufferedinputstream字节缓冲输入流">BufferedInputStream（字节缓冲输入流）<a hidden class="anchor" aria-hidden="true" href="#bufferedinputstream字节缓冲输入流">#</a></h5>
<p><code>BufferedInputStream</code> 从源头（通常是文件）读取数据（字节信息）到内存的过程中不会一个字节一个字节的读取，而是会先将读取到的字节存放在缓存区，并从内部缓冲区中单独读取字节。这样大幅减少了 IO 次数，提高了读取效率。<code>BufferedInputStream</code> 内部维护了一个缓冲区，这个缓冲区实际就是一个字节数组。</p>
<p>缓冲区的大小默认为 <strong>8192</strong> 字节，可以通过 <code>BufferedInputStream(InputStream in, int size)</code> 这个构造方法来指定缓冲区的大小。</p>
<h5 id="bufferedoutputstream字节缓冲输出流">BufferedOutputStream（字节缓冲输出流）<a hidden class="anchor" aria-hidden="true" href="#bufferedoutputstream字节缓冲输出流">#</a></h5>
<p><code>BufferedOutputStream</code> 将数据（字节信息）写入到目的地（通常是文件）的过程中不会一个字节一个字节的写入，而是会先将要写入的字节存放在缓存区，并从内部缓冲区中单独写入字节。这样大幅减少了 IO 次数，提高了读取效率</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">try</span> (BufferedOutputStream bos = <span style="color:#fff;font-weight:bold">new</span> BufferedOutputStream(<span style="color:#fff;font-weight:bold">new</span> FileOutputStream(<span style="color:#0ff;font-weight:bold">&#34;output.txt&#34;</span>))) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">byte</span>[] array = <span style="color:#0ff;font-weight:bold">&#34;King&#34;</span>.<span style="color:#007f7f">getBytes</span>();
</span></span><span style="display:flex;"><span>    bos.<span style="color:#007f7f">write</span>(array);
</span></span><span style="display:flex;"><span>} <span style="color:#fff;font-weight:bold">catch</span> (IOException e) {
</span></span><span style="display:flex;"><span>    e.<span style="color:#007f7f">printStackTrace</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>类似于 <code>BufferedInputStream</code> ，<code>BufferedOutputStream</code> 内部也维护了一个缓冲区，并且，这个缓存区的大小也是 <strong>8192</strong> 字节。</p>
<h4 id="字符缓冲流">字符缓冲流<a hidden class="anchor" aria-hidden="true" href="#字符缓冲流">#</a></h4>
<p><code>BufferedReader</code> （字符缓冲输入流）和 <code>BufferedWriter</code>（字符缓冲输出流）类似于 <code>BufferedInputStream</code>（字节缓冲输入流）和<code>BufferedOutputStream</code>（字节缓冲输入流），内部都维护了一个字节数组作为缓冲区。不过，前者主要是用来操作字符信息。</p>
<h3 id="打印流">打印流<a hidden class="anchor" aria-hidden="true" href="#打印流">#</a></h3>
<p>这里需要介绍的两个打印流就是我们常用的<code>Scanner</code>与<code>PrintStream</code>。</p>
<h4 id="scanner">Scanner<a hidden class="anchor" aria-hidden="true" href="#scanner">#</a></h4>
<p>这个类更像是一个工具类，其本质就是在初始化时接受一个<code>InputStream</code>对象，然后从这个对象中接受数据，并且提供了非常多的方法使你读取对象中的数据，我们常常将<code>System.in</code>对象传入，这个是控制台我们并不能主动创建，是通过<code>c++</code>实现的，我们只能从<code>System</code>类中取出来用。</p>
<p>想要读取控制台的数据其实还可以使用其他方式：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">byte</span>[] x = <span style="color:#fff;font-weight:bold">new</span> <span style="color:#fff;font-weight:bold">byte</span>[<span style="color:#ff0;font-weight:bold">10</span>];
</span></span><span style="display:flex;"><span>BufferedInputStream inputStream1 = <span style="color:#fff;font-weight:bold">new</span> BufferedInputStream(System.<span style="color:#007f7f">in</span>);
</span></span><span style="display:flex;"><span>inputStream1.<span style="color:#007f7f">read</span>(x);
</span></span><span style="display:flex;"><span>System.<span style="color:#007f7f">in</span>.<span style="color:#007f7f">read</span>(x);
</span></span></code></pre></td></tr></table>
</div>
</div><p>只不过通过这种方法读取的数据是<code>byte</code>，需要自己进行类型转化十分的不方便，而<code>Scanner</code>就是封装好了各种类型转化的方法咱们直接拿来用就好。</p>
<h4 id="printstream">PrintStream<a hidden class="anchor" aria-hidden="true" href="#printstream">#</a></h4>
<p>本质是个装饰类，需要设置真正读取数据的<code>OutputStream</code>对象，<code>System.out</code>中的这个对象是通过<code>C++</code>实现的可以直接拿来用。通过反射我们可以看到底层还是通过<code>FileOutputStream</code>实现，但是在<code>FileOutputStream</code>是使用了<code>FileDescriptor</code>进行实现，该对象已经通过默认句柄封装好了，还有兴趣往下探索的可以看jvm的源码。</p>
<p><img loading="lazy" src="https://king-super.oss-cn-nanjing.aliyuncs.com/20230226223726.png" alt=""  />
</p>
<p><code>PrintStream</code>存在自动刷新机制，例如当向<code>PrintStream</code>流中写入一个字节数组后自动调用<code>flush()</code>方法。<code>PrintStream</code>也永远不会抛出异常，而是使用内部检查机制checkError()方法进行错误检查。最方便的是，它能够格式化任意的类型，将它们以字符串的形式写入到输出流。</p>
<h3 id="数据流">数据流<a hidden class="anchor" aria-hidden="true" href="#数据流">#</a></h3>
<p><code>DataInputStream</code>和<code>DataOutputStream</code>可以直接将字节转化为需要的类型，通常是基本类型。</p>
<h3 id="对象流">对象流<a hidden class="anchor" aria-hidden="true" href="#对象流">#</a></h3>
<p><code>ObjectOutputStream</code>、<code>ObjectOInputStream</code>通常用于序列化与反序列化（Java原生的序列号与反序列化）。</p>
<h2 id="nio">NIO<a hidden class="anchor" aria-hidden="true" href="#nio">#</a></h2>
<h3 id="缓冲区">缓冲区<a hidden class="anchor" aria-hidden="true" href="#缓冲区">#</a></h3>
<p><code>Buffer</code>中共定义了四个变量，用于控制缓冲区内数据的位置：<code>mark</code>-用于标记位置，在读时用到、<code>position</code>-标记现在处在的位置用于存放读取数据、<code>limit</code>-用于现实<code>position</code>的最大位置、<code>capacity</code>-标记缓冲区大小。</p>
<p>Buffer类是缓冲区的实现，类似于Java中的数组，也是用于存放和获取数据的。但是Buffer相比Java中的数组，功能就非常强大了，它包含一系列对于数组的快捷操作。</p>
<p>Buffer是一个抽象类，它的核心内容：（除了capacity其余的变量都是可以通过方法直接设置位置的）</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">abstract</span> <span style="color:#fff;font-weight:bold">class</span> Buffer {
</span></span><span style="display:flex;"><span>		<span style="color:#007f7f">// 这四个变量的关系: mark &lt;= position &lt;= limit &lt;= capacity
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  	<span style="color:#007f7f">// 这些变量就是Buffer操作的核心了，之后我们学习的过程中可以看源码是如何操作这些变量的
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">int</span> mark = -<span style="color:#ff0;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">int</span> position = <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">int</span> limit;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">int</span> capacity;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 直接缓冲区实现子类的数据内存地址（之后会讲解）
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">long</span> address;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们来看看Buffer类的子类，包括我们认识到的所有基本类型（除了<code>boolean</code>类型之外）：</p>
<ul>
<li>
<p>IntBuffer  -  int类型的缓冲区。</p>
</li>
<li>
<p>ShortBuffer  -  short类型的缓冲区。</p>
</li>
<li>
<p>LongBuffer  -  long类型的缓冲区。</p>
</li>
<li>
<p>FloatBuffer  -  float类型的缓冲区。</p>
</li>
<li>
<p>DoubleBuffer  -  double类型的缓冲区。</p>
</li>
<li>
<p>ByteBuffer  -  byte类型的缓冲区。</p>
</li>
<li>
<p>CharBuffer  -  char类型的缓冲区。</p>
</li>
</ul>
<h4 id="缓冲区构造">缓冲区构造<a hidden class="anchor" aria-hidden="true" href="#缓冲区构造">#</a></h4>
<p>构造缓冲区有两个方法：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> main(String[] args) {
</span></span><span style="display:flex;"><span>  	<span style="color:#007f7f">//创建一个缓冲区不能直接new，而是需要使用静态方法去生成，有两种方式：
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#007f7f">//1. 申请一个容量为10的int缓冲区
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    IntBuffer buffer = IntBuffer.<span style="color:#007f7f">allocate</span>(<span style="color:#ff0;font-weight:bold">10</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">//2. 可以将现有的数组直接转换为缓冲区（包括数组中的数据）
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">int</span>[] arr = <span style="color:#fff;font-weight:bold">new</span> <span style="color:#fff;font-weight:bold">int</span>[]{<span style="color:#ff0;font-weight:bold">1</span>, <span style="color:#ff0;font-weight:bold">2</span>, <span style="color:#ff0;font-weight:bold">3</span>, <span style="color:#ff0;font-weight:bold">4</span>, <span style="color:#ff0;font-weight:bold">5</span>, <span style="color:#ff0;font-weight:bold">6</span>};
</span></span><span style="display:flex;"><span>    IntBuffer buffer = IntBuffer.<span style="color:#007f7f">wrap</span>(arr);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面以IntBuffer为例分别看一下两个方法的内容，其中会用到的类的一个继承关系：</p>
<img src="https://king-super.oss-cn-nanjing.aliyuncs.com/20230227101737.png" style="zoom: 50%;" />
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">28
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">29
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">30
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">31
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">32
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">33
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">34
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">// allocate
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// IntBuffer
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> IntBuffer allocate(<span style="color:#fff;font-weight:bold">int</span> capacity) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (capacity &lt; <span style="color:#ff0;font-weight:bold">0</span>)
</span></span><span style="display:flex;"><span>      	<span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> IllegalArgumentException();
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">new</span> HeapIntBuffer(capacity, capacity);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// HeapIntBuffer
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>HeapIntBuffer(<span style="color:#fff;font-weight:bold">int</span> cap, <span style="color:#fff;font-weight:bold">int</span> lim) {
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">super</span>(-<span style="color:#ff0;font-weight:bold">1</span>, <span style="color:#ff0;font-weight:bold">0</span>, lim, cap, <span style="color:#fff;font-weight:bold">new</span> <span style="color:#fff;font-weight:bold">int</span>[cap], <span style="color:#ff0;font-weight:bold">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// IntBuffer
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>IntBuffer(<span style="color:#fff;font-weight:bold">int</span> mark, <span style="color:#fff;font-weight:bold">int</span> pos, <span style="color:#fff;font-weight:bold">int</span> lim, <span style="color:#fff;font-weight:bold">int</span> cap, <span style="color:#fff;font-weight:bold">int</span>[] hb, <span style="color:#fff;font-weight:bold">int</span> offset){
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">super</span>(mark, pos, lim, cap);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">hb</span> = hb;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">offset</span> = offset;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// Buffer
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>Buffer(<span style="color:#fff;font-weight:bold">int</span> mark, <span style="color:#fff;font-weight:bold">int</span> pos, <span style="color:#fff;font-weight:bold">int</span> lim, <span style="color:#fff;font-weight:bold">int</span> cap) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (cap &lt; <span style="color:#ff0;font-weight:bold">0</span>)
</span></span><span style="display:flex;"><span>      	<span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> IllegalArgumentException(<span style="color:#0ff;font-weight:bold">&#34;Negative capacity: &#34;</span> + cap);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">capacity</span> = cap;
</span></span><span style="display:flex;"><span>    limit(lim);
</span></span><span style="display:flex;"><span>    position(pos);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (mark &gt;= <span style="color:#ff0;font-weight:bold">0</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">if</span> (mark &gt; pos)
</span></span><span style="display:flex;"><span>          	<span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> IllegalArgumentException(<span style="color:#0ff;font-weight:bold">&#34;mark &gt; position: (&#34;</span> + mark + <span style="color:#0ff;font-weight:bold">&#34; &gt; &#34;</span> + pos + <span style="color:#0ff;font-weight:bold">&#34;)&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">mark</span> = mark;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述方法有一点需要注意：这些构造方法的修饰权限是默认的，所以我们无法直接使用构造函数进行创建。</p>
<p>在IntBuffer方法中创建了数组用于存放缓冲数据，这就是缓冲区的底层实现，然后对刚刚提到的Buffer中的四个标志进行了初始化。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">// wrap
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// IntBuffer
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> IntBuffer wrap(<span style="color:#fff;font-weight:bold">int</span>[] array) {
</span></span><span style="display:flex;"><span>  	<span style="color:#fff;font-weight:bold">return</span> wrap(array, <span style="color:#ff0;font-weight:bold">0</span>, array.<span style="color:#007f7f">length</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> IntBuffer wrap(<span style="color:#fff;font-weight:bold">int</span>[] array, <span style="color:#fff;font-weight:bold">int</span> offset, <span style="color:#fff;font-weight:bold">int</span> length){
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>      	<span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">new</span> HeapIntBuffer(array, offset, length);
</span></span><span style="display:flex;"><span>    } <span style="color:#fff;font-weight:bold">catch</span> (IllegalArgumentException x) {
</span></span><span style="display:flex;"><span>      	<span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> IndexOutOfBoundsException();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// HeapintBuffer
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>HeapIntBuffer(<span style="color:#fff;font-weight:bold">int</span>[] buf, <span style="color:#fff;font-weight:bold">int</span> off, <span style="color:#fff;font-weight:bold">int</span> len) {
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">super</span>(-<span style="color:#ff0;font-weight:bold">1</span>, off, off + len, buf.<span style="color:#007f7f">length</span>, buf, <span style="color:#ff0;font-weight:bold">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="缓冲区写操作">缓冲区写操作<a hidden class="anchor" aria-hidden="true" href="#缓冲区写操作">#</a></h4>
<p>数据的存放包括以下四个方法：</p>
<ul>
<li>
<p>public abstract IntBuffer put(int i);  -  在当前position位置插入数据，由具体子类实现</p>
</li>
<li>
<p>public abstract IntBuffer put(int index, int i);  -  在指定位置存放数据，也是由具体子类实现</p>
</li>
<li>
<p>public final IntBuffer put(int[] src);  -  直接存放所有数组中的内容（数组长度不能超出缓冲区大小）</p>
</li>
<li>
<p>public IntBuffer put(int[] src, int offset, int length);  -  直接存放数组中的内容，同上，但是可以指定存放一段范围</p>
</li>
<li>
<p>public IntBuffer put(IntBuffer src);  -  直接存放另一个缓冲区中的内容</p>
</li>
</ul>
<p>put操作实际就是在position的位置插入一个数据，然后向后移动一位，并且会检查是否超多了限制limit：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> IntBuffer put(<span style="color:#fff;font-weight:bold">int</span> x) {
</span></span><span style="display:flex;"><span>    hb[ix(nextPutIndex())] = x;   <span style="color:#007f7f">//这个ix和nextPutIndex()很灵性，我们来看看具体实现
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">protected</span> <span style="color:#fff;font-weight:bold">int</span> ix(<span style="color:#fff;font-weight:bold">int</span> i) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> i + offset;   <span style="color:#007f7f">//将i的值加上我们之前设定的offset偏移量值，但是默认是0（非0的情况后面会介绍）
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">int</span> nextPutIndex() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> p = position;    <span style="color:#007f7f">//获取Buffer类中的position位置（一开始也是0）
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> (p &gt;= limit)    <span style="color:#007f7f">//位置肯定不能超过底层数组最大长度，否则越界
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> BufferOverflowException();
</span></span><span style="display:flex;"><span>    position = p + <span style="color:#ff0;font-weight:bold">1</span>;   <span style="color:#007f7f">//获取之后会使得Buffer类中的position+1
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">return</span> p;   <span style="color:#007f7f">//返回当前的位置
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>}	
</span></span></code></pre></td></tr></table>
</div>
</div><p>第二种put方法就是直接在指定位置写入数据（若原先存在数据也是直接覆盖）</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> IntBuffer put(<span style="color:#fff;font-weight:bold">int</span> i, <span style="color:#fff;font-weight:bold">int</span> x) {
</span></span><span style="display:flex;"><span>    hb[ix(checkIndex(i))] = x;  <span style="color:#007f7f">//这里依然会使用ix，但是会检查位置是否合法
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">int</span> checkIndex(<span style="color:#fff;font-weight:bold">int</span> i) {                       <span style="color:#007f7f">// package-private
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> ((i &lt; <span style="color:#ff0;font-weight:bold">0</span>) || (i &gt;= limit))    <span style="color:#007f7f">//插入的位置不能小于0并且不能大于等于底层数组最大长度
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> IndexOutOfBoundsException();
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> i;   <span style="color:#007f7f">//没有问题就把i返回
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>第三种put</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> IntBuffer put(<span style="color:#fff;font-weight:bold">int</span>[] src, <span style="color:#fff;font-weight:bold">int</span> offset, <span style="color:#fff;font-weight:bold">int</span> length) {
</span></span><span style="display:flex;"><span>    checkBounds(offset, length, src.<span style="color:#007f7f">length</span>);   <span style="color:#007f7f">//检查截取范围是否合法，给offset、调用者指定长度、数组实际长度
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> (length &gt; remaining())   <span style="color:#007f7f">//接着判断要插入的数据量在缓冲区是否容得下，装不下也不行
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> BufferOverflowException();
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> end = offset + length;   <span style="color:#007f7f">//计算出最终读取位置，下面开始for
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = offset; i &lt; end; i++)
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">put</span>(src[i]);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> checkBounds(<span style="color:#fff;font-weight:bold">int</span> off, <span style="color:#fff;font-weight:bold">int</span> len, <span style="color:#fff;font-weight:bold">int</span> size) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> ((off | len | (off + len) | (size - (off + len))) &lt; <span style="color:#ff0;font-weight:bold">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> IndexOutOfBoundsException();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">int</span> remaining() {  <span style="color:#007f7f">//计算并获取当前缓冲区的剩余空间
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">int</span> rem = limit - position;   <span style="color:#007f7f">//最大容量减去当前位置，就是剩余空间
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">return</span> rem &gt; <span style="color:#ff0;font-weight:bold">0</span> ? rem : <span style="color:#ff0;font-weight:bold">0</span>;  <span style="color:#007f7f">//没容量就返回0
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>}	
</span></span></code></pre></td></tr></table>
</div>
</div><p>第四种put，方法内会将形参缓冲区position到limit之间的数据存入当前缓冲区，get方法会将position继续向后推！！</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> IntBuffer put(IntBuffer src) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (src == <span style="color:#fff;font-weight:bold">this</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> IllegalArgumentException();
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (isReadOnly())
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> ReadOnlyBufferException();
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> n = src.<span style="color:#007f7f">remaining</span>();  <span style="color:#007f7f">//给进来的src看看容量
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> (n &gt; remaining())    <span style="color:#007f7f">//这里判断当前剩余容量是否小于src容量
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> BufferOverflowException();
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; n; i++)   <span style="color:#007f7f">//也是从position位置开始继续写入
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        put(src.<span style="color:#007f7f">get</span>());   <span style="color:#007f7f">//通过get方法一个一个读取数据出来
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">int</span> get() {
</span></span><span style="display:flex;"><span>  	<span style="color:#fff;font-weight:bold">return</span> hb[ix(nextGetIndex())];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">int</span> nextGetIndex() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> p = position;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (p &gt;= limit)
</span></span><span style="display:flex;"><span>      	<span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> BufferUnderflowException();
</span></span><span style="display:flex;"><span>    position = p + <span style="color:#ff0;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> p;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>所以这第四种put方式存在一些陷阱，通过allocate创建缓冲区并且在缓冲区内添加数据后position处在下一个可以添加的位置，limit指向最后，因此这两者中间的数据是还未被添加的默认值0，这时候使用第四种put并不能起到效果，解决方法是在put前flip一下。或者使用wrap进行创建，这种方法创建得到的缓冲区内的默认值是创建时传入的形参，但是几个标记变量的值还是和allocate一样的，当你插入过数据后到底想要什么数据就需要注意了。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> main(String[] args) {
</span></span><span style="display:flex;"><span>    IntBuffer src = IntBuffer.<span style="color:#007f7f">allocate</span>(<span style="color:#ff0;font-weight:bold">5</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; <span style="color:#ff0;font-weight:bold">5</span>; i++) src.<span style="color:#007f7f">put</span>(i);   <span style="color:#007f7f">//手动插入数据
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    IntBuffer buffer = IntBuffer.<span style="color:#007f7f">allocate</span>(<span style="color:#ff0;font-weight:bold">10</span>);
</span></span><span style="display:flex;"><span>    buffer.<span style="color:#007f7f">put</span>(src);
</span></span><span style="display:flex;"><span>    System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(Arrays.<span style="color:#007f7f">toString</span>(buffer.<span style="color:#007f7f">array</span>()));
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">final</span> Buffer flip() {
</span></span><span style="display:flex;"><span>    limit = position;  <span style="color:#007f7f">//修改limit值，当前写到哪里，下次读的最终位置就是这里
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    position = <span style="color:#ff0;font-weight:bold">0</span>;    <span style="color:#007f7f">//position归零
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    mark = -<span style="color:#ff0;font-weight:bold">1</span>;    <span style="color:#007f7f">//标记还原为-1
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="缓冲区读操作">缓冲区读操作<a hidden class="anchor" aria-hidden="true" href="#缓冲区读操作">#</a></h4>
<p>前面我们看完了写操作，现在我们接着来看看读操作。读操作有四个方法：</p>
<ul>
<li>
<p><code>public abstract int get();</code>   -   直接获取当前position位置的数据，由子类实现</p>
</li>
<li>
<p><code>public abstract int get(int index);</code> -   获取指定位置的数据，也是子类实现</p>
</li>
<li>
<p><code>public IntBuffer get(int[] dst)</code> -  将数据读取到给定的数组中</p>
</li>
<li>
<p><code>public IntBuffer get(int[] dst, int offset, int length)</code> -  同上，加了个范围</p>
</li>
</ul>
<p>第一种在上面已经看到过了</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">int</span> get() {
</span></span><span style="display:flex;"><span>  	<span style="color:#fff;font-weight:bold">return</span> hb[ix(nextGetIndex())];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">int</span> nextGetIndex() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> p = position;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (p &gt;= limit)
</span></span><span style="display:flex;"><span>      	<span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> BufferUnderflowException();
</span></span><span style="display:flex;"><span>    position = p + <span style="color:#ff0;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> p;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>第二种</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">int</span> get(<span style="color:#fff;font-weight:bold">int</span> i) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> hb[ix(checkIndex(i))];   <span style="color:#007f7f">//这里依然是使用checkIndex来检查位置是否非法
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>第三四种</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> IntBuffer get(<span style="color:#fff;font-weight:bold">int</span>[] dst, <span style="color:#fff;font-weight:bold">int</span> offset, <span style="color:#fff;font-weight:bold">int</span> length) {
</span></span><span style="display:flex;"><span>    checkBounds(offset, length, dst.<span style="color:#007f7f">length</span>);   <span style="color:#007f7f">//跟put操作一样，也是需要检查是否越界
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> (length &gt; remaining())   <span style="color:#007f7f">//如果读取的长度比可以读的长度大，那肯定是不行的
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> BufferUnderflowException();
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> end = offset + length;    <span style="color:#007f7f">//计算出最终读取位置
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = offset; i &lt; end; i++)
</span></span><span style="display:flex;"><span>        dst[i] = get();   <span style="color:#007f7f">//开始从position把数据读到数组中，注意是在数组的offset位置开始
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> IntBuffer get(<span style="color:#fff;font-weight:bold">int</span>[] dst) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> get(dst, <span style="color:#ff0;font-weight:bold">0</span>, dst.<span style="color:#007f7f">length</span>);   <span style="color:#007f7f">//不指定范围的话，那就直接用上面的
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>还能直接获取底层实现的数组</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">int</span>[] array() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (hb == <span style="color:#fff;font-weight:bold">null</span>)   <span style="color:#007f7f">//为空那说明底层不是数组实现的，肯定就没法转换了
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> UnsupportedOperationException();
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (isReadOnly)   <span style="color:#007f7f">//只读也是不让直接取出的，因为一旦取出去岂不是就能被修改了
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> ReadOnlyBufferException();
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> hb;   <span style="color:#007f7f">//直接返回hb
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>还可以使用mark、reset进行position的跳转</p>
<ul>
<li>
<p><code>public final Buffer mark()</code>  -  标记当前位置</p>
</li>
<li>
<p><code>public final Buffer reset()</code>  -  让当前的position位置跳转到mark当时标记的位置</p>
</li>
</ul>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">final</span> Buffer mark() {
</span></span><span style="display:flex;"><span>    mark = position;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">final</span> Buffer reset() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> m = mark;   <span style="color:#007f7f">//存一下当前的mark位置
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> (m &lt; <span style="color:#ff0;font-weight:bold">0</span>)    <span style="color:#007f7f">//因为mark默认是-1
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> InvalidMarkException();
</span></span><span style="display:flex;"><span>    position = m;   <span style="color:#007f7f">//直接让position变成mark位置
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="缓冲区其他操作">缓冲区其他操作<a hidden class="anchor" aria-hidden="true" href="#缓冲区其他操作">#</a></h4>
<p>前面我们大致了解了一下缓冲区的读写操作，除了常规的读写操作之外，还有哪些其他的操作：</p>
<ul>
<li>
<p><code>public abstract IntBuffer compact()</code>  -  压缩缓冲区，由具体实现类实现</p>
</li>
<li>
<p><code>public IntBuffer duplicate()</code>  -  复制缓冲区，会直接创建一个新的数据相同的缓冲区</p>
</li>
<li>
<p><code>public abstract IntBuffer slice()</code>  -   划分缓冲区，会将原本的容量大小的缓冲区划分为更小的出来进行操作</p>
</li>
<li>
<p><code>public final Buffer rewind()</code> -  重绕缓冲区，其实就是把position归零，然后mark变回-1</p>
</li>
<li>
<p><code>public final Buffer clear()</code> -  将缓冲区清空，所有的变量变回最初的状态</p>
</li>
</ul>
<p>我们先从压缩缓冲区开始看起，它会将整个缓冲区的大小和数据内容变成position位置到limit之间的数据，并移动到数组头部：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> IntBuffer compact() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> pos = position();   <span style="color:#007f7f">//获取当前位置
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">int</span> lim = limit();    <span style="color:#007f7f">//获取当前最大position位置
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">assert</span> (pos &lt;= lim);   <span style="color:#007f7f">//断言表达式，position必须小于最大位置，肯定的
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">int</span> rem = (pos &lt;= lim ? lim - pos : <span style="color:#ff0;font-weight:bold">0</span>);  <span style="color:#007f7f">//计算pos距离最大位置的长度
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    System.<span style="color:#007f7f">arraycopy</span>(hb, ix(pos), hb, ix(<span style="color:#ff0;font-weight:bold">0</span>), rem);   <span style="color:#007f7f">//直接将hb数组当前position位置的数据拷贝到头部去，然后长度改成刚刚计算出来的空间
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    position(rem);   <span style="color:#007f7f">//直接将position移动到rem位置
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    limit(capacity());   <span style="color:#007f7f">//pos最大位置修改为最大容量
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    discardMark();   <span style="color:#007f7f">//mark变回-1
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">this</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>复制缓冲区，原来的改变新创建的缓冲区中的数据也会改变，因为hb用的是一个</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> IntBuffer duplicate() {   <span style="color:#007f7f">//直接new一个新的，但是是吧hb给丢进去了，而不是拷贝一个新的
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">new</span> HeapIntBuffer(hb,
</span></span><span style="display:flex;"><span>                                    <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">markValue</span>(),
</span></span><span style="display:flex;"><span>                                    <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">position</span>(),
</span></span><span style="display:flex;"><span>                                    <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">limit</span>(),
</span></span><span style="display:flex;"><span>                                    <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">capacity</span>(),
</span></span><span style="display:flex;"><span>                                    offset);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>划分缓冲区，和复制类似都用的是旧的hb</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> IntBuffer slice() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> pos = <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">position</span>();   <span style="color:#007f7f">//获取当前position
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">int</span> lim = <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">limit</span>();     <span style="color:#007f7f">//获取position最大位置
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">int</span> rem = (pos &lt;= lim ? lim - pos : <span style="color:#ff0;font-weight:bold">0</span>);   <span style="color:#007f7f">//求得剩余空间
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">new</span> HeapIntBuffer(hb,    <span style="color:#007f7f">//返回一个新的划分出的缓冲区，但是底层的数组用的还是同一个
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>                                    -<span style="color:#ff0;font-weight:bold">1</span>,
</span></span><span style="display:flex;"><span>                                    <span style="color:#ff0;font-weight:bold">0</span>,
</span></span><span style="display:flex;"><span>                                    rem,    <span style="color:#007f7f">//新的容量变成了剩余空间的大小
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>                                    rem,
</span></span><span style="display:flex;"><span>                                    pos + offset);   <span style="color:#007f7f">//可以看到offset的地址不再是0了，而是当前的position加上原有的offset值
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="缓冲区的比较">缓冲区的比较<a hidden class="anchor" aria-hidden="true" href="#缓冲区的比较">#</a></h4>
<p>equals、compateTo都是比较两个缓冲区从当前position开始的内容是否一致。</p>
<h4 id="只读缓冲区">只读缓冲区<a hidden class="anchor" aria-hidden="true" href="#只读缓冲区">#</a></h4>
<p>所有的put方法不能用了。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> IntBuffer asReadOnlyBuffer() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">new</span> HeapIntBufferR(hb,    <span style="color:#007f7f">//注意这里并不是直接创建了HeapIntBuffer，而是HeapIntBufferR，并且直接复制的hb数组
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>                                 <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">markValue</span>(),
</span></span><span style="display:flex;"><span>                                 <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">position</span>(),
</span></span><span style="display:flex;"><span>                                 <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">limit</span>(),
</span></span><span style="display:flex;"><span>                                 <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">capacity</span>(),
</span></span><span style="display:flex;"><span>                                 offset);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// HeapIntBufferR
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">public</span> IntBuffer put(<span style="color:#fff;font-weight:bold">int</span> x) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> ReadOnlyBufferException();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> IntBuffer put(<span style="color:#fff;font-weight:bold">int</span> i, <span style="color:#fff;font-weight:bold">int</span> x) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> ReadOnlyBufferException();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> IntBuffer put(<span style="color:#fff;font-weight:bold">int</span>[] src, <span style="color:#fff;font-weight:bold">int</span> offset, <span style="color:#fff;font-weight:bold">int</span> length) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> ReadOnlyBufferException();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> IntBuffer put(IntBuffer src) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> ReadOnlyBufferException();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="通道">通道<a hidden class="anchor" aria-hidden="true" href="#通道">#</a></h3>
<p>在传统IO中，我们都是通过流进行传输，数据会源源不断从流中传出；而在NIO中，数据是放在缓冲区中进行管理，再使用通道将缓冲区中的数据传输到目的地。</p>
<h4 id="通道接口层次">通道接口层次<a hidden class="anchor" aria-hidden="true" href="#通道接口层次">#</a></h4>
<p>通道的根基接口是<code>Channel</code>，所以的派生接口和类都是从这里开始的，我们来看看它定义了哪些基本功能：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">interface</span> Channel <span style="color:#fff;font-weight:bold">extends</span> Closeable {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">//通道是否处于开启状态
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">boolean</span> isOpen();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">//因为通道开启也需要关闭，所以实现了Closeable接口
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> close() <span style="color:#fff;font-weight:bold">throws</span> IOException;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们接着来看看它的一些子接口，首先是最基本的读写操作：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">interface</span> ReadableByteChannel <span style="color:#fff;font-weight:bold">extends</span> Channel {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">//将通道中的数据读取到给定的缓冲区中
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">int</span> read(ByteBuffer dst) <span style="color:#fff;font-weight:bold">throws</span> IOException;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">interface</span> WritableByteChannel <span style="color:#fff;font-weight:bold">extends</span> Channel {
</span></span><span style="display:flex;"><span>  	<span style="color:#007f7f">//将给定缓冲区中的数据写入到通道中
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">int</span> write(ByteBuffer src) <span style="color:#fff;font-weight:bold">throws</span> IOException;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>有了读写功能后，最后整合为了一个ByteChannel接口：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">interface</span> ByteChannel <span style="color:#fff;font-weight:bold">extends</span> ReadableByteChannel, WritableByteChannel{
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><img src="https://king-super.oss-cn-nanjing.aliyuncs.com/20230227220904.png" style="zoom:50%;" />
<p>比如现在我们要实现从输入流中读取数据然后打印出来，那么之前传统IO的写法：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> main(String[] args) <span style="color:#fff;font-weight:bold">throws</span> IOException {
</span></span><span style="display:flex;"><span>  	<span style="color:#007f7f">//数组创建好，一会用来存放从流中读取到的数据
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  	<span style="color:#fff;font-weight:bold">byte</span>[] data = <span style="color:#fff;font-weight:bold">new</span> <span style="color:#fff;font-weight:bold">byte</span>[<span style="color:#ff0;font-weight:bold">10</span>];
</span></span><span style="display:flex;"><span>  	<span style="color:#007f7f">//直接使用输入流
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    InputStream in = System.<span style="color:#007f7f">in</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">while</span> (<span style="color:#fff;font-weight:bold">true</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">int</span> len;
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">while</span> ((len = in.<span style="color:#007f7f">read</span>(data)) &gt;= <span style="color:#ff0;font-weight:bold">0</span>) {  <span style="color:#007f7f">//将输入流中的数据一次性读取到数组中
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>            System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">print</span>(<span style="color:#0ff;font-weight:bold">&#34;读取到一批数据：&#34;</span>+<span style="color:#fff;font-weight:bold">new</span> String(data, <span style="color:#ff0;font-weight:bold">0</span>, len));  <span style="color:#007f7f">//读取了多少打印多少
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>而现在我们使用通道之后：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> main(String[] args) <span style="color:#fff;font-weight:bold">throws</span> IOException {
</span></span><span style="display:flex;"><span>  	<span style="color:#007f7f">//缓冲区创建好，一会就靠它来传输数据
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    ByteBuffer buffer = ByteBuffer.<span style="color:#007f7f">allocate</span>(<span style="color:#ff0;font-weight:bold">10</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">//将System.in作为输入源，一会Channel就可以从这里读取数据，然后通过缓冲区装载一次性传递数据
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    ReadableByteChannel readChannel = Channels.<span style="color:#007f7f">newChannel</span>(System.<span style="color:#007f7f">in</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">while</span> (<span style="color:#fff;font-weight:bold">true</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">//将通道中的数据写到缓冲区中，缓冲区最多一次装10个
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        readChannel.<span style="color:#007f7f">read</span>(buffer);
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">//写入操作结束之后，需要进行翻转，以便接下来的读取操作
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        buffer.<span style="color:#007f7f">flip</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">//最后转换成String打印出来康康
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;读取到一批数据：&#34;</span>+<span style="color:#fff;font-weight:bold">new</span> String(buffer.<span style="color:#007f7f">array</span>(), <span style="color:#ff0;font-weight:bold">0</span>, buffer.<span style="color:#007f7f">remaining</span>()));
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">//回到最开始的状态
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        buffer.<span style="color:#007f7f">clear</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>乍一看，好像感觉也没啥区别，不就是把数组换成缓冲区了吗，效果都是一样的，数据也是从Channel中读取得到，并且通过缓冲区进行数据装载然后得到结果，但是，Channel不像流那样是单向的，它就像它的名字一样，一个通道可以从一端走到另一端，也可以从另一端走到这一端，我们后面进行介绍。</p>
<h4 id="文件传输filechannel">文件传输FileChannel<a hidden class="anchor" aria-hidden="true" href="#文件传输filechannel">#</a></h4>
<p>前面我们介绍了通道的基本情况，这里我们就来尝试实现一下文件的读取和写入，在传统IO中，文件的写入和输出都是依靠FileOutputStream和FileInputStream来完成的：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> main(String[] args) <span style="color:#fff;font-weight:bold">throws</span> IOException {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">try</span>(FileOutputStream out = <span style="color:#fff;font-weight:bold">new</span> FileOutputStream(<span style="color:#0ff;font-weight:bold">&#34;test.txt&#34;</span>);
</span></span><span style="display:flex;"><span>        FileInputStream in = <span style="color:#fff;font-weight:bold">new</span> FileInputStream(<span style="color:#0ff;font-weight:bold">&#34;test.txt&#34;</span>)){
</span></span><span style="display:flex;"><span>        String data = <span style="color:#0ff;font-weight:bold">&#34;King&#34;</span>;
</span></span><span style="display:flex;"><span>        out.<span style="color:#007f7f">write</span>(data.<span style="color:#007f7f">getBytes</span>());   <span style="color:#007f7f">//向文件的输出流中写入数据，也就是把数据写到文件中
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        out.<span style="color:#007f7f">flush</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">byte</span>[] bytes = <span style="color:#fff;font-weight:bold">new</span> <span style="color:#fff;font-weight:bold">byte</span>[in.<span style="color:#007f7f">available</span>()];
</span></span><span style="display:flex;"><span>        in.<span style="color:#007f7f">read</span>(bytes);    <span style="color:#007f7f">//从文件的输入流中读取文件的信息
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#fff;font-weight:bold">new</span> String(bytes));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>而现在，我们只需要通过一个FileChannel就可以完成这两者的操作，获取文件通道的方式有以下几种：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> main(String[] args) <span style="color:#fff;font-weight:bold">throws</span> IOException {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">//1. 直接通过输入或输出流获取对应的通道
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    FileInputStream in = <span style="color:#fff;font-weight:bold">new</span> FileInputStream(<span style="color:#0ff;font-weight:bold">&#34;test.txt&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">//但是这里的通道只支持读取或是写入操作
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    FileChannel channel = in.<span style="color:#007f7f">getChannel</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">//创建一个容量为128的缓冲区
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    ByteBuffer buffer = ByteBuffer.<span style="color:#007f7f">allocate</span>(<span style="color:#ff0;font-weight:bold">128</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">//从通道中将数据读取到缓冲区中
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    channel.<span style="color:#007f7f">read</span>(buffer);
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">//翻转一下，接下来要读取了
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    buffer.<span style="color:#007f7f">flip</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#fff;font-weight:bold">new</span> String(buffer.<span style="color:#007f7f">array</span>(), <span style="color:#ff0;font-weight:bold">0</span>, buffer.<span style="color:#007f7f">remaining</span>()));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> main(String[] args) <span style="color:#fff;font-weight:bold">throws</span> IOException {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">//1. 直接通过输入或输出流获取对应的通道
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    FileInputStream in = <span style="color:#fff;font-weight:bold">new</span> FileInputStream(<span style="color:#0ff;font-weight:bold">&#34;test.txt&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">//但是这里的通道只支持读取或是写入操作
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    FileChannel channel = in.<span style="color:#007f7f">getChannel</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">//尝试写入一下
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    channel.<span style="color:#007f7f">write</span>(ByteBuffer.<span style="color:#007f7f">wrap</span>(<span style="color:#0ff;font-weight:bold">&#34;King&#34;</span>.<span style="color:#007f7f">getBytes</span>()));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>从FileInputStream获得的通道无法进行写操作，同样的FileOutputStream获得的通道只能进行写操作，无法进行读操作。</p>
<p>可以看到输出流生成的Channel又不支持读取，所以说本质上还是保持着输入输出流的特性，但是之前不是说Channel又可以输入又可以输出吗？这里我们来看看第二种方式：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">//RandomAccessFile能够支持文件的随机访问，并且实现了数据流
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> RandomAccessFile <span style="color:#fff;font-weight:bold">implements</span> DataOutput, DataInput, Closeable {
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以通过RandomAccessFile来创建通道：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> main(String[] args) <span style="color:#fff;font-weight:bold">throws</span> IOException {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">/*
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">      通过RandomAccessFile进行创建，注意后面的mode有几种：
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">      r        以只读的方式使用
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">      rw   读操作和写操作都可以
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">      rws  每当进行写操作，同步的刷新到磁盘，刷新内容和元数据
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">      rwd  每当进行写操作，同步的刷新到磁盘，刷新内容
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">try</span>(RandomAccessFile f = <span style="color:#fff;font-weight:bold">new</span> RandomAccessFile(<span style="color:#0ff;font-weight:bold">&#34;test.txt&#34;</span>, <span style="color:#0ff;font-weight:bold">&#34;&#34;</span>)){
</span></span><span style="display:flex;"><span>				
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在我们来测试一下它的读写操作：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> main(String[] args) <span style="color:#fff;font-weight:bold">throws</span> IOException {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">/*
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">      通过RandomAccessFile进行创建，注意后面的mode有几种：
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">      r        以只读的方式使用
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">      rw   读操作和写操作都可以
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">      rws  每当进行写操作，同步的刷新到磁盘，刷新内容和元数据
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">      rwd  每当进行写操作，同步的刷新到磁盘，刷新内容
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">try</span>(RandomAccessFile f = <span style="color:#fff;font-weight:bold">new</span> RandomAccessFile(<span style="color:#0ff;font-weight:bold">&#34;test.txt&#34;</span>, <span style="color:#0ff;font-weight:bold">&#34;rw&#34;</span>);  <span style="color:#007f7f">//这里设定为支持读写，这样创建的通道才能具有这些功能
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        FileChannel channel = f.<span style="color:#007f7f">getChannel</span>()){   <span style="color:#007f7f">//通过RandomAccessFile创建一个通道
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        channel.<span style="color:#007f7f">write</span>(ByteBuffer.<span style="color:#007f7f">wrap</span>(<span style="color:#0ff;font-weight:bold">&#34;King&#34;</span>.<span style="color:#007f7f">getBytes</span>()));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;写操作完成之后文件访问位置：&#34;</span>+channel.<span style="color:#007f7f">position</span>());  <span style="color:#007f7f">//注意读取也是从现在的位置开始
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        channel.<span style="color:#007f7f">position</span>(<span style="color:#ff0;font-weight:bold">0</span>);  <span style="color:#007f7f">//需要将位置变回到最前面，这样下面才能从文件的最开始进行读取
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>
</span></span><span style="display:flex;"><span>        ByteBuffer buffer = ByteBuffer.<span style="color:#007f7f">allocate</span>(<span style="color:#ff0;font-weight:bold">128</span>);
</span></span><span style="display:flex;"><span>        channel.<span style="color:#007f7f">read</span>(buffer);
</span></span><span style="display:flex;"><span>        buffer.<span style="color:#007f7f">flip</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#fff;font-weight:bold">new</span> String(buffer.<span style="color:#007f7f">array</span>(), <span style="color:#ff0;font-weight:bold">0</span>, buffer.<span style="color:#007f7f">remaining</span>()));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，一个FileChannel既可以完成文件读取，也可以完成文件的写入。</p>
<p>除了基本的读写操作，我们也可以直接对文件进行截断：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> main(String[] args) <span style="color:#fff;font-weight:bold">throws</span> IOException {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">try</span>(RandomAccessFile f = <span style="color:#fff;font-weight:bold">new</span> RandomAccessFile(<span style="color:#0ff;font-weight:bold">&#34;test.txt&#34;</span>, <span style="color:#0ff;font-weight:bold">&#34;rw&#34;</span>);
</span></span><span style="display:flex;"><span>        FileChannel channel = f.<span style="color:#007f7f">getChannel</span>()){
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">//截断文件，只留前20个字节
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        channel.<span style="color:#007f7f">truncate</span>(<span style="color:#ff0;font-weight:bold">20</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ByteBuffer buffer = ByteBuffer.<span style="color:#007f7f">allocate</span>(<span style="color:#ff0;font-weight:bold">128</span>);
</span></span><span style="display:flex;"><span>        channel.<span style="color:#007f7f">read</span>(buffer);
</span></span><span style="display:flex;"><span>        buffer.<span style="color:#007f7f">flip</span>();
</span></span><span style="display:flex;"><span>        System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#fff;font-weight:bold">new</span> String(buffer.<span style="color:#007f7f">array</span>(), <span style="color:#ff0;font-weight:bold">0</span>, buffer.<span style="color:#007f7f">remaining</span>()));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到文件的内容直接被截断了，文件内容就只剩一半了。</p>
<p>当然，如果我们要进行文件的拷贝，也是很方便的，只需要使用通道就可以，比如我们现在需要将一个通道的数据写入到另一个通道，就可以直接使用transferTo方法：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> main(String[] args) <span style="color:#fff;font-weight:bold">throws</span> IOException {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">try</span>(FileOutputStream out = <span style="color:#fff;font-weight:bold">new</span> FileOutputStream(<span style="color:#0ff;font-weight:bold">&#34;test2.txt&#34;</span>);
</span></span><span style="display:flex;"><span>        FileInputStream in = <span style="color:#fff;font-weight:bold">new</span> FileInputStream(<span style="color:#0ff;font-weight:bold">&#34;test.txt&#34;</span>)){
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        FileChannel inChannel = in.<span style="color:#007f7f">getChannel</span>();   <span style="color:#007f7f">//获取到test文件的通道
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        inChannel.<span style="color:#007f7f">transferTo</span>(<span style="color:#ff0;font-weight:bold">0</span>, inChannel.<span style="color:#007f7f">size</span>(), out.<span style="color:#007f7f">getChannel</span>());   <span style="color:#007f7f">//直接将test文件通道中的数据转到test2文件的通道中
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到执行后，文件的内容全部被复制到另一个文件了。</p>
<p>当然，反向操作也是可以的：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> main(String[] args) <span style="color:#fff;font-weight:bold">throws</span> IOException {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">try</span>(FileOutputStream out = <span style="color:#fff;font-weight:bold">new</span> FileOutputStream(<span style="color:#0ff;font-weight:bold">&#34;test2.txt&#34;</span>);
</span></span><span style="display:flex;"><span>        FileInputStream in = <span style="color:#fff;font-weight:bold">new</span> FileInputStream(<span style="color:#0ff;font-weight:bold">&#34;test.txt&#34;</span>)){
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        FileChannel inChannel = in.<span style="color:#007f7f">getChannel</span>();   <span style="color:#007f7f">//获取到test文件的通道
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        out.<span style="color:#007f7f">getChannel</span>().<span style="color:#007f7f">transferFrom</span>(inChannel, <span style="color:#ff0;font-weight:bold">0</span>, inChannel.<span style="color:#007f7f">size</span>());   <span style="color:#007f7f">//直接将从test文件通道中传来的数据转给test2文件的通道
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>当我们要编辑某个文件时，通过使用MappedByteBuffer类，可以将其映射到内存中进行编辑，编辑的内容会同步更新到文件中：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">//注意一定要是可写的，不然无法进行修改操作
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">try</span>(RandomAccessFile f = <span style="color:#fff;font-weight:bold">new</span> RandomAccessFile(<span style="color:#0ff;font-weight:bold">&#34;test.txt&#34;</span>, <span style="color:#0ff;font-weight:bold">&#34;rw&#34;</span>);
</span></span><span style="display:flex;"><span>    FileChannel channel = f.<span style="color:#007f7f">getChannel</span>()){
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">//通过map方法映射文件的某一段内容，创建MappedByteBuffer对象
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#007f7f">//比如这里就是从第四个字节开始，映射10字节内容到内存中
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  	<span style="color:#007f7f">//注意这里需要使用MapMode.READ_WRITE模式，其他模式无法保存数据到文件
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    MappedByteBuffer buffer = channel.<span style="color:#007f7f">map</span>(FileChannel.<span style="color:#007f7f">MapMode</span>.<span style="color:#007f7f">READ_WRITE</span>, <span style="color:#ff0;font-weight:bold">4</span>, <span style="color:#ff0;font-weight:bold">10</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">//我们可以直接对在内存中的数据进行编辑，也就是编辑Buffer中的内容
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  	<span style="color:#007f7f">//注意这里写入也是从pos位置开始的，默认是从0开始，相对于文件就是从第四个字节开始写
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  	<span style="color:#007f7f">//注意我们只映射了10个字节，也就是写的内容不能超出10字节了
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    buffer.<span style="color:#007f7f">put</span>(<span style="color:#0ff;font-weight:bold">&#34;yyds&#34;</span>.<span style="color:#007f7f">getBytes</span>());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">//编辑完成后，通过force方法将数据写回文件的映射区域
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    buffer.<span style="color:#007f7f">force</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，文件的某一个区域已经被我们修改了，并且这里实际上使用的就是DirectByteBuffer直接缓冲区，效率还是很高的。</p>
<h4 id="文件锁filelock">文件锁FileLock<a hidden class="anchor" aria-hidden="true" href="#文件锁filelock">#</a></h4>
<p>我们可以创建一个跨进程文件锁来防止多个进程之间的文件争抢操作（注意这里是进程，不是线程）FileLock是文件锁，它能保证同一时间只有一个进程（程序）能够修改它，或者都只可以读，这样就解决了多进程间的同步文件，保证了安全性。但是需要注意的是，它进程级别的，不是线程级别的，他可以解决多个进程并发访问同一个文件的问题，但是它不适用于控制同一个进程中多个线程对一个文件的访问。</p>
<p>那么我们来看看如何使用文件锁：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> main(String[] args) <span style="color:#fff;font-weight:bold">throws</span> IOException, InterruptedException {
</span></span><span style="display:flex;"><span>  	<span style="color:#007f7f">//创建RandomAccessFile对象，并拿到Channel
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    RandomAccessFile f = <span style="color:#fff;font-weight:bold">new</span> RandomAccessFile(<span style="color:#0ff;font-weight:bold">&#34;test.txt&#34;</span>, <span style="color:#0ff;font-weight:bold">&#34;rw&#34;</span>);
</span></span><span style="display:flex;"><span>    FileChannel channel = f.<span style="color:#007f7f">getChannel</span>();
</span></span><span style="display:flex;"><span>    System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#fff;font-weight:bold">new</span> Date() + <span style="color:#0ff;font-weight:bold">&#34; 正在尝试获取文件锁...&#34;</span>);
</span></span><span style="display:flex;"><span>  	<span style="color:#007f7f">//接着我们直接使用lock方法进行加锁操作（如果其他进程已经加锁，那么会一直阻塞在这里）
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  	<span style="color:#007f7f">//加锁操作支持对文件的某一段进行加锁，比如这里就是从0开始后的6个字节加锁，false代表这是一把独占锁
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  	<span style="color:#007f7f">//范围锁甚至可以提前加到一个还未写入的位置上
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    FileLock lock = channel.<span style="color:#007f7f">lock</span>(<span style="color:#ff0;font-weight:bold">0</span>, <span style="color:#ff0;font-weight:bold">6</span>, <span style="color:#fff;font-weight:bold">false</span>);
</span></span><span style="display:flex;"><span>    System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#fff;font-weight:bold">new</span> Date() + <span style="color:#0ff;font-weight:bold">&#34; 已获取到文件锁！&#34;</span>);
</span></span><span style="display:flex;"><span>    Thread.<span style="color:#007f7f">sleep</span>(<span style="color:#ff0;font-weight:bold">5000</span>);   <span style="color:#007f7f">//假设要处理5秒钟
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#fff;font-weight:bold">new</span> Date() + <span style="color:#0ff;font-weight:bold">&#34; 操作完毕，释放文件锁！&#34;</span>);
</span></span><span style="display:flex;"><span>  	
</span></span><span style="display:flex;"><span>  	<span style="color:#007f7f">//操作完成之后使用release方法进行锁释放
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    lock.<span style="color:#007f7f">release</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>有关共享锁和独占锁：</p>
<ul>
<li>
<p>进程对文件加独占锁后，当前进程对文件可读可写，独占此文件，其它进程是不能读该文件进行读写操作的。</p>
</li>
<li>
<p>进程对文件加共享锁后，进程可以对文件进行读操作，但是无法进行写操作，共享锁可以被多个进程添加，但是只要存在共享锁，就不能添加独占锁。</p>
</li>
</ul>
<p>当然，除了直接使用<code>lock()</code>方法进行加锁之外，我们也可以使用<code>tryLock()</code>方法以非阻塞方式获取文件锁，但是如果获取锁失败会得到null。</p>
<h3 id="选择器">选择器<a hidden class="anchor" aria-hidden="true" href="#选择器">#</a></h3>
<p><strong>Selector</strong> 一般称 为<strong>选择器</strong> ，当然你也可以翻译为 <strong>多路复用器</strong> 。它是Java NIO核心组件中的一个，用于检查一个或多个NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个channels,也就是可以管理多个网络链接。</p>
<p><strong>使用Selector的好处在于：</strong> 使用更少的线程来就可以来处理通道了， 相比使用多个线程，避免了线程上下文切换带来的开销。</p>
<h4 id="selector的使用方法介绍">Selector的使用方法介绍<a hidden class="anchor" aria-hidden="true" href="#selector的使用方法介绍">#</a></h4>
<h5 id="1-selector的创建">1. Selector的创建<a hidden class="anchor" aria-hidden="true" href="#1-selector的创建">#</a></h5>
<p>通过调用Selector.open()方法创建一个Selector对象，如下：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Selector selector = Selector.<span style="color:#007f7f">open</span>();
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里需要说明一下</p>
<h5 id="2-注册channel到selector">2. 注册Channel到Selector<a hidden class="anchor" aria-hidden="true" href="#2-注册channel到selector">#</a></h5>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>channel.<span style="color:#007f7f">configureBlocking</span>(<span style="color:#fff;font-weight:bold">false</span>);
</span></span><span style="display:flex;"><span>SelectionKey key = channel.<span style="color:#007f7f">register</span>(selector, Selectionkey.<span style="color:#007f7f">OP_READ</span>);
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>Channel必须是非阻塞的</strong>。
所以FileChannel不适用Selector，因为FileChannel不能切换为非阻塞模式，更准确的来说是因为FileChannel没有继承SelectableChannel。Socket channel可以正常使用。</p>
<p><strong>SelectableChannel抽象类</strong> 有一个 <strong>configureBlocking（）</strong> 方法用于使通道处于阻塞模式或非阻塞模式。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">abstract</span> SelectableChannel configureBlocking(<span style="color:#fff;font-weight:bold">boolean</span> block)  
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>注意：</strong></p>
<p><strong>SelectableChannel抽象类</strong>的<strong>configureBlocking（）</strong> 方法是由 <strong>AbstractSelectableChannel抽象类</strong>实现的，<strong>SocketChannel、ServerSocketChannel、DatagramChannel</strong>都是直接继承了 <strong>AbstractSelectableChannel抽象类</strong> 。
大家有兴趣可以看看NIO的源码，各种抽象类和抽象类上层的抽象类。我本人暂时不准备研究NIO源码，因为还有很多事情要做，需要研究的同学可以自行看看。</p>
<p><strong>register()</strong> 方法的第二个参数。这是一个“ <strong>interest集合</strong> ”，意思是在<strong>通过Selector监听Channel时对什么事件感兴趣</strong>。可以监听四种不同类型的事件：</p>
<ul>
<li><strong>Connect</strong></li>
<li><strong>Accept</strong></li>
<li><strong>Read</strong></li>
<li><strong>Write</strong></li>
</ul>
<p>通道触发了一个事件意思是该事件已经就绪。比如某个Channel成功连接到另一个服务器称为“ <strong>连接就绪</strong> ”。一个Server Socket Channel准备好接收新进入的连接称为“ <strong>接收就绪</strong> ”。一个有数据可读的通道可以说是“ <strong>读就绪</strong> ”。等待写数据的通道可以说是“ <strong>写就绪</strong> ”。</p>
<p>这四种事件用SelectionKey的四个常量来表示：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>SelectionKey.<span style="color:#007f7f">OP_CONNECT</span>
</span></span><span style="display:flex;"><span>SelectionKey.<span style="color:#007f7f">OP_ACCEPT</span>
</span></span><span style="display:flex;"><span>SelectionKey.<span style="color:#007f7f">OP_READ</span>
</span></span><span style="display:flex;"><span>SelectionKey.<span style="color:#007f7f">OP_WRITE</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果你对不止一种事件感兴趣，使用或运算符即可，如下：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> interestSet = SelectionKey.<span style="color:#007f7f">OP_READ</span> | SelectionKey.<span style="color:#007f7f">OP_WRITE</span>;
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="3-selectionkey介绍">3. SelectionKey介绍<a hidden class="anchor" aria-hidden="true" href="#3-selectionkey介绍">#</a></h5>
<p>一个SelectionKey键表示了一个特定的通道对象和一个特定的选择器对象之间的注册关系。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>key.<span style="color:#007f7f">attachment</span>(); <span style="color:#007f7f">//返回SelectionKey的attachment，attachment可以在注册channel的时候指定。
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>key.<span style="color:#007f7f">channel</span>(); <span style="color:#007f7f">// 返回该SelectionKey对应的channel。
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>key.<span style="color:#007f7f">selector</span>(); <span style="color:#007f7f">// 返回该SelectionKey对应的Selector。
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>key.<span style="color:#007f7f">interestOps</span>(); <span style="color:#007f7f">//返回代表需要Selector监控的IO操作的bit mask
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>key.<span style="color:#007f7f">readyOps</span>(); <span style="color:#007f7f">// 返回一个bit mask，代表在相应channel上可以进行的IO操作。
</span></span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>key.interestOps():</strong></p>
</blockquote>
<p>我们可以通过以下方法来判断Selector是否对Channel的某种事件感兴趣</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> interestSet = selectionKey.<span style="color:#007f7f">interestOps</span>(); 
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">boolean</span> isInterestedInAccept = (interestSet &amp; SelectionKey.<span style="color:#007f7f">OP_ACCEPT</span>) == SelectionKey.<span style="color:#007f7f">OP_ACCEPT</span><span style="color:#f00">；</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">boolean</span> isInterestedInConnect = interestSet &amp; SelectionKey.<span style="color:#007f7f">OP_CONNECT</span>;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">boolean</span> isInterestedInRead = interestSet &amp; SelectionKey.<span style="color:#007f7f">OP_READ</span>;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">boolean</span> isInterestedInWrite = interestSet &amp; SelectionKey.<span style="color:#007f7f">OP_WRITE</span>;
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>key.readyOps()</strong></p>
</blockquote>
<p>ready 集合是通道已经准备就绪的操作的集合。JAVA中定义以下几个方法用来检查这些操作是否就绪.</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">//创建ready集合的方法
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">int</span> readySet = selectionKey.<span style="color:#007f7f">readyOps</span>();
</span></span><span style="display:flex;"><span><span style="color:#007f7f">//检查这些操作是否就绪的方法
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>key.<span style="color:#007f7f">isAcceptable</span>();<span style="color:#007f7f">//是否可读，是返回 true
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">boolean</span> isWritable()<span style="color:#f00">：</span><span style="color:#007f7f">//是否可写，是返回 true
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">boolean</span> isConnectable()<span style="color:#f00">：</span><span style="color:#007f7f">//是否可连接，是返回 true
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">boolean</span> isAcceptable()<span style="color:#f00">：</span><span style="color:#007f7f">//是否可接收，是返回 true
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><strong>从SelectionKey访问Channel和Selector很简单。如下：</strong></p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Channel channel = key.<span style="color:#007f7f">channel</span>();
</span></span><span style="display:flex;"><span>Selector selector = key.<span style="color:#007f7f">selector</span>();
</span></span><span style="display:flex;"><span>key.<span style="color:#007f7f">attachment</span>();
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>key.<span style="color:#007f7f">attach</span>(theObject);
</span></span><span style="display:flex;"><span>Object attachedObj = key.<span style="color:#007f7f">attachment</span>();
</span></span></code></pre></td></tr></table>
</div>
</div><p>还可以在用register()方法向Selector注册Channel的时候附加对象。如：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>SelectionKey key = channel.<span style="color:#007f7f">register</span>(selector, SelectionKey.<span style="color:#007f7f">OP_READ</span>, theObject);
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="4-从selector中选择channelselecting-channels-via-a-selector">4. 从Selector中选择channel(Selecting Channels via a Selector)<a hidden class="anchor" aria-hidden="true" href="#4-从selector中选择channelselecting-channels-via-a-selector">#</a></h5>
<p>选择器维护注册过的通道的集合，并且这种注册关系都被封装在SelectionKey当中.</p>
<blockquote>
<p><strong>Selector维护的三种类型SelectionKey集合：</strong></p>
</blockquote>
<ul>
<li>
<p><strong>已注册的键的集合(Registered key set)</strong></p>
<p>所有与选择器关联的通道所生成的键的集合称为已经注册的键的集合。并不是所有注册过的键都仍然有效。这个集合通过 <strong>keys()</strong> 方法返回，并且可能是空的。这个已注册的键的集合不是可以直接修改的；试图这么做的话将引发java.lang.UnsupportedOperationException。</p>
</li>
<li>
<p><strong>已选择的键的集合(Selected key set)</strong></p>
<p>所有与选择器关联的通道所生成的键的集合称为已经注册的键的集合。并不是所有注册过的键都仍然有效。这个集合通过 <strong>keys()</strong> 方法返回，并且可能是空的。这个已注册的键的集合不是可以直接修改的；试图这么做的话将引发java.lang.UnsupportedOperationException。</p>
</li>
<li>
<p><strong>已取消的键的集合(Cancelled key set)</strong></p>
<p>已注册的键的集合的子集，这个集合包含了 <strong>cancel()</strong> 方法被调用过的键(这个键已经被无效化)，但它们还没有被注销。这个集合是选择器对象的私有成员，因而无法直接访问。</p>
<p><strong>注意：</strong>
当键被取消（ 可以通过<strong>isValid( )</strong> 方法来判断）时，它将被放在相关的选择器的已取消的键的集合里。注册不会立即被取消，但键会立即失效。当再次调用 <strong>select( )</strong> 方法时（或者一个正在进行的select()调用结束时），已取消的键的集合中的被取消的键将被清理掉，并且相应的注销也将完成。通道会被注销，而新的SelectionKey将被返回。当通道关闭时，所有相关的键会自动取消（记住，一个通道可以被注册到多个选择器上）。当选择器关闭时，所有被注册到该选择器的通道都将被注销，并且相关的键将立即被无效化（取消）。一旦键被无效化，调用它的与选择相关的方法就将抛出CancelledKeyException。</p>
</li>
</ul>
<blockquote>
<p><strong>select()方法介绍：</strong></p>
</blockquote>
<p>在刚初始化的Selector对象中，这三个集合都是空的。 <strong>通过Selector的select（）方法可以选择已经准备就绪的通道</strong> （这些通道包含你感兴趣的的事件）。比如你对读就绪的通道感兴趣，那么select（）方法就会返回读事件已经就绪的那些通道。下面是Selector几个重载的select()方法：</p>
<ul>
<li>int select()：阻塞到至少有一个通道在你注册的事件上就绪了。</li>
<li>int select(long timeout)：和select()一样，但最长阻塞时间为timeout毫秒。</li>
<li>int selectNow()：非阻塞，只要有通道就绪就立刻返回。</li>
</ul>
<p><strong>select()方法返回的int值表示有多少通道已经就绪,是自上次调用select()方法后有多少通道变成就绪状态。之前在select（）调用时进入就绪的通道不会在本次调用中被记入，而在前一次select（）调用进入就绪但现在已经不在处于就绪的通道也不会被记入</strong>。例如：首次调用select()方法，如果有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道，但在每次select()方法调用之间，只有一个通道就绪了。</p>
<p><strong>一旦调用select()方法，并且返回值不为0时，则 可以通过调用Selector的selectedKeys()方法来访问已选择键集合</strong> 。如下：
Set selectedKeys=selector.selectedKeys();
进而可以放到和某SelectionKey关联的Selector和Channel。如下所示：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Set selectedKeys = selector.<span style="color:#007f7f">selectedKeys</span>();
</span></span><span style="display:flex;"><span>Iterator keyIterator = selectedKeys.<span style="color:#007f7f">iterator</span>();
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">while</span>(keyIterator.<span style="color:#007f7f">hasNext</span>()) {
</span></span><span style="display:flex;"><span>    SelectionKey key = keyIterator.<span style="color:#007f7f">next</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span>(key.<span style="color:#007f7f">isAcceptable</span>()) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// a connection was accepted by a ServerSocketChannel.
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    } <span style="color:#fff;font-weight:bold">else</span> <span style="color:#fff;font-weight:bold">if</span> (key.<span style="color:#007f7f">isConnectable</span>()) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// a connection was established with a remote server.
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    } <span style="color:#fff;font-weight:bold">else</span> <span style="color:#fff;font-weight:bold">if</span> (key.<span style="color:#007f7f">isReadable</span>()) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// a channel is ready for reading
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    } <span style="color:#fff;font-weight:bold">else</span> <span style="color:#fff;font-weight:bold">if</span> (key.<span style="color:#007f7f">isWritable</span>()) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// a channel is ready for writing
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    }
</span></span><span style="display:flex;"><span>    keyIterator.<span style="color:#007f7f">remove</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="5-停止选择的方法">5. 停止选择的方法<a hidden class="anchor" aria-hidden="true" href="#5-停止选择的方法">#</a></h5>
<p>选择器执行选择的过程，系统底层会依次询问每个通道是否已经就绪，这个过程可能会造成调用线程进入阻塞状态,那么我们有以下三种方式可以唤醒在select（）方法中阻塞的线程。</p>
<ul>
<li><strong>wakeup()方法</strong> ：通过调用Selector对象的wakeup（）方法让处在阻塞状态的select()方法立刻返回
该方法使得选择器上的第一个还没有返回的选择操作立即返回。如果当前没有进行中的选择操作，那么下一次对select()方法的一次调用将立即返回。</li>
<li><strong>close()方法</strong> ：通过close（）方法关闭Selector，
该方法使得任何一个在选择操作中阻塞的线程都被唤醒（类似wakeup（）），同时使得注册到该Selector的所有Channel被注销，所有的键将被取消，但是Channel本身并不会关闭。</li>
</ul>
<h1 id="35-序列化">35. 序列化<a hidden class="anchor" aria-hidden="true" href="#35-序列化">#</a></h1>
<p>序列化：指的就是通过某种技术将数据结构或者对象转化为二进制字节流的过程（通常是二进制的形式，也可以采用类似XML或者JSON的方式，但是这样虽然提高了可读性但是降低的性能）</p>
<p>反序列化：指的将二进制字节流转化为数据结构或者对象的过程。（序列化相对的步骤）</p>
<p>通常序列化与反序列化的作用是</p>
<ul>
<li>将当前程序中的数据实现持久化的存储</li>
<li>将对象通过网络进行传输，在远程的设备上需要本地设备的对象</li>
<li>存储到数据库中也需要序列化</li>
</ul>
<p>（一般就是需要将对象取出来使用的场景，此时就需要通过序列化的方式来实现这些功能）</p>
<p>JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。</p>
<h2 id="jdk自带的序列化实现">JDK自带的序列化实现<a hidden class="anchor" aria-hidden="true" href="#jdk自带的序列化实现">#</a></h2>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>@Getter
</span></span><span style="display:flex;"><span>@Setter
</span></span><span style="display:flex;"><span>@NoArgsConstructor
</span></span><span style="display:flex;"><span>@AllArgsConstructor
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> People <span style="color:#fff;font-weight:bold">implements</span> Serializable {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">long</span> serialVersionUID = <span style="color:#ff0;font-weight:bold">1905122041950251207L</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">int</span> anInt;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">private</span> String string;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用Java自带的序列化只需要实现<code>Serializable</code>接口最好是自己创建<code>serialVersionUID</code>，<code>UID</code>的作用是在反序列化时检测版本是否一致，若不一致则无法进行反序列化。</p>
<p>对于不想进行序列化的变量，可以使用 <code>transient</code> 关键字修饰，关键字只可用于修饰变量，不可以用于修饰方法。</p>
<h2 id="kryo">Kryo<a hidden class="anchor" aria-hidden="true" href="#kryo">#</a></h2>
<p>Kryo 是一个快速序列化/反序列化工具，其使用了字节码生成机制（底层依赖了 ASM 库），因此具有比较好的运行速度。</p>
<p>Kryo 序列化出来的结果，是其自定义的、独有的一种格式，不再是 JSON 或者其他现有的通用格式；而且，其序列化出来的结果是二进制的（即 byte[]；而 JSON 本质上是字符串 String）；二进制数据显然体积更小，序列化、反序列化时的速度也更快。</p>
<p>Kryo 一般只用来进行序列化（然后作为缓存，或者落地到存储设备之中）、反序列化，而不用于在多个系统、甚至多种语言间进行数据交换 —— 目前 kryo 也只有 java 实现。</p>
<p>像 Redis 这样的存储工具，是可以安全地存储二进制数据的，所以可以直接把 Kryo 序列化出来的数据存进去。</p>
<p>当然，如果你希望用 String 的形式存储、传输 Kryo 序列化之后的数据，也可以通过 Base64 等编码方式来实现。但这会降低程序的运行速度，一定程度上违背了使用 <code>kryo</code> 的初衷。</p>
<ul>
<li>相较于Java提供的序列化工具，<code>Kryo</code>可以序列化任意类型的对象（不包括匿名内部类，对非静态内部类的支持一般），这使得许多已经开发好的工具包中的类但是没有实现@Serializable接口的对象可以实现序列化，通常序列化所需的时间都纳秒级别的。</li>
<li>线程不安全，<code>Kryo</code>没有在序列化时对对象进行上锁，所以理论上存在数据出错的可能性大，可以通过<code>ThreadLocal</code>保证线程安全性</li>
<li>注册，在<code>Kryo</code>中可以进行注册，注册后每种类型会获得一个编号，但是在现实环境中（重启虚拟机后注册顺序不同、多设备部署）同一个类型具有两种不同的编号，会使得反序列化失败，一般情况下不使用注册的方式实现序列化，通过如下设置关闭注册: <code>kryo.setRegistrationRequired(false);</code></li>
<li>循环引用问题，默认情况下是支持循环引用问题的，例如A引用了B，在B中同样引用了A。有特殊需求可以关闭循环引用: <code>kryo.setReferences(false);</code></li>
</ul>
<p>KryoUtil 对 Kryo 进行了一定的封装，能够满足分布式系统的一般需求，而无需进行任何额外的配置。</p>
<p>除了用于获得当前线程的 kryo 实例的 getInstance() 方法之外，KryoUtil 内共有 8 个 public 方法，分为两组：</p>
<p><T> byte[] writeToByteArray(T obj);</p>
<p><T> String writeToString(T obj);</p>
<p><T> T readFromByteArray(byte[] byteArray);</p>
<p><T> T readFromString(String str);</p>
<p>及：</p>
<p><T> byte[] writeObjectToByteArray(T obj)</p>
<p><T> String writeObjectToString(T obj)</p>
<p><T> T readObjectFromByteArray(byte[] byteArray, Class<T> clazz)</p>
<p><T> T readObjectFromString(String str, Class<T> clazz)</p>
<p>其中第一组序列化的结果里包含了类型信息，第二组不包含 —— 因此，可以看到，在使用第二组方法进行反序列化的时候，需要提供原始对象的 Class 。但我们建议使用第一组方法，原因见第 3.2 节。</p>
<p>另外，必须注意，第一组方法和第二组方法不能混用，第一组序列化出来的结果，只能由第一组的方法进行反序列化；第二组亦然。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">28
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">29
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">30
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">31
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">32
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">33
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">34
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">35
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">36
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">37
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">38
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">39
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">40
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">41
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">42
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">43
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">44
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">45
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">46
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">47
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">48
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">49
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">50
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">51
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">52
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">53
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">54
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">55
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">56
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">57
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">58
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">59
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">60
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">61
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">62
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">63
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">64
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">65
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">66
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">67
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">68
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">69
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">70
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">71
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">72
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">73
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">74
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">75
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">76
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">77
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">78
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">79
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">80
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">81
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">82
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">83
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">84
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">85
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">86
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">87
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">88
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">89
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">90
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">91
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> KryoUtil {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">final</span> String DEFAULT_ENCODING = <span style="color:#0ff;font-weight:bold">&#34;UTF-8&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">final</span> ThreadLocal&lt;Kryo&gt; kryoLocal = <span style="color:#fff;font-weight:bold">new</span> ThreadLocal&lt;Kryo&gt;() {
</span></span><span style="display:flex;"><span>        @Override
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">protected</span> Kryo initialValue() {
</span></span><span style="display:flex;"><span>            Kryo kryo = <span style="color:#fff;font-weight:bold">new</span> Kryo();
</span></span><span style="display:flex;"><span>            kryo.<span style="color:#007f7f">setReferences</span>(<span style="color:#fff;font-weight:bold">true</span>);
</span></span><span style="display:flex;"><span>            kryo.<span style="color:#007f7f">setRegistrationRequired</span>(<span style="color:#fff;font-weight:bold">false</span>); 
</span></span><span style="display:flex;"><span>            ((Kryo.<span style="color:#007f7f">DefaultInstantiatorStrategy</span>) kryo.<span style="color:#007f7f">getInstantiatorStrategy</span>()).<span style="color:#007f7f">setFallbackInstantiatorStrategy</span>(<span style="color:#fff;font-weight:bold">new</span> StdInstantiatorStrategy());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">return</span> kryo;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> Kryo getInstance() {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> kryoLocal.<span style="color:#007f7f">get</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> &lt;T&gt; <span style="color:#fff;font-weight:bold">byte</span>[] writeToByteArray(T obj) {
</span></span><span style="display:flex;"><span>        ByteArrayOutputStream byteArrayOutputStream = <span style="color:#fff;font-weight:bold">new</span> ByteArrayOutputStream();
</span></span><span style="display:flex;"><span>        Output output = <span style="color:#fff;font-weight:bold">new</span> Output(byteArrayOutputStream);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Kryo kryo = getInstance();
</span></span><span style="display:flex;"><span>        kryo.<span style="color:#007f7f">writeClassAndObject</span>(output, obj);
</span></span><span style="display:flex;"><span>        output.<span style="color:#007f7f">flush</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> byteArrayOutputStream.<span style="color:#007f7f">toByteArray</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> &lt;T&gt; String writeToString(T obj) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">new</span> String(Base64.<span style="color:#007f7f">encodeBase64</span>(writeToByteArray(obj)), DEFAULT_ENCODING);
</span></span><span style="display:flex;"><span>        } <span style="color:#fff;font-weight:bold">catch</span> (UnsupportedEncodingException e) {
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> IllegalStateException(e);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>    @SuppressWarnings(<span style="color:#0ff;font-weight:bold">&#34;unchecked&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> &lt;T&gt; T readFromByteArray(<span style="color:#fff;font-weight:bold">byte</span>[] byteArray) {
</span></span><span style="display:flex;"><span>        ByteArrayInputStream byteArrayInputStream = <span style="color:#fff;font-weight:bold">new</span> ByteArrayInputStream(byteArray);
</span></span><span style="display:flex;"><span>        Input input = <span style="color:#fff;font-weight:bold">new</span> Input(byteArrayInputStream);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Kryo kryo = getInstance();
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> (T) kryo.<span style="color:#007f7f">readClassAndObject</span>(input);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> &lt;T&gt; T readFromString(String str) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">return</span> readFromByteArray(Base64.<span style="color:#007f7f">decodeBase64</span>(str.<span style="color:#007f7f">getBytes</span>(DEFAULT_ENCODING)));
</span></span><span style="display:flex;"><span>        } <span style="color:#fff;font-weight:bold">catch</span> (UnsupportedEncodingException e) {
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> IllegalStateException(e);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> &lt;T&gt; <span style="color:#fff;font-weight:bold">byte</span>[] writeObjectToByteArray(T obj) {
</span></span><span style="display:flex;"><span>        ByteArrayOutputStream byteArrayOutputStream = <span style="color:#fff;font-weight:bold">new</span> ByteArrayOutputStream();
</span></span><span style="display:flex;"><span>        Output output = <span style="color:#fff;font-weight:bold">new</span> Output(byteArrayOutputStream);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Kryo kryo = getInstance();
</span></span><span style="display:flex;"><span>        kryo.<span style="color:#007f7f">writeObject</span>(output, obj);
</span></span><span style="display:flex;"><span>        output.<span style="color:#007f7f">flush</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> byteArrayOutputStream.<span style="color:#007f7f">toByteArray</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> &lt;T&gt; String writeObjectToString(T obj) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">new</span> String(Base64.<span style="color:#007f7f">encodeBase64</span>(writeObjectToByteArray(obj)), DEFAULT_ENCODING);
</span></span><span style="display:flex;"><span>        } <span style="color:#fff;font-weight:bold">catch</span> (UnsupportedEncodingException e) {
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> IllegalStateException(e);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    @SuppressWarnings(<span style="color:#0ff;font-weight:bold">&#34;unchecked&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> &lt;T&gt; T readObjectFromByteArray(<span style="color:#fff;font-weight:bold">byte</span>[] byteArray, Class&lt;T&gt; clazz) {
</span></span><span style="display:flex;"><span>        ByteArrayInputStream byteArrayInputStream = <span style="color:#fff;font-weight:bold">new</span> ByteArrayInputStream(byteArray);
</span></span><span style="display:flex;"><span>        Input input = <span style="color:#fff;font-weight:bold">new</span> Input(byteArrayInputStream);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Kryo kryo = getInstance();
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> kryo.<span style="color:#007f7f">readObject</span>(input, clazz);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> &lt;T&gt; T readObjectFromString(String str, Class&lt;T&gt; clazz) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">return</span> readObjectFromByteArray(Base64.<span style="color:#007f7f">decodeBase64</span>(str.<span style="color:#007f7f">getBytes</span>(DEFAULT_ENCODING)), clazz);
</span></span><span style="display:flex;"><span>        } <span style="color:#fff;font-weight:bold">catch</span> (UnsupportedEncodingException e) {
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> IllegalStateException(e);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="36-spi">36. SPI<a hidden class="anchor" aria-hidden="true" href="#36-spi">#</a></h1>
<p>SPI机制指的是由调用方定义接口，实现方根据调用方提供的接口进行实现。</p>
<img src="https://king-super.oss-cn-nanjing.aliyuncs.com/20230223151326.png" style="zoom: 33%;" />
<p>调用的示意图如上，那么这套机制是如何实现的呢？</p>
<h2 id="调用方">调用方<a hidden class="anchor" aria-hidden="true" href="#调用方">#</a></h2>
<p>在调用方从ServiceLoader中获取接口的实现对象，当然调用方需要对ServiceLoader中不存在实现对象，或存在多个实例对象的情况进行考虑（ServiceLoader中对象从何而来将在实现方进行讲解）</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">private</span> LoggerService() {
</span></span><span style="display:flex;"><span>    ServiceLoader&lt;Logger&gt; loader = ServiceLoader.<span style="color:#007f7f">load</span>(Logger.<span style="color:#007f7f">class</span>);
</span></span><span style="display:flex;"><span>    List&lt;Logger&gt; list = <span style="color:#fff;font-weight:bold">new</span> ArrayList&lt;&gt;();
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (Logger log : loader) {
</span></span><span style="display:flex;"><span>      	list.<span style="color:#007f7f">add</span>(log);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// LoggerList 是所有 ServiceProvider
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    loggerList = list;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (!list.<span style="color:#007f7f">isEmpty</span>()) {
</span></span><span style="display:flex;"><span>      	<span style="color:#007f7f">// Logger 只取一个
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>      	logger = list.<span style="color:#007f7f">get</span>(<span style="color:#ff0;font-weight:bold">0</span>);
</span></span><span style="display:flex;"><span>    } <span style="color:#fff;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>      	logger = <span style="color:#fff;font-weight:bold">null</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>调用方通过ServiceLoader.load方法获取实例对象，该对象就是调用方提供的接口。</p>
<h2 id="实现方">实现方<a hidden class="anchor" aria-hidden="true" href="#实现方">#</a></h2>
<p>实现方直接对接口进行实现即可，那么实现方在实现完成后如何将实现对象放入ServiceLoader呢，这就需要讲到SPI的实现机制了。</p>
<p>在Java中调用方通过会定义好接口在一个包中，实现方会实现该接口在另一个包中，Java在引入jar包时提供了SPI的机制，设置配置文件META-INF/services，文件名为接口的全路径，文件内容是实现类的全路径。jdk在加载jar包时会读取该文件，并创建对象，将对象存放到ServiceLoader中。</p>
<p>这就有非常多的事情可以做了，因为这种方式可以自动加载配置文件中写的类，会触发类加载，所以可以在类加载中、初始化方法中做很多想做的事情。</p>
<h1 id="37-范型">37. 范型<a hidden class="anchor" aria-hidden="true" href="#37-范型">#</a></h1>
<h2 id="什么是泛型有什么作用">什么是泛型？有什么作用？<a hidden class="anchor" aria-hidden="true" href="#什么是泛型有什么作用">#</a></h2>
<p><strong>Java 泛型（Generics）</strong> 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。</p>
<p>编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 <code>ArrayList&lt;Person&gt; persons = new ArrayList&lt;Person&gt;()</code> 这行代码就指明了该 <code>ArrayList</code> 对象只能传入 <code>Person</code> 对象，如果传入其他类型的对象就会报错。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ArrayList&lt;E&gt; <span style="color:#fff;font-weight:bold">extends</span> AbstractList&lt;E&gt;
</span></span></code></pre></td></tr></table>
</div>
</div><p>并且，原生 <code>List</code> 返回类型是 <code>Object</code> ，需要手动转换类型才能使用，使用泛型后编译器自动转换。</p>
<h2 id="泛型的使用方式有哪几种">泛型的使用方式有哪几种？<a hidden class="anchor" aria-hidden="true" href="#泛型的使用方式有哪几种">#</a></h2>
<p>泛型一般有三种使用方式:<strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong>。</p>
<p><strong>1.泛型类</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">//在实例化泛型类时，必须指定T的具体类型
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> Generic&lt;T&gt;{
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">private</span> T key;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> Generic(T key) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">key</span> = key;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> T getKey(){
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> key;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>如何实例化泛型类：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Generic&lt;Integer&gt; genericInteger = <span style="color:#fff;font-weight:bold">new</span> Generic&lt;Integer&gt;(<span style="color:#ff0;font-weight:bold">123456</span>);
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>2.泛型接口</strong> ：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">interface</span> Generator&lt;T&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> T method();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>实现泛型接口，不指定类型：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">class</span> GeneratorImpl&lt;T&gt; <span style="color:#fff;font-weight:bold">implements</span> Generator&lt;T&gt;{
</span></span><span style="display:flex;"><span>    @Override
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> T method() {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">null</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>实现泛型接口，指定类型：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">class</span> GeneratorImpl&lt;T&gt; <span style="color:#fff;font-weight:bold">implements</span> Generator&lt;String&gt;{
</span></span><span style="display:flex;"><span>    @Override
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> String method() {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#0ff;font-weight:bold">&#34;hello&#34;</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>3.泛型方法</strong> ：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> &lt;E&gt; <span style="color:#fff;font-weight:bold">void</span> printArray(E[] inputArray){
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (E element : inputArray){
</span></span><span style="display:flex;"><span>      	System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">printf</span>(<span style="color:#0ff;font-weight:bold">&#34;%s&#34;</span>, element);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">// 创建不同类型数组： Integer, Double 和 Character
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>Integer[] intArray = {<span style="color:#ff0;font-weight:bold">1</span>, <span style="color:#ff0;font-weight:bold">2</span>, <span style="color:#ff0;font-weight:bold">3</span>};
</span></span><span style="display:flex;"><span>String[] stringArray = {<span style="color:#0ff;font-weight:bold">&#34;Hello&#34;</span>, <span style="color:#0ff;font-weight:bold">&#34;World&#34;</span>};
</span></span><span style="display:flex;"><span>printArray(intArray);
</span></span><span style="display:flex;"><span>printArray(stringArray);
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>注意: <code>public static &lt;E&gt; void printArray(E[] inputArray)</code> 一般被称为静态泛型方法;在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的 <code>&lt;E&gt;</code></p>
</blockquote>
<h2 id="泛型类泛型接口泛型方法">泛型类、泛型接口、泛型方法<a hidden class="anchor" aria-hidden="true" href="#泛型类泛型接口泛型方法">#</a></h2>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> Test1&lt;T&gt;{
</span></span><span style="display:flex;"><span>	  <span style="color:#fff;font-weight:bold">private</span> T t;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  	<span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> setT (T t) {
</span></span><span style="display:flex;"><span>      	<span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">t</span> = t;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  	<span style="color:#fff;font-weight:bold">public</span> T getT(){
</span></span><span style="display:flex;"><span>      	<span style="color:#fff;font-weight:bold">return</span> t;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面是一个基本的泛型类的实现，其实现方式是在类名后增加&lt;&gt;符号来表示泛型，可以使用例如T、E、K、V等形式常见的参数表示泛型。</p>
<p>实例化代码是：<code>Test1&lt;Integer&gt; t = new Test1&lt;&gt;();</code>在new时后面尖括号中的类型可以省略。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">interface</span> TestInt&lt;T&gt; {
</span></span><span style="display:flex;"><span>  	<span style="color:#fff;font-weight:bold">public</span> T method();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> Test2&lt;T&gt; <span style="color:#fff;font-weight:bold">implements</span> TestInt&lt;T&gt;{
</span></span><span style="display:flex;"><span>  	@Override
</span></span><span style="display:flex;"><span>  	<span style="color:#fff;font-weight:bold">public</span> T method() {
</span></span><span style="display:flex;"><span> 				<span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">null</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> Test3 <span style="color:#fff;font-weight:bold">implements</span> TestInt&lt;Integer&gt;{
</span></span><span style="display:flex;"><span>  	@Override
</span></span><span style="display:flex;"><span>  	<span style="color:#fff;font-weight:bold">public</span> Integer method() {
</span></span><span style="display:flex;"><span> 				<span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">null</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码中定义了泛型接口并且在其中定义了一个方法，在实现这个接口时，可以直接在实现中制定泛型的类型，此时在实现具体方法时实现的方法已经是具体类型的了，也可以不指定，继续使用泛型由使用者来确定。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> &lt;E&gt; <span style="color:#fff;font-weight:bold">void</span> mathod(List&lt;E&gt; list){
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>泛型方法可以在void前侧定义泛型，然后在形参或者返回值中使用。</p>
<h2 id="泛型擦除">泛型擦除<a hidden class="anchor" aria-hidden="true" href="#泛型擦除">#</a></h2>
<p>泛型擦除指的是在编译后的字节码中是没有泛型的信息的，这点可以通过反编译进行验证。其中泛型T、K等被擦除为Object，T extends XXX被擦除为XXX。</p>
<p>因为泛型擦除的存在会导致一个新问题，泛型怎么办，例如在一个类实现了另一个泛型类，并且确定了泛型的类型，此时实现的方式是具体类型的，但是在父类中的方法中类型是Object的，但是实现的方法却是具体类型的，此时多态就遇到了问题，因此编译器做了桥方法。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">class</span> Test4&lt;T&gt; {
</span></span><span style="display:flex;"><span>  	<span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> method(T t) {}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">class</span> Test5 <span style="color:#fff;font-weight:bold">extends</span> Test4&lt;Integer&gt;{
</span></span><span style="display:flex;"><span>  	<span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> method(Integer t){}
</span></span><span style="display:flex;"><span>  	
</span></span><span style="display:flex;"><span>  	<span style="color:#007f7f">// 桥方法，编译器自动生成，不需要用户实现
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>  	<span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> method(Object t){
</span></span><span style="display:flex;"><span>      	method((Integer) t);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="泛型的限制">泛型的限制<a hidden class="anchor" aria-hidden="true" href="#泛型的限制">#</a></h2>
<ul>
<li>只能申明但不能实例化T</li>
<li>泛型参数不能是基本类型，因为需要是Object的子类</li>
<li>不能实例化泛型参数的数组</li>
<li>不能实例化泛型数组</li>
<li>泛型不能使用Instance of 和getClass()进行判断</li>
<li>不能使用static修饰泛型变量</li>
</ul>
<p>可以从类型擦除的角度思考，很多不确定的东西是不能实现的。</p>
<h2 id="通配符">通配符<a hidden class="anchor" aria-hidden="true" href="#通配符">#</a></h2>
<p>在定义泛型时可以使用entends确定泛型的最高类型</p>
<p>在使用范型时可以使用？、extends、super对对象类型的范围进行限制。</p>
<p>使用extends和super进行限制后存在使用时的限制需要注意。</p>
<h1 id="38-stream流">38. stream流<a hidden class="anchor" aria-hidden="true" href="#38-stream流">#</a></h1>
<p>Java 8中的Stream是一种新的抽象层，用于对集合对象进行处理。Stream API可以让我们更方便地对集合进行操作，而不需要使用for循环等传统方式。Stream API提供了一种高效且易于使用的处理数据的方式。</p>
<p>Stream流在管道中传输，并且可以在管道的节点上进行处理，比如筛选、排序、聚合等。Stream流的操作可以分为<strong>中间操作</strong>和<strong>终端操作</strong>两种，其中中间操作返回一个新的Stream对象，终端操作则返回一个非Stream对象。</p>
<p>下面是一些Java Stream流的例子：</p>
<ol>
<li>通过 java.util.Collection.stream () 方法用集合创建流</li>
</ol>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>List &lt;String &gt; list = Arrays.<span style="color:#007f7f">asList</span>(<span style="color:#0ff;font-weight:bold">&#34;a&#34;</span>, <span style="color:#0ff;font-weight:bold">&#34;b&#34;</span>, <span style="color:#0ff;font-weight:bold">&#34;c&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 创建一个顺序流
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>Stream &lt;String &gt; stream = list.<span style="color:#007f7f">stream</span>();
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 创建一个并行流
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>Stream &lt;String &gt; parallelStream = list.<span style="color:#007f7f">parallelStream</span>();
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>使用 java.util.Arrays.stream (T [] array) 方法用数组创建流</li>
</ol>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> [] array ={<span style="color:#ff0;font-weight:bold">1</span>,<span style="color:#ff0;font-weight:bold">3</span>,<span style="color:#ff0;font-weight:bold">5</span>,<span style="color:#ff0;font-weight:bold">7</span>,<span style="color:#ff0;font-weight:bold">9</span>};
</span></span><span style="display:flex;"><span>IntStream stream = Arrays.<span style="color:#007f7f">stream</span>(array);
</span></span></code></pre></td></tr></table>
</div>
</div><ol start="3">
<li>使用 Stream.of() 方法创建流</li>
</ol>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Stream&lt;String&gt; strStream = Stream.<span style="color:#007f7f">of</span> (<span style="color:#0ff;font-weight:bold">&#34;hello&#34;</span>, <span style="color:#0ff;font-weight:bold">&#34;java8&#34;</span>, <span style="color:#0ff;font-weight:bold">&#34;stream&#34;</span>);
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="39-大数">39. 大数<a hidden class="anchor" aria-hidden="true" href="#39-大数">#</a></h1>
<p>在计算机程序中进行浮点运算时是存在精度丢失的情况的 ，如下代码就是精度问题导致的：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">float</span> a = <span style="color:#ff0;font-weight:bold">2.0f</span> - <span style="color:#ff0;font-weight:bold">1.9f</span>;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">float</span> b = <span style="color:#ff0;font-weight:bold">1.8f</span> - <span style="color:#ff0;font-weight:bold">1.7f</span>;
</span></span><span style="display:flex;"><span>System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(a);<span style="color:#007f7f">// 0.100000024
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(b);<span style="color:#007f7f">// 0.099999905
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(a == b);<span style="color:#007f7f">// false
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>按照现实中的计算来看a和b都应该是0.1，但是由于计算机对浮点数进行存储是使用的二进制的缘故，无法保证结果的精确性，在《阿里巴巴Java开发手册》中就建议为了避免精度丢失，进行浮点运算时采用BigDecimal进行。</p>
<h2 id="bigdecimal介绍">BigDecimal介绍<a hidden class="anchor" aria-hidden="true" href="#bigdecimal介绍">#</a></h2>
<p>《阿里巴巴 Java 开发手册》中提到：<strong>浮点数之间的等值判断，基本数据类型不能用 == 来比较，包装数据类型不能用 equals 来判断。</strong>（由于精度的原因）</p>
<h3 id="创建">创建<a hidden class="anchor" aria-hidden="true" href="#创建">#</a></h3>
<p>我们在使用 <code>BigDecimal</code> 时，为了防止精度丢失，推荐使用它的<code>BigDecimal(String val)</code>构造方法或者 <code>BigDecimal.valueOf(double val)</code> 静态方法来创建对象。</p>
<img src="https://king-super.oss-cn-nanjing.aliyuncs.com/20230223100028.png" style="zoom: 50%;" />
<h3 id="加减乘除操作">加减乘除操作<a hidden class="anchor" aria-hidden="true" href="#加减乘除操作">#</a></h3>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>BigDecimal a = <span style="color:#fff;font-weight:bold">new</span> BigDecimal(<span style="color:#0ff;font-weight:bold">&#34;1.0&#34;</span>);
</span></span><span style="display:flex;"><span>BigDecimal b = <span style="color:#fff;font-weight:bold">new</span> BigDecimal(<span style="color:#0ff;font-weight:bold">&#34;0.9&#34;</span>);
</span></span><span style="display:flex;"><span>System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(a.<span style="color:#007f7f">add</span>(b));<span style="color:#007f7f">// 1.9
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(a.<span style="color:#007f7f">subtract</span>(b));<span style="color:#007f7f">// 0.1
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(a.<span style="color:#007f7f">multiply</span>(b));<span style="color:#007f7f">// 0.90
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(a.<span style="color:#007f7f">divide</span>(b));<span style="color:#007f7f">// 无法除尽，抛出 ArithmeticException 异常
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(a.<span style="color:#007f7f">divide</span>(b, <span style="color:#ff0;font-weight:bold">2</span>, RoundingMode.<span style="color:#007f7f">HALF_UP</span>));<span style="color:#007f7f">// 1.11
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>这里需要注意的是，在我们使用 <code>divide</code> 方法的时候尽量使用 3 个参数版本，并且<code>RoundingMode</code> 不要选择 <code>UNNECESSARY</code>，否则很可能会遇到 <code>ArithmeticException</code>（无法除尽出现无限循环小数的时候），其中 <code>scale</code> 表示要保留几位小数，<code>roundingMode</code> 代表保留规则。</p>
<h3 id="大小比较">大小比较<a hidden class="anchor" aria-hidden="true" href="#大小比较">#</a></h3>
<p><code>a.compareTo(b)</code> : 返回 -1 表示 <code>a</code> 小于 <code>b</code>，0 表示 <code>a</code> 等于 <code>b</code> ， 1 表示 <code>a</code> 大于 <code>b</code>。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>BigDecimal a = <span style="color:#fff;font-weight:bold">new</span> BigDecimal(<span style="color:#0ff;font-weight:bold">&#34;1.0&#34;</span>);
</span></span><span style="display:flex;"><span>BigDecimal b = <span style="color:#fff;font-weight:bold">new</span> BigDecimal(<span style="color:#0ff;font-weight:bold">&#34;0.9&#34;</span>);
</span></span><span style="display:flex;"><span>System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(a.<span style="color:#007f7f">compareTo</span>(b));<span style="color:#007f7f">// 1
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="保留几位小数">保留几位小数<a hidden class="anchor" aria-hidden="true" href="#保留几位小数">#</a></h3>
<p>通过 <code>setScale</code>方法设置保留几位小数以及保留规则。保留规则有挺多种，不需要记，IDEA 会提示。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>BigDecimal m = <span style="color:#fff;font-weight:bold">new</span> BigDecimal(<span style="color:#0ff;font-weight:bold">&#34;1.255433&#34;</span>);
</span></span><span style="display:flex;"><span>BigDecimal n = m.<span style="color:#007f7f">setScale</span>(<span style="color:#ff0;font-weight:bold">3</span>,RoundingMode.<span style="color:#007f7f">HALF_DOWN</span>);
</span></span><span style="display:flex;"><span>System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(n);<span style="color:#007f7f">// 1.255
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="等值比较问题">等值比较问题<a hidden class="anchor" aria-hidden="true" href="#等值比较问题">#</a></h3>
<img src="https://king-super.oss-cn-nanjing.aliyuncs.com/image-20230223100604900.png" style="zoom:50%;" />
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>BigDecimal a = <span style="color:#fff;font-weight:bold">new</span> BigDecimal(<span style="color:#0ff;font-weight:bold">&#34;1&#34;</span>);
</span></span><span style="display:flex;"><span>BigDecimal b = <span style="color:#fff;font-weight:bold">new</span> BigDecimal(<span style="color:#0ff;font-weight:bold">&#34;1.0&#34;</span>);
</span></span><span style="display:flex;"><span>System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(a.<span style="color:#007f7f">equals</span>(b));<span style="color:#007f7f">//false
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(a.<span style="color:#007f7f">compareTo</span>(b));<span style="color:#007f7f">//0
</span></span></span></code></pre></td></tr></table>
</div>
</div><h1 id="40-集合">40. 集合<a hidden class="anchor" aria-hidden="true" href="#40-集合">#</a></h1>
<p>Java集合也称为容器，所有容器都由两大接口派生而来，分别是<code>Collection</code>、<code>Map</code>。Collection接口的实现类只要用于存放单一的元素，Map接口的实现类主要用于存放键值对，其中Collection接口有三个主要的子接口：List、Set、Queue。</p>
<p><img loading="lazy" src="https://king-super.oss-cn-nanjing.aliyuncs.com/20230224103416.png" alt=""  />
</p>
<h2 id="四种主要容器的区别">四种主要容器的区别<a hidden class="anchor" aria-hidden="true" href="#四种主要容器的区别">#</a></h2>
<ul>
<li>List：存放有序的、可重复的元素（处理有序的元素）</li>
<li>Set：存放无序的、不可重复的元素（主要用于处理不可重复的场景）</li>
<li>Queue：存放有序的、可重复的元素，但是会根据要求限制先后顺序（例如排队等功能）</li>
<li>Map：存储键值对，其中key是无序的、不可重复的</li>
</ul>
<h2 id="如何选用集合">如何选用集合?<a hidden class="anchor" aria-hidden="true" href="#如何选用集合">#</a></h2>
<p>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code>,不需要排序时就选择 <code>HashMap</code>,需要保证线程安全就选用 <code>ConcurrentHashMap</code>。</p>
<p>当我们只需要存放元素值时，就选择实现<code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code>，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code>，然后再根据实现这些接口的集合的特点来选用。</p>
<h2 id="为什么要使用集合">为什么要使用集合？<a hidden class="anchor" aria-hidden="true" href="#为什么要使用集合">#</a></h2>
<p>当我们需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，这个容器就是数组，但是，使用数组存储对象具有一定的弊端， 因为我们在实际开发中，存储的数据的类型是多种多样的，于是，就出现了“集合”，集合同样也是用来存储多个数据的。</p>
<p>数组的缺点是一旦声明之后，长度就不可变了；同时，声明数组时的数据类型也决定了该数组存储的数据的类型；而且，数组存储的数据是有序的、可重复的，特点单一。 但是集合提高了数据存储的灵活性，Java 集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据。</p>
<h2 id="集合的使用方法">集合的使用方法<a hidden class="anchor" aria-hidden="true" href="#集合的使用方法">#</a></h2>
<p>我们在使用集合的时候通常都是使用四种接口然后指向其子类，所以下面主要介绍几个接口总提供的方法进行介绍。</p>
<h4 id="collection">Collection<a hidden class="anchor" aria-hidden="true" href="#collection">#</a></h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>int size()</td>
<td>容器中存放的对象数量</td>
</tr>
<tr>
<td>boolean contains(Object)</td>
<td>容器中是否包含形参对象</td>
</tr>
<tr>
<td>boolean containsAll(Collection<?> c)</td>
<td>若容器中包含形参容器中的所有元素，返回true</td>
</tr>
<tr>
<td>iterator()</td>
<td>迭代器</td>
</tr>
<tr>
<td>T[] toArray()</td>
<td>将容器中的对象转化为一个数组进行返回</td>
</tr>
<tr>
<td>T[] toArray(T[] a)</td>
<td>控制返回类型的数组，作用同上</td>
</tr>
<tr>
<td>boolean add(E e)</td>
<td>向容器中添加元素</td>
</tr>
<tr>
<td>boolean addAll(Collection&lt;? extends E&gt; c)</td>
<td>将形参容器中的所有元素添加到容器中</td>
</tr>
<tr>
<td>boolean remove(Object o)</td>
<td>从容器中移除元素</td>
</tr>
<tr>
<td>boolean removeAll(Collection<?> c)</td>
<td>从容器中移除形参容器中的所以元素</td>
</tr>
<tr>
<td>boolean retainAll(Collection<?> c)</td>
<td>保留容器中存在与形参容器中的元素</td>
</tr>
<tr>
<td>void clear()</td>
<td>清空容器</td>
</tr>
</tbody>
</table>
<h4 id="list">List<a hidden class="anchor" aria-hidden="true" href="#list">#</a></h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean addAll(int index, Collection&lt;? extends E&gt; c)</td>
<td>在index下表开始添加形参中的元素</td>
</tr>
<tr>
<td>default void replaceAll(UnaryOperator<E> operator)</td>
<td>将容器中的每一个元素替换为operator运算后的结果</td>
</tr>
<tr>
<td>void sort(Comparator&lt;? super E&gt; c)</td>
<td>根据比较器对容器中的元素进行排</td>
</tr>
<tr>
<td>E get(int index)</td>
<td>获取下标为index的元素</td>
</tr>
<tr>
<td>E set(int index, E element)</td>
<td>设置下表为index的元素为element</td>
</tr>
<tr>
<td>void add(int index, E element)</td>
<td>在下标为index的地方插入元素element</td>
</tr>
<tr>
<td>E remove(int index)</td>
<td>移除下标为index的元素</td>
</tr>
<tr>
<td>int indexOf(Object o)</td>
<td>获取元素在容器中的下标</td>
</tr>
<tr>
<td>int lastIndexOf(Object o)</td>
<td>获取元素在容器中最后一次出现的索引</td>
</tr>
<tr>
<td>ListIterator<E> listIterator()</td>
<td>返回词容器的列表迭代器</td>
</tr>
<tr>
<td>ListIterator<E> listIterator(int index)</td>
<td>返回从index开始的列表迭代器</td>
</tr>
<tr>
<td>List<E> subList(int fromIndex, int toIndex)</td>
<td>返回子序列（前闭后开，相同时返回为空）</td>
</tr>
</tbody>
</table>
<p>大部分方法通过方法名就可以知道其作用，通常这些方法也是最常用的。</p>
<h4 id="set">Set<a hidden class="anchor" aria-hidden="true" href="#set">#</a></h4>
<p>Set中的方法都继承自Collection，其通过Map实现，因为Map中的Key是唯一的，因此满足Set不重复、乱序的特点。</p>
<h4 id="queue">Queue<a hidden class="anchor" aria-hidden="true" href="#queue">#</a></h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean offer(E e)</td>
<td>在不违反容量限制的条件下，立即将指定的元素插入队列中</td>
</tr>
<tr>
<td>E remove()</td>
<td>删除队列的头元素，若队列为空将抛出异常</td>
</tr>
<tr>
<td>E poll()</td>
<td>退出队列的头元素，队列为空则返回null</td>
</tr>
<tr>
<td>E element()</td>
<td>检查队列的头元素，若队列为空抛出异常</td>
</tr>
<tr>
<td>E peek()</td>
<td>检测队列的头元素，若队列为空返回null</td>
</tr>
</tbody>
</table>
<h4 id="map">Map<a hidden class="anchor" aria-hidden="true" href="#map">#</a></h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>int size()</td>
<td>返回映射中的键值对数量</td>
</tr>
<tr>
<td>boolean containsKey(Object key)</td>
<td>映射中是否包含键为key的键值对</td>
</tr>
<tr>
<td>boolean containsValue(Object value)</td>
<td>映射中是否有键值对映射到该value上</td>
</tr>
<tr>
<td>V get(Object key)</td>
<td>根据提供的key获得value</td>
</tr>
<tr>
<td>V put(K key, V value)</td>
<td>向映射中添加键值对，若原来已经存在则替换value</td>
</tr>
<tr>
<td>V remove(Object key)</td>
<td>根据value从映射中移除键值对</td>
</tr>
<tr>
<td>void putAll(Map&lt;? extends K, ? extends V&gt; m)</td>
<td>将形参映射中所有的键值对添加到映射中</td>
</tr>
<tr>
<td>void clear()</td>
<td>清空映射</td>
</tr>
<tr>
<td>Set<K> keySet()</td>
<td>返回映射中key构成的Set类型对象</td>
</tr>
<tr>
<td>Collection<V> values()</td>
<td>返回映射中value构成的Collection对象</td>
</tr>
<tr>
<td>Set&lt;Map.Entry&lt;K, V&raquo; entrySet()</td>
<td>返回映射中键值对构成的Set类型对象</td>
</tr>
<tr>
<td>V getOrDefault(Object key, V defaultValue)</td>
<td>返回key映射到的值，若不存在则返回默认值</td>
</tr>
<tr>
<td>void forEach(BiConsumer&lt;? super K, ? super V&gt; action)</td>
<td>对映射中的所有键值对执行指定操作</td>
</tr>
<tr>
<td>void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function)</td>
<td>对映射中的所有键值对执行指定操作，与foreach方法的区别在于执行的操作会改变value的值，而foreach不会</td>
</tr>
<tr>
<td>V putIfAbsent(K key, V value)</td>
<td>如果指定的键尚未与值关联（或映射到 null），则将其与给定值关联并返回 null，否则返回当前值。</td>
</tr>
<tr>
<td>boolean remove(Object key, Object value)</td>
<td>仅当指定键当前映射到指定值时，才删除该项。</td>
</tr>
<tr>
<td>boolean replace(K key, V oldValue, V newValue)</td>
<td>更新指定键值对的值</td>
</tr>
<tr>
<td>V replace(K key, V value)</td>
<td>仅当指定键当前映射到某个值时，才替换该项</td>
</tr>
<tr>
<td>V computeIfAbsent(K key,         Function&lt;? super K, ? extends V&gt; mappingFunction)</td>
<td>如果指定的键尚未与值关联（或映射到 null），则尝试使用给定的映射函数计算其值，并将其输入到此映射中，除非为 null。如果函数返回 null，则不记录任何映射。如果函数本身引发（未选中的）异常，则会重新引发异常，并且不会记录任何映射</td>
</tr>
<tr>
<td>V computeIfPresent(K key,         BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</td>
<td>如果指定键的值存在且非 null，则尝试在给定键及其当前映射值的情况下计算新映射</td>
</tr>
<tr>
<td>V compute(K key,         BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</td>
<td>尝试计算指定键及其当前映射值的映射（如果没有当前映射，则为 null）</td>
</tr>
<tr>
<td>V merge(K key, V value,         BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction)</td>
<td>如果指定的键尚未与值关联或与 null 关联，则将其与给定的非 null 值相关联。否则，将关联的值替换为给定重映射函数的结果，如果结果为 null，则删除。当组合一个键的多个映射值时，此方法可能有用</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断映射是否为空</td>
</tr>
</tbody>
</table>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://jinchaojjj.github.io/tags/%E5%9F%BA%E7%A1%80/">基础</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://jinchaojjj.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">
    <span class="title">« Prev</span>
    <br>
    <span>计算机网络</span>
  </a>
  <a class="next" href="https://jinchaojjj.github.io/posts/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E6%8F%90%E5%8D%87/">
    <span class="title">Next »</span>
    <br>
    <span>Java基本提升</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://jinchaojjj.github.io">King&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
