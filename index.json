[{"content":"计算机网络 作用：在不同设备之间进行通信，为了在不同类型的设备间都可以通行就定义了一套网络协议\n与OSI的七层模型相比，在现实中使用更多的是TCP/IP的四层模型\n下图中描述了在不同层级中常用的协议、数据格式、作用等。\n下图介绍了HTTP请求过程中不同层级涉及到的协议的格式，上层内容作为下层的数据。 一、HTTP协议 应用层协议 Hyper Text Transfer Protocol 超文本传输协议，通过传输文本的方式（文本中包含了超链接等非文本类型的数据）传输网页 作用：在浏览器中显示网页；当然该协议也可以传输非HTTP格式的数据（例如JSON、XML、txt等格式），此时获取数据后的使用交由客户端决定。 下面首先对HTTP协议的消息结构进行讲解；HTTP是基于客户端/服务端（C/S）架构的，通过可靠的链接（TCP）来交换信息，是一个无状态的请求/响应协议。\n无连接的：限制每次连接只处理一个请求，服务器处理完客户的请求并收到客户的应答后，即断开连接 无状态的：指的是协议对于事务没有记忆能力，若后面的处理需要前面的信息必须重传 媒体独立的：任何类型的数据都可以通过HTTP发送，只要客户端和服务端知道如何处理数据内容 HTTP消息结构 HTTP请求由客户端发出，客户端通常是一个应用程序（浏览器或者其他应用程序） HTTP的服务器同样是应用程序（通常是一个Web服务器），用于处理用户发出的请求，并向客户端发送响应 HTTP使用统一资源标识符（URL）来传输数据和建立连接 请求报文-请求行 请求行中包含以下内容\n请求方式：也称为动作，用于表明本次请求对指定资源的不同操作 URL：统一资源定位符，用于表示资源信息的位置 版本：HTTP请求的版本 请求方式 方法 描述 1 GET 请求指定的页面信息，并返回实体主体。 2 HEAD 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 3 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 4 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 5 DELETE 请求服务器删除指定的页面。 6 CONNECT HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。 7 OPTIONS 允许客户端查看服务器的性能。 8 TRACE 回显服务器收到的请求，主要用于测试或诊断。 9 PATCH 是对 PUT 方法的补充，用来对已知资源进行局部更新 。 上述的九种请求方法中现在常用的是REST风格中的四种请求方式：GET、POST、PUT、DELETE。\nURL URL完整的格式如下：\n其中不同字段的含义如下：\nscheme：协议\nhost：主机名，指定的域名或者IP地址\nport：端口号（一般会省略，每种常用的请求协议都有默认的端口号）\npath：路径，由零或多个/符号隔开的字符串，一般用来表示主机上的一个目录或文件地址\nquery：查询（可选），用于给动态网页（如使用CGI、ISAPI、PHP/JSP/ASP/ASP.NET等技术制作的网页）传递参数，可有多个参数，用\u0026amp;符号隔开，每个参数的名和值用=符号隔开\nfragment：信息片断（字符串），用于指定网络资源中的片断。例如一个网页中有多个名词解释，可使用fragment直接定\n位到某一名词解释\nHTTP请求中的URL其实指代的是完整URL中的path部分。通常采用零个或者多个/符号进行分割，如下图所示：\n版本 常见的HTTP版本有：1.1、2.0、3.0，之后会单独写一篇博客对几个不同的版本进行比较。\n请求报文-请求头 请求头中的内容格式较为简单：字段名-字段值的方式按行分布，中间用空格分隔，下面讲述一些常用的首部字段：\nAccept 表示客户端期望服务器返回的媒体格式。客户端期望的资源类型服务器可能没有，所以客户端会期望多种类型，并且设置优先级，服务器根据优先级寻找相应的资源返回给客户端。\n1 2 # 注意：先逗号分割类型，再分号分割属性 Accept: audio/*; q=0.2, audio/basic 表示audio/basic类型的资源优先，如果没有，就随便其它什么格式的audio资源都可以。q的取值范围是(0-1]，其具体值并没有意义，它仅用来排序优先级，如果没有q，默认q=1，也就是最高优先级。\nAccept-Charset 表示客户端期望服务器返回的内容的编码格式。它同Accept头一样，也可以指定多个编码，以q值代表优先级。\n1 2 # 注意：先逗号分割类型，再分号分割属性 Accept-Charset: utf8, gbk; q=0.6 表示utf8编码优先，如果不行，就拿gbk编码返回。\nContent-Type Content-Type是服务器向客户端发送的头（也可以是客户端在发送请求时规定请求体的数据格式、编码等信息），代表内容的媒体类型和编码格式，是对Accept头和Accept-Charset头的统一应答。\n1 Content-Type: text/html; charset=utf8 表示返回的Body是个html文本，编码为utf8\nAccept-Language 表示客户端期望服务器返回的内容的语言。很多大型互联网公司是全球化的，它的技术文档一般有多种语言，通过这个字段可以实现文档的本地化，对国内用户呈现简体中文文档，对英语系用户呈现英文文档。\n1 Accept-Language: zh-CN, en-US; q=0.8, zh-TW; q=0.6 表示大陆简体中文优先，其次英语，再其次台湾繁体中文\nContent-Language 这个头字段内容是对Accept-Language的应答。服务器通过此字段告知客户端返回的Body信息的语言是什么。\nContent-Length 表示传输的请求／响应的Body的长度。GET请求因为没有Body（这里需要说明的是HTTP协议、Java后端是支持GET请求带有请求体的，但是WEB可能不支持带有请求体，前段代码还是要依托于浏览器的，所以尽可能不要在GET请求中使用请求体），所以不需要这个头。携带Body的并且可以提前知道Body长度的请求／响应必须带上这个字段，以便对方可以方便的分辨出报文的边界，也就是Body数据何时结束。如果Body太大，需要边计算边传输，不到最后计算结束是无法知道整个Body大小的，这个时候可以使用http分块传输，这个时候也是不需要Content-Length字段的。\nContent-Location 当客户端请求的资源在服务器有多个地址时，服务器可以通过Content-Location字段告知客户端其它的可选地址。这个字段比较少见。\nContent-MD5 在Header中提供这个信息是用来做Body内容校验。它表示Body信息被md5算法处理后的base64字符串。这个字段也比较少见。因为校验机制在TCP层已经有实现了，再来一层校验并没有多大意义。另外资源的md5值往往用来放在后面的ETag头信息中作为资源的唯一标识来使用。\nDate 如果服务器没有缓存，那么Date就是响应的即时生成时间。如果服务器设有缓存，那么Date就是响应内容被缓存的时间。它必须符合规范里定义的特定格式，这种格式叫着HTTP-Date，不支持随意定义自己的时间格式。\n1 Date: Tue, 15 Nov 1994 08:12:31 GMT Age 表示资源缓存的年龄，也就是资源自缓存以来到现在已经过去了多少时间，单位是秒。\n1 Age: 86400 Expires 服务器使用Expect头来告知对方资源何时失效。如果它的值等于Date头的值，就表示资源已经失效。\n1 Expires: Thu, 01 Dec 1994 16:00:00 GMT ETag 资源标签，每个资源可以提供多个标签信息。它一般用来和下面的If-Match和If-None-Match配合使用，用来判断缓存资源的有效性。比较常见的标签是资源的版本号，比如可以拿资源数据的md5校验码作为版本号。\nIf-Match If-Match的值一般是上面提到的ETag的值，它常用于HTTP的乐观锁。所谓HTTP乐观锁，是指客户端先GET这个资源得到ETag中的版本号，然后发起一个资源修改请求PUT|PATCH时通过If-Match头来指定资源的版本号，如果服务器资源满足If-Match中指定的版本号，请求就会被执行。如果不满足，说明资源被并发修改了，就需要返回状态码为412 Precondition failed 的错误。客户端可以选择放弃或者重试整个过程。\nIf-None-Match 类似于If-Match，只是条件相反。\nAllow 表示资源支持访问的HTTP Method类型。它是服务器对客户端的建议，告知对方请使用Allow中提到的Method来访问资源。\n1 Allow: GET, HEAD, PUT Connection 当客户端和服务器需要协商连接的属性时，可以使用Connection头部。比较常用的一个值是close，用来通知对方在当前请求结束后关闭连接。\n1 Connection: close Expect 用于请求发送之前向服务器询问许可。譬如要向服务器发送一个很大的文件而不确定是否超出限制，就可以在请求头里携带一个Expect头部\n1 Expect: 100-continue 如果服务器说不行，就会返回417 Expectation Failed错误告知客户端放弃。如果可以那就返回100 continue状态码告知客户端放马过来吧，于是客户端就会继续上传Body内容。如果服务器提前收到Body内容就会放弃返回100 continue响应。\nFrom 该字段一般用来标记请求发起者的邮件地址，相当于给请求赋予一个责任人。如果服务器发现请求存在问题，就会通过此字段联系到发起人进行处理。因为邮件地址涉及到隐私信息，所以请求携带From头需要征得用户的同意。RFC协议建议所有的机器人代理发起的请求应该携带此头部，以免遇到问题时可以找到责任人。不过如果是恶意的机器人，估计这样的建议也只是耳边风而已。\nHost RFC协议规定所有的HTTP请求必须携带Host头，即使Host没有值，也必须带上这个Host头附加一个空串，如果不满足，应用服务器应该抛出400 Bad Request。协议虽然这样规定，不过大部分网关或者服务器都比较仁慈，既然没有指定Host字段，那就给你默认加上一个。 网关代理可以根据不同的Host值转发到不同的upstream服务节点，它常用于虚拟主机服务业务。\nLast-Modified 标记资源的最近修改时间，它和Date比较类似，区别是Last-Modified代表修改时间，而Date是创建时间。\nIf-Modified-Since 浏览器向服务器请求静态资源时，如果浏览器本地已经有了缓存，就会携带If-Modified-Since头，值为资源的Last-Modified时间，询问服务器该资源自从这个Last-Modified时间之后有没有被修改。如果没有修改过，就会向浏览器返回304 Not Modified通知浏览器可以放心使用缓存内的资源。如果资源修改过，那就像正常的GET请求一样，携带资源的内容返回200 OK。\nIf-Unmodified-Since 类似于If-Modified-Since，意义相反。区别是当服务器资源条件不满足时，不是返回304 Not Modified，而是返回412 Precondition Failed。\nRange 支持断点续传的服务器必须处理Range头，它表示客户端请求资源的一部分时指定的请求字节范围。它是客户端向服务器发送的请求头。\n1 Range: bytes=500-999 Content-Range 针对上面的Range头，服务器响应客户端时也需提供相应的Content-Range头，表示传输的Body数据在整体资源块中的字节范围。比如下面的例子表示该资源总共有47022字节，当前响应的内容是21010-47021字节之间的内容。\n1 Content-Range: bytes 21010-47021/47022 之所以是47021而不是47022是因为offset是以0开始的，47021就是最后一个字节。\nIf-Range 在断点续传时，为确保连续2个请求之间服务器资源本身没有发生变化，需要If-Range头带上ETag的资源版本号。服务器资源根据这个版本号来判定资源是否改变了。如果没变，就返回206 Partial Content将部分资源返回。如果资源变了，那就相当于一个普通的GET请求，返回200 OK和整个资源内容。\nLocation 服务器向客户端发送302跳转的时候，总会携带Location头信息，它的值为目标URL。\n1 2 HTTP/1.1 302 Temporary Redirect Location: https://www-temp.example.org/ Max-Forwards 用来限定网关或者代理的层数，也就是最大转发次数。HTTP每经过一个网关或者代理层，Max-Forwards值就要减1。如果nginx接收到前端请求的时候Max-Forwards已经等于0，那么它就不应该再将请求转发到upstream指定的服务节点上。\nPragma 这个头是比较常见的，在前端开发模式下经常会加上这个头部。\n1 Pragma: no-cache 当网关收到一个带有这样请求的头部时，即使内部存在该请求资源的缓存并且有效也不可以直接发送给客户端，而必须转发给后面的upstream进行处理。 不过如果真的所有的网关都遵循这个协议的话，攻击是很容易构造的，所以它一般仅用于开发模式，防止静态资源修改后前端得不到即时更新。其它值的pragma值没有遇到过。\nReferer Referer是非常常用的头，它表示请求的发起来源URI，也就是当前页面资源的父页面。如果你从A页面跳转到B页面，那么请求B页面的请求头里面就会有Referer信息，它的值就是A页面的访问地址。通过追踪Referer，可得出资源页面之间复杂的跳转链，它非常适合用于网页的数据分析和路径优化。\nRetry-After 服务器升级时，来自客户端的请求会直接给予503(Service Unavailable)错误，通过在返回头里面加入Retry-After字段告知客户端何时服务可以恢复正常访问。Retry-After的头可以是HTTP-Date，也可以是整数，表示多少秒后服务可以恢复正常访问。浏览器在拿到这个值之后可以考虑增加一个定时器在未来的某个时间进行重试。\nServer 用于返回服务器相关的软件信息，来告知客户端当前的HTTP服务是由某某软件提供的，可以看成是一种软件广告。 RFC协议里对这个头信息做了警告：暴露出服务器信息可能会导致黑客更易于攻击你的服务，建议谨慎使用。\nUser-Agent 携带当前的用户代理信息，一般包含浏览器、浏览器内核和操作系统的版本型号信息。它和Server头是对应的，一个是表达服务器信息，一个是表达客户端信息。服务器可以根据用户代理信息统计出网页服务的浏览器、操作系统的使用占比情况，服务器也可以根据UA的信息来定制不一样的内容。\nTransfer-Encoding 传送Body信息时需要对Body数据采取何种变换。当HTTP对Body进行分块传送时，需要增加下面的头部信息才可以进行分块传送。其它类型目前没有遇到过。\n1 Transfer-Encoding: chunked Upgrade 服务器建议客户端升级传输协议。比如当客户端使用HTTP/1.0发送请求时，服务器就可以建议客户端升级到HTTP/1.1。 这个时候就可以使用Upgrade头。客户端收到这个Upgrade后就会将后续请求转成HTTP/1.1格式继续进行交流。可以支持多个参数，使用逗号分割即可。\n1 Upgrade: HTTP/1.1 当客户端要和服务器进行Websocket进行通讯时，在握手阶段服务器也会向客户端发送Upgrade头部信息，提示客户端将协议切换到Websocket。\n1 Upgrade: WebSocket Vary 该头部用于缓存控制。对于一些缓存服务器，我们在请求里加入Vary参数可以告知缓存服务器对不同的Vary参数的响应使用不同的缓存单元。比如Vary参数里放入编码参数，那么不同编码的网页就会有不同的缓存。Vary的值可以有多个，只要任意一个值不一样就会有不同的缓存。 比如下面的这个例子告知缓存服务器对不同语言和不同编码的网页响应使用不同的缓存单元。\n1 Vary: Accept-Encoding,Accept-Language Via 该字段用来标识一个请求经过的网关路由节点。如果这个请求经过了多个代理层，Via头部就会有多个网关信息。\nWarning 用于在响应中添加一些附加的警告信息，警告信息包含一个错误码和错误说明。通用的一些错误码在RFC协议中有具体规定。比如111号错误码表示缓存服务器的缓存项目已经过期，并且尝试reload资源，但是reload失败了，所以只好返回了旧的已经过期的内容，这个时候就需要通过warning头反馈客户端。\n1 Warning: 111 Revalidation failed WWW-Authenticate WWW-Authenticate是401 Unauthorized错误码返回时必须携带的头，该头会携带一个问题Challenge给客户端，告知客户端需要携带这个问题的答案来请求服务器才可以继续访问目标资源。这种问题Challenge可以自定义，比较常见的是Basic认证。\n1 WWW-Authenticate: Basic realm=xxx Basic指代base64加密算法(不安全)，realm指代认证范围/场合/情景名称。\nAuthorization 对于某些需要特殊权限才能访问的资源需要客户端在请求里提供用户名密码的认证信息。它是对WWW-Authenticate的应答。\n1 2 # value = base64(user_name:password) Authorization: Basic YWRtaW46YWRtaW4xMjM= Proxy-Authenticate 同WWW-Authorization头部，用于代理服务器认证。\nProxy-Authorization 同Authorization头部，用于代理服务器认证。\nETag vs Last-Modified vs Expires ETag一般携带的是资源的版本号，协议没有具体规定版本号是什么。它可以是资源的md5校验码，也可以是uuid，甚至可以是自增的数字，也可以是资源的修改时间。它的匹配方式是相等/不相等。因为服务器需要维护版本号，取决的版本号是什么，这可能是一个存储和计算的负担。\nLast-Modified携带的资源的修改时间。它的匹配方式是大于/小于。如果是静态资源文件，一般就是操作系统记录的文件修改时间。\nExpires是服务器告知客户端资源的过期时间。客户端缓存的资源在这个时间之后自动过期，而不需要非得向服务器确认一下是不是304 Not Modified才认为没过期。\nCache-Control 这可能是HTTP头里面最复杂的一个头了。这个头既可以用于请求，也可以用于响应。在请求和响应的取值不一样，分别代表了不同的意思。\nno-cache 如果no-cache没有指定值，那就表示不允许缓存。对于请求来说，服务器不得使用缓存内容直接返回。对于响应来说，客户端不得缓存响应的资源内容。如果no-cache指定了值，那就表示值对应的头信息不得使用缓存，其它的信息还是可以缓存的。告知对方我只要新鲜刚出浴的数据。 no-store 告知对方不要持久化请求/响应数据到其它地方，这种信息是敏感的，要保持它的易失性。告知对方记在心里(memory)就行，别写在纸上(disk)。 no-transform 告知对方不要转换数据。比如客户端上传了raw图像数据，服务器一般都会选择性压缩图像数据进行存储。no-transform告知对方保留原始数据信息，不要进行任何转换。告知对方不要乱动我发过来的东西。 only-if-cached 用于请求头，告知服务器只要那些已经缓存的内容，不要去reload。如果没有缓存内容就返回504 Gateway Timeout错误。表示客户端不想太麻烦服务器，有就给，没就算了。 max-age 用于请求头。限制缓存内容的年龄，如果超过max-age年龄的，需要服务器去reload内容资源。这叫客户端的年龄歧视。 max-stale 用于请求头。客户端允许服务器返回缓存已过期的资源内容，但是限定了最大过期时间。表示客户端虽然很宽容，那是也是有限度的。 min-fresh 用于请求头。客户端限制服务器不要那些即将过期的资源内容。就好比我们去超市买牛奶，如果牛奶快过期了虽然还在保质期内咱们也就不会考虑。 public 用于响应头。表示允许客户端缓存响应信息，并可以给别人使用。比如代理服务器缓存静态资源供所有代理用户使用。 private 用于响应头。表示仅允许客户端缓存响应信息给自己使用，不得分享给别人。这样是为了禁止代理服务器进行缓存，而允许客户端自己缓存资源内容。意思是你个人留着用就行，别借给别人用。 请求体 请求体部分就比较简单了，将需要的发送的数据放到请求体中即可，但是需要注意将请求体的格式、编码在字段Content-Type中指明，同时需要注意请求数据的长度，服务端是否支持这么长的请求数据等\n状态码 相较于请求行中的内容，在响应行中还有状态码，下面对常用的状态码进行介绍：\nHTTP 状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型。响应分为五类：\n分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 HTTP状态码列表:\n状态码 状态码英文名称 中文描述 100 Continue 继续。客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 200 OK 请求成功。一般用于GET与POST请求 201 Created 已创建。成功请求并创建了新的资源 202 Accepted 已接受。已经接受请求，但未处理完成 203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 206 Partial Content 部分内容。服务器成功处理了部分GET请求 300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 303 See Other 查看其它地址。与301类似。使用GET和POST请求查看 304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 305 Use Proxy 使用代理。所请求的资源必须通过代理访问 306 Unused 已经被废弃的HTTP状态码 307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向 400 Bad Request 客户端请求的语法错误，服务器无法理解 401 Unauthorized 请求要求用户的身份认证 402 Payment Required 保留，将来使用 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\u0026quot;您所请求的资源无法找到\u0026quot;的个性页面 405 Method Not Allowed 客户端请求中的方法被禁止 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求 407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 408 Request Time-out 服务器等待客户端发送的请求时间过长，超时 409 Conflict 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息 412 Precondition Failed 客户端请求信息的先决条件错误 413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理 415 Unsupported Media Type 服务器无法处理请求附带的媒体格式 416 Requested range not satisfiable 客户端请求的范围无效 417 Expectation Failed 服务器无法满足Expect的请求头信息 500 Internal Server Error 服务器内部错误，无法完成请求 501 Not Implemented 服务器不支持请求的功能，无法完成请求 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求 505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理 ","permalink":"https://jinchaojjj.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","summary":"计算机网络 作用：在不同设备之间进行通信，为了在不同类型的设备间都可以通行就定义了一套网络协议 与OSI的七层模型相比，在现实中使用更多的是TC","title":"计算机网络"},{"content":"HTTP ","permalink":"https://jinchaojjj.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/http%E8%AF%A6%E8%A7%A3/","summary":"HTTP","title":"HTTP详解"},{"content":"加密算法 一、编码算法 编码算法是将二进制（bit）转化为字符（例如a、中等）的过程，这种编码称为字符编码。\n常见的字符编码有：ASCII、UTF、GBK等。其中ASCII中只能有128个字符，通常只用来显示英文字符，与汉子相关使用较多的是UTF-8与GBK，这里需要注意的是产生二进制bit使用的编码是什么时，在显示字符时所用的也要是对应的编码。\nURL编码 是浏览器发送数据给服务器时所用的编码，通常附加在URL后面的参数部分，使用编码的原因是为了提高兼容性，很多服务器只能使用ASCII字符.\nURL编码的方式如下：\n字符是A～ Z、a～z、0~9以及-、_、.、*保持不变 字符的每个字节以%XX表示（十六进制） 因为本质上编码是将bit解释为正确的信息（用户正确的目的传达给服务器），只要前后端商量好使用的编码方式即可（可以直接通过js对字符进行编码，但通常来说还是使用URL编码较为广泛，没必要自己特立独行的使用奇怪的编码方式）\nBase64 Base64编码可以把任意长度的二进制数据变为纯文本，且只包含A～Z、a～z、0~9、+、/、=这些字符。\nBase64编码的方式：\n将3字节的二进制数据按6bit为一组，分为四组 四组分别用四个int整数来表示 然后查表，把int整数用对应的字符进行表示 得到编码后的字符串 因为6位整数的范围总是0～63，所以，能用64个字符表示：字符A～Z对应索引0～25，字符a～z对应索引26～51，字符0～9对应索引52~61，最后两个索引62、63分别用字符+和/表示。\n如果编码的时候不是3的整数倍，那就在最后补0x00，补了一个0x00就在最后添加一个=，补了两个就添加两个==\n二、Hash算法 hash算法的本质是通过hash函数直接将数据（可以是任意格式的数据，只要函数支持）计算后得到一串规定好的字符串（通常是计算得到一串固定长度的bit数据，用十六进制对应的字符串表示）\nhash函数需要保证是幂等的，不管数据的经过多少次运算得到的hash值应该是相等的。\n同时hash函数应该保证hash碰撞的概率尽可能低、不能猜测输出（输入稍加改变，结果就将完全不同，不能有规律的被猜测输入是什么）。\n常见的hash函数有一下几种：\n算法 输出长度（位） 输出长度（字节） MD5 128 bits 16 bytes SHA-1 160 bits 20 bytes RipeMD-160 160 bits 20 bytes SHA-256 256 bits 32 bytes SHA-512 512 bits 64 bytes MD5在短时间内是可以破解的，现在已经不安全了，用于文件校验是没有问题的，但是用来加密已经不够安全。\n用处 常见的用处是对计算文件、软件等信息的hash码，较为常见的是使用MD5，在下载到软件后使用对应的hash算法计算其hash值和官网提供的hash值进行比对就知道下载到的数据是否有被篡改了。 另一个重要用途是存储用户口令。如果直接将用户的原始口令存放到数据库中，会产生极大的安全风险： 数据库管理员能够看到用户明文口令； 数据库数据一旦泄漏，黑客即可获取用户明文口令。 使用hash口令的时候需要防止彩虹表攻击，因为黑客在得到hash值后很难倒推原文，但是他们提前有一张表里面记录了常见口令的hash码，所以如果使用了常见口令时可以很快的匹配到结果，因此不要使用较为简单的密码。\n此外还有一个方法就是加盐（salt），在用户口令的后添加随机数，使得用户的密码变得复杂，使得黑客无法使用彩虹表进行倒推。\nHmac Hmac算法是一种基于密钥的消息认证码算法，全称是Hash-based Message Authentication Code，是一种更安全的消息摘要算法。\nHmac算法总是和某种哈希算法配合起来用的。例如，我们使用MD5算法，对应的就是HmacMD5算法，它相当于“加盐”的MD5。因此，HmacMD5可以看作带有一个安全的key的MD5。使用HmacMD5而不是用MD5加salt，有如下好处：\nHmacMD5使用的key长度是64字节，更安全； Hmac是标准算法，同样适用于SHA-1等其他哈希算法； Hmac输出和原有的哈希算法长度一致。 Hmac算法定义：关于Hmac算法的更多内容可以参看这篇博客\nHMAC(k,m)=H(k’⊕opad,H(k’⊕ipad,m))\n其中：\nH 为密码Hash函数（如MD5或SHA-2），能够对明文进行分组循环压缩； k 为密钥（secret key）； m 为要认证的消息； k’ 是从原始密钥 k 导出的另一个密钥（如果 k 短于散列函数的输入块大小，则向右填充零；如果比该块大小更长，则对 k 进行散列） ipad 内部填充（0x5C5C5C…5C5C，一段十六进制常量）； opad 外部填充（0x363636…3636，一段十六进制常量） 步骤如上图所示（引用了博客中的图片），具体步骤如下：\n在密钥k后面添加0，或者对密钥k用H（Hash函数）进行处理，创建一个字长为B的字符串（B为Hash函数的明文分组长度）； 将上一步生成的B字长的字符串ipad做异或运算； 将数据流m填充至第二步的结果字符串中； 用H作用于第三步生成的数据流； 将第一步生成的B字长字符串与opad做异或运算； 再将第四步的结果填充进第五步的结果中； 用H作用于第六步生成的数据流，输出最终结果。 密匙问题：如何在使用认证方法的双方确认密匙的可靠性（不被第三者攻击或者得到），可以使用非对称加密进行密匙的传输（在数学上被验证可靠的、不会被攻击的）。\n三、对称加密 对称加密就是使用密匙然后利用算法直接对内容进行加密和解密，常见的对称加密方式有这几种：\n算法 密钥长度 工作模式 填充模式 DES 56/64 ECB/CBC/PCBC/CTR/\u0026hellip; NoPadding/PKCS5Padding/\u0026hellip; AES 128/192/256 ECB/CBC/PCBC/CTR/\u0026hellip; NoPadding/PKCS5Padding/PKCS7Padding/\u0026hellip; IDEA 128 ECB PKCS5Padding/PKCS7Padding/\u0026hellip; 对称加密的特点：\n运算速度快 密钥必须保密 无法做到安全的密钥交换 密码强度取决于密匙的长度 四、非对称加密 密匙交换算法 在不安全的信道上传递加密文件是没有问题的，因为黑客拿到加密文件没有用。但是，如何如何在不安全的信道上安全地传输密钥？要解决这个问题，密钥交换算法即DH算法：Diffie-Hellman算法应运而生。\nDH算法交换密钥过程：\n甲首先选择一个素数p，例如97，底数g是p的一个原根，例如5；随机数a，例如123；然后计算A = g ^ a mod p，结果是34，然后，甲发送p＝97，g=5，A=34给乙（隐藏了a的值）； 乙方收到后，也选择一个随机数b，例如456；然后计算B = g ^ b mod p，结果是75，乙再同时计算s = A ^ b mod p，结果是22； 乙把计算的B=75发给甲，甲计算s ＝ B ^ a mod p，计算结果与乙算出的结果一样，都是22。 结果数学计算验证得到的S，在甲和乙中计算出的结果是相同的，并且在现实使用中使用的素数是非常大的，虽然S的计算公式中g、p、A、B是已知的，但是仍然无法倒推出S的。\na为甲的私钥，A为甲的共钥。b为乙的私钥，B为乙的共钥。\n素数P、底数g是提前约定好的，共钥与私钥是成对的，使用提前约定好的P确定自己的私钥后就可以计算出自己的共钥给别人；别人用同样的方法计算出共钥和私钥，现在只要拿着别人的共钥和自己的私钥进行计算就可以得到真正的密钥，别人拿着你的共钥也可以计算得到和你一样的密钥，此时你俩就可以进行机密通话了\n非对称加密 非对称加密就是使用DH算法的方式，非对称加密的一个最大问题是：速度慢。\n为了解决这一问题方法是通过非对称加密传递对称加密的密匙，然后双方使用对称加密进行消息的传递。\n五、签名算法 签名算法是非对称加密算法的逆运用，通常是使用共钥对数据进行加密，然后可以通过私钥进行解密。\n但是签名算法是用私钥对数据加密，那这时候所有人都可以使用公钥进行解密，签名算法的目的就是使所有人都拿到这个用户想要公开的东西，并且确保这个东西的正确性。\n通常的运用常见是对传输文件（原始消息）的hash值进行签名，对签名进行解密就是用共钥解密，然后把解密后的hash与原始消息的hash值进行对比。如果有人对消息进行更改的时候两次的hash值是对不上的（破坏者改变了原始数据，并且更新hash，但是没有原始发送者的私钥无法再次进行加密，接受者使用发送者的公钥进行解密得到的与得到数据的hash是对不上的，那么数据就被修改了）\n六、数字证书 摘要算法用来确保数据没有被篡改，非对称加密算法可以对数据进行加解密，签名算法可以确保数据完整性和抗否认性，把这些算法集合到一起，并搞一套完善的标准，这就是数字证书。\n因此，数字证书就是集合了多种密码学算法，用于实现数据加解密、身份认证、签名等多种功能的一种安全标准。\n数字证书可以防止中间人攻击，因为它采用链式签名认证，即通过根证书（Root CA）去签名下一级证书，这样层层签名，直到最终的用户证书。而Root CA证书内置于操作系统中，所以，任何经过CA认证的数字证书都可以对其本身进行校验，确保证书本身不是伪造的。\n我们在上网时常用的HTTPS协议就是数字证书的应用。浏览器会自动验证证书的有效性。\n","permalink":"https://jinchaojjj.github.io/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/","summary":"加密算法 一、编码算法 编码算法是将二进制（bit）转化为字符（例如a、中等）的过程，这种编码称为字符编码。 常见的字符编码有：ASCII、UTF","title":"加密算法"},{"content":"Java基本语法 1. 注释 Java中存在三种注释：单行注释、多行注释、文档注释\n单行注释采用//的方式进行，在本行中的所有内容在编译时都将忽略 多行注释采用/* 内容 */的方式进行，在中间的部分都认为是注释，通常用于注释多行代码 文档注释采用/** 内容 */的方式，一般在类上、方法上使用，其中可以html语法，并且在生成Java开发文档时将自动将注释部分作为文档中的内容 在开发过程中多写注释是一个好习惯，当代码量非常巨大的时候，往往注释可以很方便的告知使用者类、方法的具体含义，以此减少沟通成本、提高系统的开发效率\n1 2 3 4 5 6 7 8 9 10 11 // 单行注释 /* * 多行注释 */ /** * 文档注释 * \u0026lt;p\u0026gt; 可以采用html格式 * @author King */ 2. 标识符和关键字 标识符就是在Java程序中设置的各种类、方法、变量等的名字，同时还有一些标识符例如if、for等是Java已经赋予了特殊含义的标识符称为关键字。各种关键字有哪些可以在官网上查看：官网\n3. 基本数据类型以及包装类 八大基本数据类型：boolean、byte、char、short、int、long、floet、double\n对应的包装类：Boolean、Byte、Character、Short、Integer、Long、Float、Double\n4. 类型转换和判断 类型转化分为两种方式：隐式类型转化和强制类型转化\n隐式类型转化 在Java基础数据类型中byte -\u0026gt; short -\u0026gt; char -\u0026gt; int -\u0026gt; long -\u0026gt; float -\u0026gt; double可以进行隐式的类型转化，前面的类型可以直接赋值给后面的类型 基本数据类型可以与包装类互相转化 子类对象可以赋值给父类对象使用 强制类型转化 基本数据类型从大类型到小类型的转换，需要使用强制转换符。在 Java 中，强制类型转换的格式为 (type)value 类对象也可以采用这种方法进行强制类型转换，通常是某些方法返回值是Object类型此时需要强制类型转换 类型判断 可以使用 instanceof 运算符来判断一个对象是否为一个类的实例。instanceof 运算符通过返回一个布尔值来指出，这个对象是否是这个特定类或者是它的子类的一个实例。\ninstanceof 运算符的语法格式为：object instanceof class，其中 object 是要测试的对象，class 是类或接口类型。如果 object 是 class 的一个实例，则 instanceof 运算符返回 true；否则返回 false\n5. 变量、常量和作用域 作用域根据变量定义时的外侧的大括号进行判断。\n6. 基本运算符 自增自减运算符（++、--） 自增、自减运算符可以用于整型数据以及浮点数据上，其中也包括char类型。\n++ 位于变量名之前，则优先运算++的值，并将结果用于外部等式的运算。\n若位于变量名之后，则优先进行外部等式的运算，在计算完成后变量再进行加减计算。\n1 2 3 4 5 6 7 8 9 int a = 5; int b = a++; System.out.println(a); System.out.println(b); System.out.println(--a); // 6 // 5 // 5 位移运算符 位移运算法有\u0026gt;\u0026gt;\u0026gt; 、\u0026gt;\u0026gt; 和 \u0026lt;\u0026lt; 三种，操作都是针对二进制数，同时只对整型类型有效。\n移位操作符实际上支持的类型只有int和long，编译器在对short、byte、char类型进行移位前，都会将其转换为int类型再操作\n对于int类型当位移次数大于32次时会首先对位移数向32求余，类似于a \u0026gt;\u0026gt;\u0026gt; 33等价于a \u0026gt;\u0026gt;\u0026gt; 1，对于long类型是向64求余。其中\u0026gt;\u0026gt;在位移时会按照有符号的方式进行补位，而\u0026gt;\u0026gt;\u0026gt;是直接补0。\n1 2 3 4 5 6 7 int a = 5; // 0000 0101 System.out.println(a \u0026gt;\u0026gt; 1);// 0000 0010 = 2 System.out.println(a \u0026lt;\u0026lt; 1);// 0000 1010 = 10 System.out.println(-5 \u0026gt;\u0026gt;\u0026gt; 1); //1111 1111 1111 1111 1111 1111 1111 1010 = -5 //0111 1111 1111 1111 1111 1111 1111 1101 = 2147483645 System.out.println(5 \u0026gt;\u0026gt;\u0026gt; 1);// 2 位运算 与\u0026amp;：1010 \u0026amp; 0001 = 0000 或|：1010 | 0001 = 1011 非~：~0001 = 1110 异或^：1010 ^ 1001 = 0011 同或：在Java中并没有同或的实现，但是可以通过先异或再取反的方式实现：~ (1010 ^ 1001) = 1100或者(1010 ^ 1001) ^ -1 = 1100；第二种方法中的-1是对应数据类型的-1，idea也提示两种方法的作用是相同的，建议还是使用第一种 Math Java中的Math类提供了很多有用的方法来执行基本数学运算。以下是一些常用的方法：\nabs()：返回一个数的绝对值。 ceil()：返回大于或等于参数的最小double值，等于一个整数。 floor()：返回小于或等于参数的最大double值，等于一个整数。 max()：返回两个参数中的最大值。 min()：返回两个参数中的最小值。 pow()：返回第一个参数的第二个参数次幂。 random()：返回一个随机数。 round()：返回一个四舍五入的整数。 7. 包结构 主要涉及到的是packing关键词。 8. 顺序结构 9. if 10. switch 11. while 12. for 13. foreach 14. break、continue 15. 方法 16. 命令行的参数传递 当你使用Java命令行来运行程序时，如果在后面带上参数，Java的虚拟机就直接把这些参数存放到args数组中了，完成了命令行传参。\n例如，你可以在命令行中输入以下命令来运行一个名为Main的Java类，并传递一个参数：java Main arg1\n在Main类中，你可以通过以下方式访问该参数：\n1 2 3 public static void main(String[] args) { System.out.println(args[0]); } 这将输出：arg1\n17. 可变参数 1 2 3 4 5 public static void main(String[] args) { } public static void main(String... args) { } 上述两种传参数方式是相同的，使用第二种时会在编译阶段重新封装为第一种。因此在使用可变参数的时候有以下几种限制：\n一个方法的形参中只能有一个可变参数 可变参数必须是最后一个形参 18. 数组 19. Arrays Java中的Arrays类提供了很多有用的方法来操作数组。以下是一些常用的方法：\nfill()：给数组赋值。 sort()：对数组进行排序。 equals()：比较两个数组是否相等。 binarySearch()：对排序好的数组进行二分查找。 asList()：将数组转换为List。 copyOf()：复制数组。 copyOfRange()：复制数组的一部分。 toString()：将数组转换为字符串。 20. 类和对象 21. 构造函数 与类同名\n22. 继承 extends、implements\n23. super 24. 重写 继承后将父类的方法重新实现，根据里氏替换原则这是不建议的。\n25. static 26. 抽象类 abstract\n27. 接口 interface\n28. 内部类 Java中的内部类分为四种：成员内部类、静态内部类、局部内部类和匿名内部类。\n成员内部类：定义在一个类的内部，且在该类的外部可以通过实例化对象来访问。 静态内部类：定义在一个类的内部，且在该类的外部可以直接通过“外部类.静态内部类”来访问。 局部内部类：定义在方法或作用域内，且只能在该方法或作用域内使用。 匿名内部类：没有名字的局部内部类。 下面是一些例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 public class Outer { private int x = 10; // 成员内部类 class Inner { void print() { System.out.println(\u0026#34;x = \u0026#34; + x); } } } public class Outer { private static int x = 10; // 静态内部类 static class Inner { void print() { System.out.println(\u0026#34;x = \u0026#34; + x); } } } public class Outer { public void method() { // 局部内部类 class Inner { void print() { System.out.println(\u0026#34;Hello World!\u0026#34;); } } Inner inner = new Inner(); inner.print(); } } public class Outer { public void method() { new Thread( // 匿名内部类 new Runnable() { @Override public void run() { System.out.println(\u0026#34;Hello World!\u0026#34;); } }).start(); } } 29. 异常 在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类:\nException :程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。 Error ：Error 属于程序无法处理的错误 ，我们没办法通过 catch 来进行捕获 。例如 Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。 Checked Exception Checked Exception 即受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 catch或者throws 关键字处理的话，就没办法通过编译。\n除了RuntimeException及其子类以外，其他的Exception类及其子类都属于受检查异常 。常见的受检查异常有： IO 相关的异常、ClassNotFoundException 、SQLException\n所有的异常都继承自Exception类，若继承自RuntimeException则是不受检查的，若直接继承自Exception则是受检查的异常。\n异常可以在发生时告知发生的原因和内容。\nThrowable 类常用方法有哪些？ String getMessage(): 返回异常发生时的简要描述 String toString(): 返回异常发生时的详细信息 String getLocalizedMessage(): 返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage()返回的结果相同 void printStackTrace(): 在控制台上打印 Throwable 对象封装的异常信息 try-catch-finally 如何使用？ try块 ： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。 catch块 ： 用于处理 try 捕获到的异常。 finally 块 ： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。 在对象实现AutoCloseable接口的情况下，可以使用 try-with-resources语法进行简化，不必再使用finally语句进行关闭操作，不过该部分执行的也只是关闭操作，如果需要执行额外的操作还是需要使用finally。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // try-catch-finally InputStream stream = null; try { stream = new FileInputStream(\u0026#34;test.txt\u0026#34;); } catch (FileNotFoundException e) { throw new RuntimeException(e); } finally { try { stream.close(); } catch (IOException e) { throw new RuntimeException(e); } } // try-with-resources 这看起来就清爽很多了 // 不过使用的前提是要实现Closeable接口 try(InputStream stream1 = new FileInputStream(\u0026#34;test.txt\u0026#34;)){ } catch (FileNotFoundException e) { throw new RuntimeException(e); } catch (IOException e) { throw new RuntimeException(e); } 30. 反射 何谓反射？ 如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性。\n反射的优缺点？ 反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。\n不过，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。\n优点 ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利\n缺点 ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的\n使用反射机制主要分为两部分：获取Class对象、同Class对象对对象进行操作，下面会根据这两部分进行介绍\n反射的应用场景？ 像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。但是！这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。\n这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。\n比如下面是通过 JDK 实现动态代理的示例代码，其中就使用了反射类 Method 来调用指定的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class DebugInvocationHandler implements InvocationHandler { /** * 代理类中的真实对象 */ private final Object target; public DebugInvocationHandler(Object target) { this.target = target; } public Object invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException { System.out.println(\u0026#34;before method \u0026#34; + method.getName()); Object result = method.invoke(target, args); System.out.println(\u0026#34;after method \u0026#34; + method.getName()); return result; } } 另外，像 Java 中的一大利器 注解 的实现也用到了反射。\n为什么你使用 Spring 的时候 ，一个@Component注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 @Value注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？\n这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。\n获取Class对象对四种方法 通过具体的类获取对象\n1 Class\u0026lt;?\u0026gt; clazz = TargetObject.Class; 通过Class.forName()方法传入类的全路径获取\n1 Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;cn.king.TargetObject\u0026#34;); 通过类对象实例的.getClass()方法获取\n1 2 TargetObject object = new TargetObject(); Class\u0026lt;?\u0026gt; clazz = object.getClass(); 通过类加载器传入类路径获取\n1 ClassLoader.getSystemClassLoader().loadClass(\u0026#34;cn.king.TargetObject\u0026#34;); 上述是四种获取Class对象的方法，其中前面两种方法都会进行类对象的初始化（静态代码块和静态对象的初始化），第三种已经创建了对象，此时是一定会进行初始化的，但是第四种获取的方式不会引起初始化，这是需要值得注意的，在有些特殊的场景下需要注意。\n反射的基本操作 这部分主要是学习Class类中所具有的方法，一个类中主要有以下几部分组成：类成员变量、方法、类本身\n1. Class类 获得类相关的方法 方法 用途 asSubclass(Class clazz) 把传递的类的对象转换成代表其子类的对象 Cast 把对象转换成代表类或是接口的对象 getClassLoader() 获得类的加载器 getClasses() 返回一个数组，数组中包含该类中所有公共类和接口类的对象 getDeclaredClasses() 返回一个数组，数组中包含该类中所有类和接口类的对象 forName(String className) 根据类名返回类的对象 getName() 获得类的完整路径名字 newInstance() 创建类的实例 getPackage() 获得类的包 getSimpleName() 获得类的名字 getSuperclass() 获得当前类继承的父类的名字 getInterfaces() 获得当前类实现的类或是接口 获得类中属性相关的方法 方法 用途 getField(String name) 获得某个公有的属性对象 getFields() 获得所有公有的属性对象 getDeclaredField(String name) 获得某个属性对象 getDeclaredFields() 获得所有属性对象 获得类中注解相关的方法 方法 用途 getAnnotation(Class annotationClass) 返回该类中与参数类型匹配的公有注解对象 getAnnotations() 返回该类所有的公有注解对象 getDeclaredAnnotation(Class annotationClass) 返回该类中与参数类型匹配的所有注解对象 getDeclaredAnnotations() 返回该类所有的注解对象 获得类中构造器相关的方法 方法 用途 getConstructor(Class\u0026hellip;\u003c?\u003e parameterTypes) 获得该类中与参数类型匹配的公有构造方法 getConstructors() 获得该类的所有公有构造方法 getDeclaredConstructor(Class\u0026hellip;\u003c?\u003e parameterTypes) 获得该类中与参数类型匹配的构造方法 getDeclaredConstructors() 获得该类所有构造方法 获得类中方法相关的方法 方法 用途 getMethod(String name, Class\u0026hellip;\u003c?\u003e parameterTypes) 获得该类某个公有的方法 getMethods() 获得该类所有公有的方法 getDeclaredMethod(String name, Class\u0026hellip;\u003c?\u003e parameterTypes) 获得该类某个方法 getDeclaredMethods() 获得该类所有方法 类中其他重要的方法 方法 用途 isAnnotation() 如果是注解类型则返回true isAnnotationPresent(Class\u0026lt;? extends Annotation\u0026gt; annotationClass) 如果是指定类型注解类型则返回true isAnonymousClass() 如果是匿名类则返回true isArray() 如果是一个数组类则返回true isEnum() 如果是枚举类则返回true isInstance(Object obj) 如果obj是该类的实例则返回true isInterface() 如果是接口类则返回true isLocalClass() 如果是局部类则返回true isMemberClass() 如果是内部类则返回true 2. Field类 Field代表类的成员变量（成员变量也称为类的属性）。\n方法 用途 equals(Object obj) 属性与obj相等则返回true get(Object obj) 获得obj中对应的属性值 set(Object obj, Object value) 设置obj中对应属性值 3. Method类 Method代表类的方法。\n方法 用途 invoke(Object obj, Object\u0026hellip; args) 传递object对象及参数调用该对象对应的方法 4. Constructor类 Constructor代表类的构造方法。\n方法 用途 newInstance(Object\u0026hellip; initargs) 根据传递的参数创建类的对象 31. 多线程 32. 动态代理 33. IO介绍 一个程序可以分为内部与外部，内部通常是这个程序在CPU、内存上运行的，而外部可以是显示器、控制台、硬盘、其他电脑等等，在冯诺依曼的计算机结构中内部就是运算器、控制器、存储器，外部是输入设备与输出设备。将内部的数据输出到外部就是Output，将外部的数据输入内部就是Input。\n将程序分为内部与外部是我自己的理解，其他人一般不会这么将，那为什么要将程序分为内部与外部呢？其实计算机（我们能接触到的设备）本质上就是处理数据的设备，如果只是将数据在程序内进行处理那么得到的这些数据是毫无作用的（因为你看不到这些数据），所以计算得到的数据需要通过Output展现在我们面前（我们一般看见的显示器、控制台、窗口都是通过Output实现的），有时候程序的运行以来外部的数据此时需要通过Input将数据给到程序。\n分类 在UNIX系统中IO模型一共分为五种：同步阻塞IO、同步非阻塞IO、IO多路复用、信号驱动IO、异步IO\n在Java中有三种常见的IO\nBIO BIO- blocking IO 属于同步阻塞IO，同步阻塞IO模型中程序发起read调用后会一直阻塞，直到数据被拷贝到内存中。\nNIO (Non-blocking/New I/O) ava 中的 NIO 于 Java 1.4 中引入，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它是支持面向缓冲的，基于通道的 I/O 操作方法。 对于高负载、高并发的（网络）应用，应使用 NIO 。\nJava 中的 NIO 可以看作是 I/O 多路复用模型。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。\n同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。\n相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。\n但是，这种 IO 模型同样存在问题：应用程序不断进行 I/O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。\nIO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -\u0026gt; 用户空间）还是阻塞的。\nAIO (Asynchronous I/O) AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。\n异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。\nIO IO 即 Input/Output，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。\nJava IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。\nInputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。 OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。 InputStream用于从源头（通常是文件）读取数据（字节信息）到内存中，java.io.InputStream抽象类是所有字节输入流的父类。\n需要注意的是InputStream、Reader、OutputStream、Writer四种类都是抽象类无法直接使用。\n其中四种类最常用的子类是FileInputStream、FileReader、FileOutputStream、FileWriter\n字节流 InputStream（字节输入流） InputStream 常用方法 ：\nread() ：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 -1 ，表示文件结束。 read(byte b[ ]) : 从输入流中读取一些字节存储到数组 b 中。如果数组 b 的长度为零，则不读取。如果没有可用字节读取，返回 -1。如果有可用字节读取，则最多读取的字节数最多等于 b.length ， 返回读取的字节数。这个方法等价于 read(b, 0, b.length)。 read(byte b[], int off, int len) ：在read(byte b[ ]) 方法的基础上增加了 off 参数（偏移量）和 len参数（要读取的最大字节数）。 skip(long n) ：忽略输入流中的 n 个字节 ,返回实际忽略的字节数。 available() ：返回输入流中可以读取的字节数。 close() ：关闭输入流释放相关的系统资源。 从 Java 9 开始，InputStream 新增加了多个实用的方法：\nreadAllBytes() ：读取输入流中的所有字节，返回字节数组。 readNBytes(byte[] b, int off, int len) ：阻塞直到读取 len 个字节。 transferTo(OutputStream out) ： 将所有字节从一个输入流传递到一个输出流。 FileInputStream 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。\nFileInputStream 代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 try (InputStream fis = new FileInputStream(\u0026#34;input.txt\u0026#34;)) { System.out.println(\u0026#34;Number of remaining bytes:\u0026#34; + fis.available()); int content; long skip = fis.skip(2); System.out.println(\u0026#34;The actual number of bytes skipped:\u0026#34; + skip); System.out.print(\u0026#34;The content read from file:\u0026#34;); while ((content = fis.read()) != -1) { System.out.print((char) content); } } catch (IOException e) { e.printStackTrace(); } OutputStream（字节输出流） OutputStream用于将数据（字节信息）写入到目的地（通常是文件），java.io.OutputStream抽象类是所有字节输出流的父类。\nOutputStream 常用方法 ：\nwrite(int b) ：将特定字节写入输出流。 write(byte b[]) : 将数组b 写入到输出流，等价于 write(b, 0, b.length) 。 write(byte[] b, int off, int len) : 在write(byte b[ ]) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字节数）。 flush() ：刷新此输出流并强制写出所有缓冲的输出字节。 close() ：关闭输出流释放相关的系统资源。 FileOutputStream 是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。\nFileOutputStream 代码示例：\n1 2 3 4 5 6 try (FileOutputStream output = new FileOutputStream(\u0026#34;output.txt\u0026#34;)) { byte[] array = \u0026#34;King\u0026#34;.getBytes(); output.write(array); } catch (IOException e) { e.printStackTrace(); } 字符流 不管是文件读写还是网络发送接收，信息的最小存储单元都是字节。 那为什么 I/O 流操作要分为字节流操作和字符流操作呢？\n个人认为主要有两点原因：\n字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时。 如果我们不知道编码类型就很容易出现乱码问题。 乱码问题这个很容易就可以复现，我们只需要将上面提到的 FileInputStream 代码示例中的 input.txt 文件内容改为中文即可，原代码不需要改动。\n因此，I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。字符流默认采用的是 Unicode 编码，我们可以通过构造方法自定义编码。\nReader（字符输入流） Reader用于从源头（通常是文件）读取数据（字符信息）到内存中，java.io.Reader抽象类是所有字符输入流的父类。\nReader 用于读取文本， InputStream 用于读取原始字节。\nReader 常用方法 ：\nread() : 从输入流读取一个字符。 read(char[] cbuf) : 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中，等价于 read(cbuf, 0, cbuf.length) 。 read(char[] cbuf, int off, int len) ：在read(char[] cbuf) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字符数）。 skip(long n) ：忽略输入流中的 n 个字符 ,返回实际忽略的字符数。 close() : 关闭输入流并释放相关的系统资源。 InputStreamReader 是字节流转换为字符流的桥梁，其子类 FileReader 是基于该基础上的封装，可以直接操作字符文件。InputStreamReader实质是对InputStream的一次封装，根据不同的编码方式将字节转化为字符。从这也可以看出真正具备读取、书写能力的是字节流，字符流是对字节流的一层封装使得流更加好用了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 字节流转换为字符流的桥梁 public class InputStreamReader extends Reader { public InputStreamReader(InputStream in) { // 构造时就需要一个InputStream ... 省略 } ... 省略 } // 用于读取字符文件 public class FileReader extends InputStreamReader { public FileReader(String fileName) throws FileNotFoundException { super(new FileInputStream(fileName));// 创建了一个InputStream传递给InputStreamReader的构造函数 } ... 省略 } FileReader 代码示例：FileReader继承自InputStreamReader，使用InputStreamReader将字节转化为字符的能力进行字符的读取。\n1 2 3 4 5 6 7 8 9 10 11 try (FileReader fileReader = new FileReader(\u0026#34;input.txt\u0026#34;);) { int content; long skip = fileReader.skip(3); System.out.println(\u0026#34;The actual number of bytes skipped:\u0026#34; + skip); System.out.print(\u0026#34;The content read from file:\u0026#34;); while ((content = fileReader.read()) != -1) { System.out.print((char) content); } } catch (IOException e) { e.printStackTrace(); } Writer（字符输出流） Writer用于将数据（字符信息）写入到目的地（通常是文件），java.io.Writer抽象类是所有字符输出流的父类。\nWriter 常用方法 ：\nwrite(int c) : 写入单个字符。 write(char[] cbuf) ：写入字符数组 cbuf，等价于write(cbuf, 0, cbuf.length)。 write(char[] cbuf, int off, int len) ：在write(char[] cbuf) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字符数）。 write(String str) ：写入字符串，等价于 write(str, 0, str.length()) 。 write(String str, int off, int len) ：在write(String str) 方法的基础上增加了 off 参数（偏移量）和 len 参数（要读取的最大字符数）。 append(CharSequence csq) ：将指定的字符序列附加到指定的 Writer 对象并返回该 Writer 对象。 append(char c) ：将指定的字符附加到指定的 Writer 对象并返回该 Writer 对象。 flush() ：刷新此输出流并强制写出所有缓冲的输出字符。 close():关闭输出流释放相关的系统资源。 OutputStreamWriter 是字符流转换为字节流的桥梁，其子类 FileWriter 是基于该基础上的封装，可以直接将字符写入到文件。其中转化的调用不再做介绍了与Reader相同。\n1 2 3 4 5 6 // 字符流转换为字节流的桥梁 public class OutputStreamWriter extends Writer { } // 用于写入字符到文件 public class FileWriter extends OutputStreamWriter { } FileWriter 代码示例：\n1 2 3 4 5 try (Writer output = new FileWriter(\u0026#34;output.txt\u0026#34;)) { output.write(\u0026#34;你好，我是King。\u0026#34;); } catch (IOException e) { e.printStackTrace(); } InputStreamReader、OutputStreamWriter两者也被称为转换流，这两个流是Reader和Writer实现的基础。下面两者的作用是相同的（源码中也是这么实现的）并且InputStreamReader就是Reader的子类，后面在外层嵌套装饰流时作为Reader（不要弄错了）。\n1 2 FileReader reader = new FileReader(\u0026#34;XXX\u0026#34;); InputStreamReader reader2 = new InputStreamReader(new FileInputStream(\u0026#34;XXX\u0026#34;)); 并且存在的字符流都存在对应的字节流（基本都是通过字节流实现的）。\n装饰流 FilterInputStream、FilterOutputStream、FilterReader、FilterWriter\n这四种流分别继承自上述的四种流，知道装饰者模式的朋友对这四个流应该就非常熟悉了，这四种流的作用也十分简单：就是为基础流提供扩展时以这些流作为基础。这四个基本的装饰流没有提供任何额外的功能，继承自对应的流，并且重写了对应的方法，但是方法中没有进行过多的处理，之间调用了四种基础流的内容。\n用法就是在创建装饰流时用已经创建好的基础流或者基础流的子类作为对象进行传入，装饰流相当对基础流的方法进行了扩展。下面要讲的缓冲流、打印流、数据流、对象流都是继承自这四种装饰流。\n其实最基础的功能均由基础的四种流提供。\n缓冲流 缓冲流的主要作用就是减少IO次数以提高性能，在大数据流读取的环境下建议使用。\n字节缓冲流 IO 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取/写入多个字节，从而避免频繁的 IO 操作，提高流的传输效率。\n字节缓冲流这里采用了装饰器模式来增强 InputStream 和OutputStream子类对象的功能。\n举个例子，我们可以通过 BufferedInputStream（字节缓冲输入流）来增强 FileInputStream 的功能。\n1 2 // 新建一个 BufferedInputStream 对象 BufferedInputStream bufferedInputStream = new BufferedInputStream(new FileInputStream(\u0026#34;input.txt\u0026#34;)); 在读取大文件时建议使用缓冲流套一层，效果会比较好。\nBufferedInputStream（字节缓冲输入流） BufferedInputStream 从源头（通常是文件）读取数据（字节信息）到内存的过程中不会一个字节一个字节的读取，而是会先将读取到的字节存放在缓存区，并从内部缓冲区中单独读取字节。这样大幅减少了 IO 次数，提高了读取效率。BufferedInputStream 内部维护了一个缓冲区，这个缓冲区实际就是一个字节数组。\n缓冲区的大小默认为 8192 字节，可以通过 BufferedInputStream(InputStream in, int size) 这个构造方法来指定缓冲区的大小。\nBufferedOutputStream（字节缓冲输出流） BufferedOutputStream 将数据（字节信息）写入到目的地（通常是文件）的过程中不会一个字节一个字节的写入，而是会先将要写入的字节存放在缓存区，并从内部缓冲区中单独写入字节。这样大幅减少了 IO 次数，提高了读取效率\n1 2 3 4 5 6 try (BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\u0026#34;output.txt\u0026#34;))) { byte[] array = \u0026#34;King\u0026#34;.getBytes(); bos.write(array); } catch (IOException e) { e.printStackTrace(); } 类似于 BufferedInputStream ，BufferedOutputStream 内部也维护了一个缓冲区，并且，这个缓存区的大小也是 8192 字节。\n字符缓冲流 BufferedReader （字符缓冲输入流）和 BufferedWriter（字符缓冲输出流）类似于 BufferedInputStream（字节缓冲输入流）和BufferedOutputStream（字节缓冲输入流），内部都维护了一个字节数组作为缓冲区。不过，前者主要是用来操作字符信息。\n打印流 这里需要介绍的两个打印流就是我们常用的Scanner与PrintStream。\nScanner 这个类更像是一个工具类，其本质就是在初始化时接受一个InputStream对象，然后从这个对象中接受数据，并且提供了非常多的方法使你读取对象中的数据，我们常常将System.in对象传入，这个是控制台我们并不能主动创建，是通过c++实现的，我们只能从System类中取出来用。\n想要读取控制台的数据其实还可以使用其他方式：\n1 2 3 4 byte[] x = new byte[10]; BufferedInputStream inputStream1 = new BufferedInputStream(System.in); inputStream1.read(x); System.in.read(x); 只不过通过这种方法读取的数据是byte，需要自己进行类型转化十分的不方便，而Scanner就是封装好了各种类型转化的方法咱们直接拿来用就好。\nPrintStream 本质是个装饰类，需要设置真正读取数据的OutputStream对象，System.out中的这个对象是通过C++实现的可以直接拿来用。通过反射我们可以看到底层还是通过FileOutputStream实现，但是在FileOutputStream是使用了FileDescriptor进行实现，该对象已经通过默认句柄封装好了，还有兴趣往下探索的可以看jvm的源码。\nPrintStream存在自动刷新机制，例如当向PrintStream流中写入一个字节数组后自动调用flush()方法。PrintStream也永远不会抛出异常，而是使用内部检查机制checkError()方法进行错误检查。最方便的是，它能够格式化任意的类型，将它们以字符串的形式写入到输出流。\n数据流 DataInputStream和DataOutputStream可以直接将字节转化为需要的类型，通常是基本类型。\n对象流 ObjectOutputStream、ObjectOInputStream通常用于序列化与反序列化（Java原生的序列号与反序列化）。\nNIO 缓冲区 Buffer中共定义了四个变量，用于控制缓冲区内数据的位置：mark-用于标记位置，在读时用到、position-标记现在处在的位置用于存放读取数据、limit-用于现实position的最大位置、capacity-标记缓冲区大小。\nBuffer类是缓冲区的实现，类似于Java中的数组，也是用于存放和获取数据的。但是Buffer相比Java中的数组，功能就非常强大了，它包含一系列对于数组的快捷操作。\nBuffer是一个抽象类，它的核心内容：（除了capacity其余的变量都是可以通过方法直接设置位置的）\n1 2 3 4 5 6 7 8 9 10 public abstract class Buffer { // 这四个变量的关系: mark \u0026lt;= position \u0026lt;= limit \u0026lt;= capacity // 这些变量就是Buffer操作的核心了，之后我们学习的过程中可以看源码是如何操作这些变量的 private int mark = -1; private int position = 0; private int limit; private int capacity; // 直接缓冲区实现子类的数据内存地址（之后会讲解） long address; } 我们来看看Buffer类的子类，包括我们认识到的所有基本类型（除了boolean类型之外）：\nIntBuffer - int类型的缓冲区。\nShortBuffer - short类型的缓冲区。\nLongBuffer - long类型的缓冲区。\nFloatBuffer - float类型的缓冲区。\nDoubleBuffer - double类型的缓冲区。\nByteBuffer - byte类型的缓冲区。\nCharBuffer - char类型的缓冲区。\n缓冲区构造 构造缓冲区有两个方法：\n1 2 3 4 5 6 7 8 public static void main(String[] args) { //创建一个缓冲区不能直接new，而是需要使用静态方法去生成，有两种方式： //1. 申请一个容量为10的int缓冲区 IntBuffer buffer = IntBuffer.allocate(10); //2. 可以将现有的数组直接转换为缓冲区（包括数组中的数据） int[] arr = new int[]{1, 2, 3, 4, 5, 6}; IntBuffer buffer = IntBuffer.wrap(arr); } 下面以IntBuffer为例分别看一下两个方法的内容，其中会用到的类的一个继承关系：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // allocate // IntBuffer public static IntBuffer allocate(int capacity) { if (capacity \u0026lt; 0) throw new IllegalArgumentException(); return new HeapIntBuffer(capacity, capacity); } // HeapIntBuffer HeapIntBuffer(int cap, int lim) { super(-1, 0, lim, cap, new int[cap], 0); } // IntBuffer IntBuffer(int mark, int pos, int lim, int cap, int[] hb, int offset){ super(mark, pos, lim, cap); this.hb = hb; this.offset = offset; } // Buffer Buffer(int mark, int pos, int lim, int cap) { if (cap \u0026lt; 0) throw new IllegalArgumentException(\u0026#34;Negative capacity: \u0026#34; + cap); this.capacity = cap; limit(lim); position(pos); if (mark \u0026gt;= 0) { if (mark \u0026gt; pos) throw new IllegalArgumentException(\u0026#34;mark \u0026gt; position: (\u0026#34; + mark + \u0026#34; \u0026gt; \u0026#34; + pos + \u0026#34;)\u0026#34;); this.mark = mark; } } 上述方法有一点需要注意：这些构造方法的修饰权限是默认的，所以我们无法直接使用构造函数进行创建。\n在IntBuffer方法中创建了数组用于存放缓冲数据，这就是缓冲区的底层实现，然后对刚刚提到的Buffer中的四个标志进行了初始化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // wrap // IntBuffer public static IntBuffer wrap(int[] array) { return wrap(array, 0, array.length); } public static IntBuffer wrap(int[] array, int offset, int length){ try { return new HeapIntBuffer(array, offset, length); } catch (IllegalArgumentException x) { throw new IndexOutOfBoundsException(); } } // HeapintBuffer HeapIntBuffer(int[] buf, int off, int len) { super(-1, off, off + len, buf.length, buf, 0); } 缓冲区写操作 数据的存放包括以下四个方法：\npublic abstract IntBuffer put(int i); - 在当前position位置插入数据，由具体子类实现\npublic abstract IntBuffer put(int index, int i); - 在指定位置存放数据，也是由具体子类实现\npublic final IntBuffer put(int[] src); - 直接存放所有数组中的内容（数组长度不能超出缓冲区大小）\npublic IntBuffer put(int[] src, int offset, int length); - 直接存放数组中的内容，同上，但是可以指定存放一段范围\npublic IntBuffer put(IntBuffer src); - 直接存放另一个缓冲区中的内容\nput操作实际就是在position的位置插入一个数据，然后向后移动一位，并且会检查是否超多了限制limit：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public IntBuffer put(int x) { hb[ix(nextPutIndex())] = x; //这个ix和nextPutIndex()很灵性，我们来看看具体实现 return this; } protected int ix(int i) { return i + offset; //将i的值加上我们之前设定的offset偏移量值，但是默认是0（非0的情况后面会介绍） } final int nextPutIndex() { int p = position; //获取Buffer类中的position位置（一开始也是0） if (p \u0026gt;= limit) //位置肯定不能超过底层数组最大长度，否则越界 throw new BufferOverflowException(); position = p + 1; //获取之后会使得Buffer类中的position+1 return p; //返回当前的位置 }\t第二种put方法就是直接在指定位置写入数据（若原先存在数据也是直接覆盖）\n1 2 3 4 5 6 7 8 9 10 public IntBuffer put(int i, int x) { hb[ix(checkIndex(i))] = x; //这里依然会使用ix，但是会检查位置是否合法 return this; } final int checkIndex(int i) { // package-private if ((i \u0026lt; 0) || (i \u0026gt;= limit)) //插入的位置不能小于0并且不能大于等于底层数组最大长度 throw new IndexOutOfBoundsException(); return i; //没有问题就把i返回 } 第三种put\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public IntBuffer put(int[] src, int offset, int length) { checkBounds(offset, length, src.length); //检查截取范围是否合法，给offset、调用者指定长度、数组实际长度 if (length \u0026gt; remaining()) //接着判断要插入的数据量在缓冲区是否容得下，装不下也不行 throw new BufferOverflowException(); int end = offset + length; //计算出最终读取位置，下面开始for for (int i = offset; i \u0026lt; end; i++) this.put(src[i]); return this; } static void checkBounds(int off, int len, int size) { if ((off | len | (off + len) | (size - (off + len))) \u0026lt; 0) throw new IndexOutOfBoundsException(); } public final int remaining() { //计算并获取当前缓冲区的剩余空间 int rem = limit - position; //最大容量减去当前位置，就是剩余空间 return rem \u0026gt; 0 ? rem : 0; //没容量就返回0 }\t第四种put，方法内会将形参缓冲区position到limit之间的数据存入当前缓冲区，get方法会将position继续向后推！！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public IntBuffer put(IntBuffer src) { if (src == this) throw new IllegalArgumentException(); if (isReadOnly()) throw new ReadOnlyBufferException(); int n = src.remaining(); //给进来的src看看容量 if (n \u0026gt; remaining()) //这里判断当前剩余容量是否小于src容量 throw new BufferOverflowException(); for (int i = 0; i \u0026lt; n; i++) //也是从position位置开始继续写入 put(src.get()); //通过get方法一个一个读取数据出来 return this; } public int get() { return hb[ix(nextGetIndex())]; } final int nextGetIndex() { int p = position; if (p \u0026gt;= limit) throw new BufferUnderflowException(); position = p + 1; return p; } 所以这第四种put方式存在一些陷阱，通过allocate创建缓冲区并且在缓冲区内添加数据后position处在下一个可以添加的位置，limit指向最后，因此这两者中间的数据是还未被添加的默认值0，这时候使用第四种put并不能起到效果，解决方法是在put前flip一下。或者使用wrap进行创建，这种方法创建得到的缓冲区内的默认值是创建时传入的形参，但是几个标记变量的值还是和allocate一样的，当你插入过数据后到底想要什么数据就需要注意了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static void main(String[] args) { IntBuffer src = IntBuffer.allocate(5); for (int i = 0; i \u0026lt; 5; i++) src.put(i); //手动插入数据 IntBuffer buffer = IntBuffer.allocate(10); buffer.put(src); System.out.println(Arrays.toString(buffer.array())); } public final Buffer flip() { limit = position; //修改limit值，当前写到哪里，下次读的最终位置就是这里 position = 0; //position归零 mark = -1; //标记还原为-1 return this; } 缓冲区读操作 前面我们看完了写操作，现在我们接着来看看读操作。读操作有四个方法：\npublic abstract int get(); - 直接获取当前position位置的数据，由子类实现\npublic abstract int get(int index); - 获取指定位置的数据，也是子类实现\npublic IntBuffer get(int[] dst) - 将数据读取到给定的数组中\npublic IntBuffer get(int[] dst, int offset, int length) - 同上，加了个范围\n第一种在上面已经看到过了\n1 2 3 4 5 6 7 8 9 10 11 public int get() { return hb[ix(nextGetIndex())]; } final int nextGetIndex() { int p = position; if (p \u0026gt;= limit) throw new BufferUnderflowException(); position = p + 1; return p; } 第二种\n1 2 3 public int get(int i) { return hb[ix(checkIndex(i))]; //这里依然是使用checkIndex来检查位置是否非法 } 第三四种\n1 2 3 4 5 6 7 8 9 10 11 12 13 public IntBuffer get(int[] dst, int offset, int length) { checkBounds(offset, length, dst.length); //跟put操作一样，也是需要检查是否越界 if (length \u0026gt; remaining()) //如果读取的长度比可以读的长度大，那肯定是不行的 throw new BufferUnderflowException(); int end = offset + length; //计算出最终读取位置 for (int i = offset; i \u0026lt; end; i++) dst[i] = get(); //开始从position把数据读到数组中，注意是在数组的offset位置开始 return this; } public IntBuffer get(int[] dst) { return get(dst, 0, dst.length); //不指定范围的话，那就直接用上面的 } 还能直接获取底层实现的数组\n1 2 3 4 5 6 7 public final int[] array() { if (hb == null) //为空那说明底层不是数组实现的，肯定就没法转换了 throw new UnsupportedOperationException(); if (isReadOnly) //只读也是不让直接取出的，因为一旦取出去岂不是就能被修改了 throw new ReadOnlyBufferException(); return hb; //直接返回hb } 还可以使用mark、reset进行position的跳转\npublic final Buffer mark() - 标记当前位置\npublic final Buffer reset() - 让当前的position位置跳转到mark当时标记的位置\n1 2 3 4 5 6 7 8 9 10 11 public final Buffer mark() { mark = position; return this; } public final Buffer reset() { int m = mark; //存一下当前的mark位置 if (m \u0026lt; 0) //因为mark默认是-1 throw new InvalidMarkException(); position = m; //直接让position变成mark位置 return this; } 缓冲区其他操作 前面我们大致了解了一下缓冲区的读写操作，除了常规的读写操作之外，还有哪些其他的操作：\npublic abstract IntBuffer compact() - 压缩缓冲区，由具体实现类实现\npublic IntBuffer duplicate() - 复制缓冲区，会直接创建一个新的数据相同的缓冲区\npublic abstract IntBuffer slice() - 划分缓冲区，会将原本的容量大小的缓冲区划分为更小的出来进行操作\npublic final Buffer rewind() - 重绕缓冲区，其实就是把position归零，然后mark变回-1\npublic final Buffer clear() - 将缓冲区清空，所有的变量变回最初的状态\n我们先从压缩缓冲区开始看起，它会将整个缓冲区的大小和数据内容变成position位置到limit之间的数据，并移动到数组头部：\n1 2 3 4 5 6 7 8 9 10 11 public IntBuffer compact() { int pos = position(); //获取当前位置 int lim = limit(); //获取当前最大position位置 assert (pos \u0026lt;= lim); //断言表达式，position必须小于最大位置，肯定的 int rem = (pos \u0026lt;= lim ? lim - pos : 0); //计算pos距离最大位置的长度 System.arraycopy(hb, ix(pos), hb, ix(0), rem); //直接将hb数组当前position位置的数据拷贝到头部去，然后长度改成刚刚计算出来的空间 position(rem); //直接将position移动到rem位置 limit(capacity()); //pos最大位置修改为最大容量 discardMark(); //mark变回-1 return this; } 复制缓冲区，原来的改变新创建的缓冲区中的数据也会改变，因为hb用的是一个\n1 2 3 4 5 6 7 8 public IntBuffer duplicate() { //直接new一个新的，但是是吧hb给丢进去了，而不是拷贝一个新的 return new HeapIntBuffer(hb, this.markValue(), this.position(), this.limit(), this.capacity(), offset); } 划分缓冲区，和复制类似都用的是旧的hb\n1 2 3 4 5 6 7 8 9 10 11 public IntBuffer slice() { int pos = this.position(); //获取当前position int lim = this.limit(); //获取position最大位置 int rem = (pos \u0026lt;= lim ? lim - pos : 0); //求得剩余空间 return new HeapIntBuffer(hb, //返回一个新的划分出的缓冲区，但是底层的数组用的还是同一个 -1, 0, rem, //新的容量变成了剩余空间的大小 rem, pos + offset); //可以看到offset的地址不再是0了，而是当前的position加上原有的offset值 } 缓冲区的比较 equals、compateTo都是比较两个缓冲区从当前position开始的内容是否一致。\n只读缓冲区 所有的put方法不能用了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public IntBuffer asReadOnlyBuffer() { return new HeapIntBufferR(hb, //注意这里并不是直接创建了HeapIntBuffer，而是HeapIntBufferR，并且直接复制的hb数组 this.markValue(), this.position(), this.limit(), this.capacity(), offset); } // HeapIntBufferR public IntBuffer put(int x) { throw new ReadOnlyBufferException(); } public IntBuffer put(int i, int x) { throw new ReadOnlyBufferException(); } public IntBuffer put(int[] src, int offset, int length) { throw new ReadOnlyBufferException(); } public IntBuffer put(IntBuffer src) { throw new ReadOnlyBufferException(); } 通道 在传统IO中，我们都是通过流进行传输，数据会源源不断从流中传出；而在NIO中，数据是放在缓冲区中进行管理，再使用通道将缓冲区中的数据传输到目的地。\n通道接口层次 通道的根基接口是Channel，所以的派生接口和类都是从这里开始的，我们来看看它定义了哪些基本功能：\n1 2 3 4 5 6 7 public interface Channel extends Closeable { //通道是否处于开启状态 public boolean isOpen(); //因为通道开启也需要关闭，所以实现了Closeable接口 public void close() throws IOException; } 我们接着来看看它的一些子接口，首先是最基本的读写操作：\n1 2 3 4 public interface ReadableByteChannel extends Channel { //将通道中的数据读取到给定的缓冲区中 public int read(ByteBuffer dst) throws IOException; } 1 2 3 4 public interface WritableByteChannel extends Channel { //将给定缓冲区中的数据写入到通道中 public int write(ByteBuffer src) throws IOException; } 有了读写功能后，最后整合为了一个ByteChannel接口：\n1 2 public interface ByteChannel extends ReadableByteChannel, WritableByteChannel{ } 比如现在我们要实现从输入流中读取数据然后打印出来，那么之前传统IO的写法：\n1 2 3 4 5 6 7 8 9 10 11 12 public static void main(String[] args) throws IOException { //数组创建好，一会用来存放从流中读取到的数据 byte[] data = new byte[10]; //直接使用输入流 InputStream in = System.in; while (true) { int len; while ((len = in.read(data)) \u0026gt;= 0) { //将输入流中的数据一次性读取到数组中 System.out.print(\u0026#34;读取到一批数据：\u0026#34;+new String(data, 0, len)); //读取了多少打印多少 } } } 而现在我们使用通道之后：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public static void main(String[] args) throws IOException { //缓冲区创建好，一会就靠它来传输数据 ByteBuffer buffer = ByteBuffer.allocate(10); //将System.in作为输入源，一会Channel就可以从这里读取数据，然后通过缓冲区装载一次性传递数据 ReadableByteChannel readChannel = Channels.newChannel(System.in); while (true) { //将通道中的数据写到缓冲区中，缓冲区最多一次装10个 readChannel.read(buffer); //写入操作结束之后，需要进行翻转，以便接下来的读取操作 buffer.flip(); //最后转换成String打印出来康康 System.out.println(\u0026#34;读取到一批数据：\u0026#34;+new String(buffer.array(), 0, buffer.remaining())); //回到最开始的状态 buffer.clear(); } } 乍一看，好像感觉也没啥区别，不就是把数组换成缓冲区了吗，效果都是一样的，数据也是从Channel中读取得到，并且通过缓冲区进行数据装载然后得到结果，但是，Channel不像流那样是单向的，它就像它的名字一样，一个通道可以从一端走到另一端，也可以从另一端走到这一端，我们后面进行介绍。\n文件传输FileChannel 前面我们介绍了通道的基本情况，这里我们就来尝试实现一下文件的读取和写入，在传统IO中，文件的写入和输出都是依靠FileOutputStream和FileInputStream来完成的：\n1 2 3 4 5 6 7 8 9 10 11 12 public static void main(String[] args) throws IOException { try(FileOutputStream out = new FileOutputStream(\u0026#34;test.txt\u0026#34;); FileInputStream in = new FileInputStream(\u0026#34;test.txt\u0026#34;)){ String data = \u0026#34;King\u0026#34;; out.write(data.getBytes()); //向文件的输出流中写入数据，也就是把数据写到文件中 out.flush(); byte[] bytes = new byte[in.available()]; in.read(bytes); //从文件的输入流中读取文件的信息 System.out.println(new String(bytes)); } } 而现在，我们只需要通过一个FileChannel就可以完成这两者的操作，获取文件通道的方式有以下几种：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public static void main(String[] args) throws IOException { //1. 直接通过输入或输出流获取对应的通道 FileInputStream in = new FileInputStream(\u0026#34;test.txt\u0026#34;); //但是这里的通道只支持读取或是写入操作 FileChannel channel = in.getChannel(); //创建一个容量为128的缓冲区 ByteBuffer buffer = ByteBuffer.allocate(128); //从通道中将数据读取到缓冲区中 channel.read(buffer); //翻转一下，接下来要读取了 buffer.flip(); System.out.println(new String(buffer.array(), 0, buffer.remaining())); } 1 2 3 4 5 6 7 8 public static void main(String[] args) throws IOException { //1. 直接通过输入或输出流获取对应的通道 FileInputStream in = new FileInputStream(\u0026#34;test.txt\u0026#34;); //但是这里的通道只支持读取或是写入操作 FileChannel channel = in.getChannel(); //尝试写入一下 channel.write(ByteBuffer.wrap(\u0026#34;King\u0026#34;.getBytes())); } 从FileInputStream获得的通道无法进行写操作，同样的FileOutputStream获得的通道只能进行写操作，无法进行读操作。\n可以看到输出流生成的Channel又不支持读取，所以说本质上还是保持着输入输出流的特性，但是之前不是说Channel又可以输入又可以输出吗？这里我们来看看第二种方式：\n1 2 //RandomAccessFile能够支持文件的随机访问，并且实现了数据流 public class RandomAccessFile implements DataOutput, DataInput, Closeable { 我们可以通过RandomAccessFile来创建通道：\n1 2 3 4 5 6 7 8 9 10 11 12 public static void main(String[] args) throws IOException { /* 通过RandomAccessFile进行创建，注意后面的mode有几种： r 以只读的方式使用 rw 读操作和写操作都可以 rws 每当进行写操作，同步的刷新到磁盘，刷新内容和元数据 rwd 每当进行写操作，同步的刷新到磁盘，刷新内容 */ try(RandomAccessFile f = new RandomAccessFile(\u0026#34;test.txt\u0026#34;, \u0026#34;\u0026#34;)){ } } 现在我们来测试一下它的读写操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public static void main(String[] args) throws IOException { /* 通过RandomAccessFile进行创建，注意后面的mode有几种： r 以只读的方式使用 rw 读操作和写操作都可以 rws 每当进行写操作，同步的刷新到磁盘，刷新内容和元数据 rwd 每当进行写操作，同步的刷新到磁盘，刷新内容 */ try(RandomAccessFile f = new RandomAccessFile(\u0026#34;test.txt\u0026#34;, \u0026#34;rw\u0026#34;); //这里设定为支持读写，这样创建的通道才能具有这些功能 FileChannel channel = f.getChannel()){ //通过RandomAccessFile创建一个通道 channel.write(ByteBuffer.wrap(\u0026#34;King\u0026#34;.getBytes())); System.out.println(\u0026#34;写操作完成之后文件访问位置：\u0026#34;+channel.position()); //注意读取也是从现在的位置开始 channel.position(0); //需要将位置变回到最前面，这样下面才能从文件的最开始进行读取 ByteBuffer buffer = ByteBuffer.allocate(128); channel.read(buffer); buffer.flip(); System.out.println(new String(buffer.array(), 0, buffer.remaining())); } } 可以看到，一个FileChannel既可以完成文件读取，也可以完成文件的写入。\n除了基本的读写操作，我们也可以直接对文件进行截断：\n1 2 3 4 5 6 7 8 9 10 11 12 public static void main(String[] args) throws IOException { try(RandomAccessFile f = new RandomAccessFile(\u0026#34;test.txt\u0026#34;, \u0026#34;rw\u0026#34;); FileChannel channel = f.getChannel()){ //截断文件，只留前20个字节 channel.truncate(20); ByteBuffer buffer = ByteBuffer.allocate(128); channel.read(buffer); buffer.flip(); System.out.println(new String(buffer.array(), 0, buffer.remaining())); } } 可以看到文件的内容直接被截断了，文件内容就只剩一半了。\n当然，如果我们要进行文件的拷贝，也是很方便的，只需要使用通道就可以，比如我们现在需要将一个通道的数据写入到另一个通道，就可以直接使用transferTo方法：\n1 2 3 4 5 6 7 8 public static void main(String[] args) throws IOException { try(FileOutputStream out = new FileOutputStream(\u0026#34;test2.txt\u0026#34;); FileInputStream in = new FileInputStream(\u0026#34;test.txt\u0026#34;)){ FileChannel inChannel = in.getChannel(); //获取到test文件的通道 inChannel.transferTo(0, inChannel.size(), out.getChannel()); //直接将test文件通道中的数据转到test2文件的通道中 } } 可以看到执行后，文件的内容全部被复制到另一个文件了。\n当然，反向操作也是可以的：\n1 2 3 4 5 6 7 8 public static void main(String[] args) throws IOException { try(FileOutputStream out = new FileOutputStream(\u0026#34;test2.txt\u0026#34;); FileInputStream in = new FileInputStream(\u0026#34;test.txt\u0026#34;)){ FileChannel inChannel = in.getChannel(); //获取到test文件的通道 out.getChannel().transferFrom(inChannel, 0, inChannel.size()); //直接将从test文件通道中传来的数据转给test2文件的通道 } } 当我们要编辑某个文件时，通过使用MappedByteBuffer类，可以将其映射到内存中进行编辑，编辑的内容会同步更新到文件中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //注意一定要是可写的，不然无法进行修改操作 try(RandomAccessFile f = new RandomAccessFile(\u0026#34;test.txt\u0026#34;, \u0026#34;rw\u0026#34;); FileChannel channel = f.getChannel()){ //通过map方法映射文件的某一段内容，创建MappedByteBuffer对象 //比如这里就是从第四个字节开始，映射10字节内容到内存中 //注意这里需要使用MapMode.READ_WRITE模式，其他模式无法保存数据到文件 MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_WRITE, 4, 10); //我们可以直接对在内存中的数据进行编辑，也就是编辑Buffer中的内容 //注意这里写入也是从pos位置开始的，默认是从0开始，相对于文件就是从第四个字节开始写 //注意我们只映射了10个字节，也就是写的内容不能超出10字节了 buffer.put(\u0026#34;yyds\u0026#34;.getBytes()); //编辑完成后，通过force方法将数据写回文件的映射区域 buffer.force(); } 可以看到，文件的某一个区域已经被我们修改了，并且这里实际上使用的就是DirectByteBuffer直接缓冲区，效率还是很高的。\n文件锁FileLock 我们可以创建一个跨进程文件锁来防止多个进程之间的文件争抢操作（注意这里是进程，不是线程）FileLock是文件锁，它能保证同一时间只有一个进程（程序）能够修改它，或者都只可以读，这样就解决了多进程间的同步文件，保证了安全性。但是需要注意的是，它进程级别的，不是线程级别的，他可以解决多个进程并发访问同一个文件的问题，但是它不适用于控制同一个进程中多个线程对一个文件的访问。\n那么我们来看看如何使用文件锁：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public static void main(String[] args) throws IOException, InterruptedException { //创建RandomAccessFile对象，并拿到Channel RandomAccessFile f = new RandomAccessFile(\u0026#34;test.txt\u0026#34;, \u0026#34;rw\u0026#34;); FileChannel channel = f.getChannel(); System.out.println(new Date() + \u0026#34; 正在尝试获取文件锁...\u0026#34;); //接着我们直接使用lock方法进行加锁操作（如果其他进程已经加锁，那么会一直阻塞在这里） //加锁操作支持对文件的某一段进行加锁，比如这里就是从0开始后的6个字节加锁，false代表这是一把独占锁 //范围锁甚至可以提前加到一个还未写入的位置上 FileLock lock = channel.lock(0, 6, false); System.out.println(new Date() + \u0026#34; 已获取到文件锁！\u0026#34;); Thread.sleep(5000); //假设要处理5秒钟 System.out.println(new Date() + \u0026#34; 操作完毕，释放文件锁！\u0026#34;); //操作完成之后使用release方法进行锁释放 lock.release(); } 有关共享锁和独占锁：\n进程对文件加独占锁后，当前进程对文件可读可写，独占此文件，其它进程是不能读该文件进行读写操作的。\n进程对文件加共享锁后，进程可以对文件进行读操作，但是无法进行写操作，共享锁可以被多个进程添加，但是只要存在共享锁，就不能添加独占锁。\n当然，除了直接使用lock()方法进行加锁之外，我们也可以使用tryLock()方法以非阻塞方式获取文件锁，但是如果获取锁失败会得到null。\n选择器 Selector 一般称 为选择器 ，当然你也可以翻译为 多路复用器 。它是Java NIO核心组件中的一个，用于检查一个或多个NIO Channel（通道）的状态是否处于可读、可写。如此可以实现单线程管理多个channels,也就是可以管理多个网络链接。\n使用Selector的好处在于： 使用更少的线程来就可以来处理通道了， 相比使用多个线程，避免了线程上下文切换带来的开销。\nSelector的使用方法介绍 1. Selector的创建 通过调用Selector.open()方法创建一个Selector对象，如下：\n1 Selector selector = Selector.open(); 这里需要说明一下\n2. 注册Channel到Selector 1 2 channel.configureBlocking(false); SelectionKey key = channel.register(selector, Selectionkey.OP_READ); Channel必须是非阻塞的。 所以FileChannel不适用Selector，因为FileChannel不能切换为非阻塞模式，更准确的来说是因为FileChannel没有继承SelectableChannel。Socket channel可以正常使用。\nSelectableChannel抽象类 有一个 configureBlocking（） 方法用于使通道处于阻塞模式或非阻塞模式。\n1 abstract SelectableChannel configureBlocking(boolean block) 注意：\nSelectableChannel抽象类的configureBlocking（） 方法是由 AbstractSelectableChannel抽象类实现的，SocketChannel、ServerSocketChannel、DatagramChannel都是直接继承了 AbstractSelectableChannel抽象类 。 大家有兴趣可以看看NIO的源码，各种抽象类和抽象类上层的抽象类。我本人暂时不准备研究NIO源码，因为还有很多事情要做，需要研究的同学可以自行看看。\nregister() 方法的第二个参数。这是一个“ interest集合 ”，意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件：\nConnect Accept Read Write 通道触发了一个事件意思是该事件已经就绪。比如某个Channel成功连接到另一个服务器称为“ 连接就绪 ”。一个Server Socket Channel准备好接收新进入的连接称为“ 接收就绪 ”。一个有数据可读的通道可以说是“ 读就绪 ”。等待写数据的通道可以说是“ 写就绪 ”。\n这四种事件用SelectionKey的四个常量来表示：\n1 2 3 4 SelectionKey.OP_CONNECT SelectionKey.OP_ACCEPT SelectionKey.OP_READ SelectionKey.OP_WRITE 如果你对不止一种事件感兴趣，使用或运算符即可，如下：\n1 int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE; 3. SelectionKey介绍 一个SelectionKey键表示了一个特定的通道对象和一个特定的选择器对象之间的注册关系。\n1 2 3 4 5 key.attachment(); //返回SelectionKey的attachment，attachment可以在注册channel的时候指定。 key.channel(); // 返回该SelectionKey对应的channel。 key.selector(); // 返回该SelectionKey对应的Selector。 key.interestOps(); //返回代表需要Selector监控的IO操作的bit mask key.readyOps(); // 返回一个bit mask，代表在相应channel上可以进行的IO操作。 key.interestOps():\n我们可以通过以下方法来判断Selector是否对Channel的某种事件感兴趣\n1 2 3 4 5 int interestSet = selectionKey.interestOps(); boolean isInterestedInAccept = (interestSet \u0026amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT； boolean isInterestedInConnect = interestSet \u0026amp; SelectionKey.OP_CONNECT; boolean isInterestedInRead = interestSet \u0026amp; SelectionKey.OP_READ; boolean isInterestedInWrite = interestSet \u0026amp; SelectionKey.OP_WRITE; key.readyOps()\nready 集合是通道已经准备就绪的操作的集合。JAVA中定义以下几个方法用来检查这些操作是否就绪.\n1 2 3 4 5 6 7 //创建ready集合的方法 int readySet = selectionKey.readyOps(); //检查这些操作是否就绪的方法 key.isAcceptable();//是否可读，是返回 true boolean isWritable()：//是否可写，是返回 true boolean isConnectable()：//是否可连接，是返回 true boolean isAcceptable()：//是否可接收，是返回 true 从SelectionKey访问Channel和Selector很简单。如下：\n1 2 3 Channel channel = key.channel(); Selector selector = key.selector(); key.attachment(); 可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：\n1 2 key.attach(theObject); Object attachedObj = key.attachment(); 还可以在用register()方法向Selector注册Channel的时候附加对象。如：\n1 SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject); 4. 从Selector中选择channel(Selecting Channels via a Selector) 选择器维护注册过的通道的集合，并且这种注册关系都被封装在SelectionKey当中.\nSelector维护的三种类型SelectionKey集合：\n已注册的键的集合(Registered key set)\n所有与选择器关联的通道所生成的键的集合称为已经注册的键的集合。并不是所有注册过的键都仍然有效。这个集合通过 keys() 方法返回，并且可能是空的。这个已注册的键的集合不是可以直接修改的；试图这么做的话将引发java.lang.UnsupportedOperationException。\n已选择的键的集合(Selected key set)\n所有与选择器关联的通道所生成的键的集合称为已经注册的键的集合。并不是所有注册过的键都仍然有效。这个集合通过 keys() 方法返回，并且可能是空的。这个已注册的键的集合不是可以直接修改的；试图这么做的话将引发java.lang.UnsupportedOperationException。\n已取消的键的集合(Cancelled key set)\n已注册的键的集合的子集，这个集合包含了 cancel() 方法被调用过的键(这个键已经被无效化)，但它们还没有被注销。这个集合是选择器对象的私有成员，因而无法直接访问。\n注意： 当键被取消（ 可以通过isValid( ) 方法来判断）时，它将被放在相关的选择器的已取消的键的集合里。注册不会立即被取消，但键会立即失效。当再次调用 select( ) 方法时（或者一个正在进行的select()调用结束时），已取消的键的集合中的被取消的键将被清理掉，并且相应的注销也将完成。通道会被注销，而新的SelectionKey将被返回。当通道关闭时，所有相关的键会自动取消（记住，一个通道可以被注册到多个选择器上）。当选择器关闭时，所有被注册到该选择器的通道都将被注销，并且相关的键将立即被无效化（取消）。一旦键被无效化，调用它的与选择相关的方法就将抛出CancelledKeyException。\nselect()方法介绍：\n在刚初始化的Selector对象中，这三个集合都是空的。 通过Selector的select（）方法可以选择已经准备就绪的通道 （这些通道包含你感兴趣的的事件）。比如你对读就绪的通道感兴趣，那么select（）方法就会返回读事件已经就绪的那些通道。下面是Selector几个重载的select()方法：\nint select()：阻塞到至少有一个通道在你注册的事件上就绪了。 int select(long timeout)：和select()一样，但最长阻塞时间为timeout毫秒。 int selectNow()：非阻塞，只要有通道就绪就立刻返回。 select()方法返回的int值表示有多少通道已经就绪,是自上次调用select()方法后有多少通道变成就绪状态。之前在select（）调用时进入就绪的通道不会在本次调用中被记入，而在前一次select（）调用进入就绪但现在已经不在处于就绪的通道也不会被记入。例如：首次调用select()方法，如果有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道，但在每次select()方法调用之间，只有一个通道就绪了。\n一旦调用select()方法，并且返回值不为0时，则 可以通过调用Selector的selectedKeys()方法来访问已选择键集合 。如下： Set selectedKeys=selector.selectedKeys(); 进而可以放到和某SelectionKey关联的Selector和Channel。如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Set selectedKeys = selector.selectedKeys(); Iterator keyIterator = selectedKeys.iterator(); while(keyIterator.hasNext()) { SelectionKey key = keyIterator.next(); if(key.isAcceptable()) { // a connection was accepted by a ServerSocketChannel. } else if (key.isConnectable()) { // a connection was established with a remote server. } else if (key.isReadable()) { // a channel is ready for reading } else if (key.isWritable()) { // a channel is ready for writing } keyIterator.remove(); } 5. 停止选择的方法 选择器执行选择的过程，系统底层会依次询问每个通道是否已经就绪，这个过程可能会造成调用线程进入阻塞状态,那么我们有以下三种方式可以唤醒在select（）方法中阻塞的线程。\nwakeup()方法 ：通过调用Selector对象的wakeup（）方法让处在阻塞状态的select()方法立刻返回 该方法使得选择器上的第一个还没有返回的选择操作立即返回。如果当前没有进行中的选择操作，那么下一次对select()方法的一次调用将立即返回。 close()方法 ：通过close（）方法关闭Selector， 该方法使得任何一个在选择操作中阻塞的线程都被唤醒（类似wakeup（）），同时使得注册到该Selector的所有Channel被注销，所有的键将被取消，但是Channel本身并不会关闭。 35. 序列化 序列化：指的就是通过某种技术将数据结构或者对象转化为二进制字节流的过程（通常是二进制的形式，也可以采用类似XML或者JSON的方式，但是这样虽然提高了可读性但是降低的性能）\n反序列化：指的将二进制字节流转化为数据结构或者对象的过程。（序列化相对的步骤）\n通常序列化与反序列化的作用是\n将当前程序中的数据实现持久化的存储 将对象通过网络进行传输，在远程的设备上需要本地设备的对象 存储到数据库中也需要序列化 （一般就是需要将对象取出来使用的场景，此时就需要通过序列化的方式来实现这些功能）\nJDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。\nJDK自带的序列化实现 1 2 3 4 5 6 7 8 9 @Getter @Setter @NoArgsConstructor @AllArgsConstructor public class People implements Serializable { private static final long serialVersionUID = 1905122041950251207L; private int anInt; private String string; } 使用Java自带的序列化只需要实现Serializable接口最好是自己创建serialVersionUID，UID的作用是在反序列化时检测版本是否一致，若不一致则无法进行反序列化。\n对于不想进行序列化的变量，可以使用 transient 关键字修饰，关键字只可用于修饰变量，不可以用于修饰方法。\nKryo Kryo 是一个快速序列化/反序列化工具，其使用了字节码生成机制（底层依赖了 ASM 库），因此具有比较好的运行速度。\nKryo 序列化出来的结果，是其自定义的、独有的一种格式，不再是 JSON 或者其他现有的通用格式；而且，其序列化出来的结果是二进制的（即 byte[]；而 JSON 本质上是字符串 String）；二进制数据显然体积更小，序列化、反序列化时的速度也更快。\nKryo 一般只用来进行序列化（然后作为缓存，或者落地到存储设备之中）、反序列化，而不用于在多个系统、甚至多种语言间进行数据交换 —— 目前 kryo 也只有 java 实现。\n像 Redis 这样的存储工具，是可以安全地存储二进制数据的，所以可以直接把 Kryo 序列化出来的数据存进去。\n当然，如果你希望用 String 的形式存储、传输 Kryo 序列化之后的数据，也可以通过 Base64 等编码方式来实现。但这会降低程序的运行速度，一定程度上违背了使用 kryo 的初衷。\n相较于Java提供的序列化工具，Kryo可以序列化任意类型的对象（不包括匿名内部类，对非静态内部类的支持一般），这使得许多已经开发好的工具包中的类但是没有实现@Serializable接口的对象可以实现序列化，通常序列化所需的时间都纳秒级别的。 线程不安全，Kryo没有在序列化时对对象进行上锁，所以理论上存在数据出错的可能性大，可以通过ThreadLocal保证线程安全性 注册，在Kryo中可以进行注册，注册后每种类型会获得一个编号，但是在现实环境中（重启虚拟机后注册顺序不同、多设备部署）同一个类型具有两种不同的编号，会使得反序列化失败，一般情况下不使用注册的方式实现序列化，通过如下设置关闭注册: kryo.setRegistrationRequired(false); 循环引用问题，默认情况下是支持循环引用问题的，例如A引用了B，在B中同样引用了A。有特殊需求可以关闭循环引用: kryo.setReferences(false); KryoUtil 对 Kryo 进行了一定的封装，能够满足分布式系统的一般需求，而无需进行任何额外的配置。\n除了用于获得当前线程的 kryo 实例的 getInstance() 方法之外，KryoUtil 内共有 8 个 public 方法，分为两组：\nbyte[] writeToByteArray(T obj);\nString writeToString(T obj);\nT readFromByteArray(byte[] byteArray);\nT readFromString(String str);\n及：\nbyte[] writeObjectToByteArray(T obj)\nString writeObjectToString(T obj)\nT readObjectFromByteArray(byte[] byteArray, Class clazz)\nT readObjectFromString(String str, Class clazz)\n其中第一组序列化的结果里包含了类型信息，第二组不包含 —— 因此，可以看到，在使用第二组方法进行反序列化的时候，需要提供原始对象的 Class 。但我们建议使用第一组方法，原因见第 3.2 节。\n另外，必须注意，第一组方法和第二组方法不能混用，第一组序列化出来的结果，只能由第一组的方法进行反序列化；第二组亦然。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 public class KryoUtil { private static final String DEFAULT_ENCODING = \u0026#34;UTF-8\u0026#34;; private static final ThreadLocal\u0026lt;Kryo\u0026gt; kryoLocal = new ThreadLocal\u0026lt;Kryo\u0026gt;() { @Override protected Kryo initialValue() { Kryo kryo = new Kryo(); kryo.setReferences(true); kryo.setRegistrationRequired(false); ((Kryo.DefaultInstantiatorStrategy) kryo.getInstantiatorStrategy()).setFallbackInstantiatorStrategy(new StdInstantiatorStrategy()); return kryo; } }; public static Kryo getInstance() { return kryoLocal.get(); } public static \u0026lt;T\u0026gt; byte[] writeToByteArray(T obj) { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); Output output = new Output(byteArrayOutputStream); Kryo kryo = getInstance(); kryo.writeClassAndObject(output, obj); output.flush(); return byteArrayOutputStream.toByteArray(); } public static \u0026lt;T\u0026gt; String writeToString(T obj) { try { return new String(Base64.encodeBase64(writeToByteArray(obj)), DEFAULT_ENCODING); } catch (UnsupportedEncodingException e) { throw new IllegalStateException(e); } } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public static \u0026lt;T\u0026gt; T readFromByteArray(byte[] byteArray) { ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArray); Input input = new Input(byteArrayInputStream); Kryo kryo = getInstance(); return (T) kryo.readClassAndObject(input); } public static \u0026lt;T\u0026gt; T readFromString(String str) { try { return readFromByteArray(Base64.decodeBase64(str.getBytes(DEFAULT_ENCODING))); } catch (UnsupportedEncodingException e) { throw new IllegalStateException(e); } } public static \u0026lt;T\u0026gt; byte[] writeObjectToByteArray(T obj) { ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); Output output = new Output(byteArrayOutputStream); Kryo kryo = getInstance(); kryo.writeObject(output, obj); output.flush(); return byteArrayOutputStream.toByteArray(); } public static \u0026lt;T\u0026gt; String writeObjectToString(T obj) { try { return new String(Base64.encodeBase64(writeObjectToByteArray(obj)), DEFAULT_ENCODING); } catch (UnsupportedEncodingException e) { throw new IllegalStateException(e); } } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) public static \u0026lt;T\u0026gt; T readObjectFromByteArray(byte[] byteArray, Class\u0026lt;T\u0026gt; clazz) { ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArray); Input input = new Input(byteArrayInputStream); Kryo kryo = getInstance(); return kryo.readObject(input, clazz); } public static \u0026lt;T\u0026gt; T readObjectFromString(String str, Class\u0026lt;T\u0026gt; clazz) { try { return readObjectFromByteArray(Base64.decodeBase64(str.getBytes(DEFAULT_ENCODING)), clazz); } catch (UnsupportedEncodingException e) { throw new IllegalStateException(e); } } } 36. SPI SPI机制指的是由调用方定义接口，实现方根据调用方提供的接口进行实现。\n调用的示意图如上，那么这套机制是如何实现的呢？\n调用方 在调用方从ServiceLoader中获取接口的实现对象，当然调用方需要对ServiceLoader中不存在实现对象，或存在多个实例对象的情况进行考虑（ServiceLoader中对象从何而来将在实现方进行讲解）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 private LoggerService() { ServiceLoader\u0026lt;Logger\u0026gt; loader = ServiceLoader.load(Logger.class); List\u0026lt;Logger\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (Logger log : loader) { list.add(log); } // LoggerList 是所有 ServiceProvider loggerList = list; if (!list.isEmpty()) { // Logger 只取一个 logger = list.get(0); } else { logger = null; } } 调用方通过ServiceLoader.load方法获取实例对象，该对象就是调用方提供的接口。\n实现方 实现方直接对接口进行实现即可，那么实现方在实现完成后如何将实现对象放入ServiceLoader呢，这就需要讲到SPI的实现机制了。\n在Java中调用方通过会定义好接口在一个包中，实现方会实现该接口在另一个包中，Java在引入jar包时提供了SPI的机制，设置配置文件META-INF/services，文件名为接口的全路径，文件内容是实现类的全路径。jdk在加载jar包时会读取该文件，并创建对象，将对象存放到ServiceLoader中。\n这就有非常多的事情可以做了，因为这种方式可以自动加载配置文件中写的类，会触发类加载，所以可以在类加载中、初始化方法中做很多想做的事情。\n37. 范型 什么是泛型？有什么作用？ Java 泛型（Generics） 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。\n编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 ArrayList\u0026lt;Person\u0026gt; persons = new ArrayList\u0026lt;Person\u0026gt;() 这行代码就指明了该 ArrayList 对象只能传入 Person 对象，如果传入其他类型的对象就会报错。\n1 ArrayList\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; 并且，原生 List 返回类型是 Object ，需要手动转换类型才能使用，使用泛型后编译器自动转换。\n泛型的使用方式有哪几种？ 泛型一般有三种使用方式:泛型类、泛型接口、泛型方法。\n1.泛型类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型 //在实例化泛型类时，必须指定T的具体类型 public class Generic\u0026lt;T\u0026gt;{ private T key; public Generic(T key) { this.key = key; } public T getKey(){ return key; } } 如何实例化泛型类：\n1 Generic\u0026lt;Integer\u0026gt; genericInteger = new Generic\u0026lt;Integer\u0026gt;(123456); 2.泛型接口 ：\n1 2 3 public interface Generator\u0026lt;T\u0026gt; { public T method(); } 实现泛型接口，不指定类型：\n1 2 3 4 5 6 class GeneratorImpl\u0026lt;T\u0026gt; implements Generator\u0026lt;T\u0026gt;{ @Override public T method() { return null; } } 实现泛型接口，指定类型：\n1 2 3 4 5 6 class GeneratorImpl\u0026lt;T\u0026gt; implements Generator\u0026lt;String\u0026gt;{ @Override public String method() { return \u0026#34;hello\u0026#34;; } } 3.泛型方法 ：\n1 2 3 4 5 6 public static \u0026lt;E\u0026gt; void printArray(E[] inputArray){ for (E element : inputArray){ System.out.printf(\u0026#34;%s\u0026#34;, element); } System.out.println(); } 使用：\n1 2 3 4 5 // 创建不同类型数组： Integer, Double 和 Character Integer[] intArray = {1, 2, 3}; String[] stringArray = {\u0026#34;Hello\u0026#34;, \u0026#34;World\u0026#34;}; printArray(intArray); printArray(stringArray); 注意: public static \u0026lt;E\u0026gt; void printArray(E[] inputArray) 一般被称为静态泛型方法;在 java 中泛型只是一个占位符，必须在传递类型后才能使用。类在实例化时才能真正的传递类型参数，由于静态方法的加载先于类的实例化，也就是说类中的泛型还没有传递真正的类型参数，静态的方法的加载就已经完成了，所以静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的 \u0026lt;E\u0026gt;\n泛型类、泛型接口、泛型方法 1 2 3 4 5 6 7 8 9 10 11 public class Test1\u0026lt;T\u0026gt;{ private T t; public void setT (T t) { this.t = t; } public T getT(){ return t; } } 上面是一个基本的泛型类的实现，其实现方式是在类名后增加\u0026lt;\u0026gt;符号来表示泛型，可以使用例如T、E、K、V等形式常见的参数表示泛型。\n实例化代码是：Test1\u0026lt;Integer\u0026gt; t = new Test1\u0026lt;\u0026gt;();在new时后面尖括号中的类型可以省略。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public interface TestInt\u0026lt;T\u0026gt; { public T method(); } public class Test2\u0026lt;T\u0026gt; implements TestInt\u0026lt;T\u0026gt;{ @Override public T method() { return null; } } public class Test3 implements TestInt\u0026lt;Integer\u0026gt;{ @Override public Integer method() { return null; } } 上述代码中定义了泛型接口并且在其中定义了一个方法，在实现这个接口时，可以直接在实现中制定泛型的类型，此时在实现具体方法时实现的方法已经是具体类型的了，也可以不指定，继续使用泛型由使用者来确定。\n1 2 public \u0026lt;E\u0026gt; void mathod(List\u0026lt;E\u0026gt; list){ } 泛型方法可以在void前侧定义泛型，然后在形参或者返回值中使用。\n泛型擦除 泛型擦除指的是在编译后的字节码中是没有泛型的信息的，这点可以通过反编译进行验证。其中泛型T、K等被擦除为Object，T extends XXX被擦除为XXX。\n因为泛型擦除的存在会导致一个新问题，泛型怎么办，例如在一个类实现了另一个泛型类，并且确定了泛型的类型，此时实现的方式是具体类型的，但是在父类中的方法中类型是Object的，但是实现的方法却是具体类型的，此时多态就遇到了问题，因此编译器做了桥方法。\n1 2 3 4 5 6 7 8 9 10 11 12 class Test4\u0026lt;T\u0026gt; { public void method(T t) {} } class Test5 extends Test4\u0026lt;Integer\u0026gt;{ public void method(Integer t){} // 桥方法，编译器自动生成，不需要用户实现 public void method(Object t){ method((Integer) t); } } 泛型的限制 只能申明但不能实例化T 泛型参数不能是基本类型，因为需要是Object的子类 不能实例化泛型参数的数组 不能实例化泛型数组 泛型不能使用Instance of 和getClass()进行判断 不能使用static修饰泛型变量 可以从类型擦除的角度思考，很多不确定的东西是不能实现的。\n通配符 在定义泛型时可以使用entends确定泛型的最高类型\n在使用范型时可以使用？、extends、super对对象类型的范围进行限制。\n使用extends和super进行限制后存在使用时的限制需要注意。\n38. stream流 Java 8中的Stream是一种新的抽象层，用于对集合对象进行处理。Stream API可以让我们更方便地对集合进行操作，而不需要使用for循环等传统方式。Stream API提供了一种高效且易于使用的处理数据的方式。\nStream流在管道中传输，并且可以在管道的节点上进行处理，比如筛选、排序、聚合等。Stream流的操作可以分为中间操作和终端操作两种，其中中间操作返回一个新的Stream对象，终端操作则返回一个非Stream对象。\n下面是一些Java Stream流的例子：\n通过 java.util.Collection.stream () 方法用集合创建流 1 2 3 4 5 List \u0026lt;String \u0026gt; list = Arrays.asList(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;); // 创建一个顺序流 Stream \u0026lt;String \u0026gt; stream = list.stream(); // 创建一个并行流 Stream \u0026lt;String \u0026gt; parallelStream = list.parallelStream(); 使用 java.util.Arrays.stream (T [] array) 方法用数组创建流 1 2 int [] array ={1,3,5,7,9}; IntStream stream = Arrays.stream(array); 使用 Stream.of() 方法创建流 1 Stream\u0026lt;String\u0026gt; strStream = Stream.of (\u0026#34;hello\u0026#34;, \u0026#34;java8\u0026#34;, \u0026#34;stream\u0026#34;); 39. 大数 在计算机程序中进行浮点运算时是存在精度丢失的情况的 ，如下代码就是精度问题导致的：\n1 2 3 4 5 float a = 2.0f - 1.9f; float b = 1.8f - 1.7f; System.out.println(a);// 0.100000024 System.out.println(b);// 0.099999905 System.out.println(a == b);// false 按照现实中的计算来看a和b都应该是0.1，但是由于计算机对浮点数进行存储是使用的二进制的缘故，无法保证结果的精确性，在《阿里巴巴Java开发手册》中就建议为了避免精度丢失，进行浮点运算时采用BigDecimal进行。\nBigDecimal介绍 《阿里巴巴 Java 开发手册》中提到：浮点数之间的等值判断，基本数据类型不能用 == 来比较，包装数据类型不能用 equals 来判断。（由于精度的原因）\n创建 我们在使用 BigDecimal 时，为了防止精度丢失，推荐使用它的BigDecimal(String val)构造方法或者 BigDecimal.valueOf(double val) 静态方法来创建对象。\n加减乘除操作 1 2 3 4 5 6 7 BigDecimal a = new BigDecimal(\u0026#34;1.0\u0026#34;); BigDecimal b = new BigDecimal(\u0026#34;0.9\u0026#34;); System.out.println(a.add(b));// 1.9 System.out.println(a.subtract(b));// 0.1 System.out.println(a.multiply(b));// 0.90 System.out.println(a.divide(b));// 无法除尽，抛出 ArithmeticException 异常 System.out.println(a.divide(b, 2, RoundingMode.HALF_UP));// 1.11 这里需要注意的是，在我们使用 divide 方法的时候尽量使用 3 个参数版本，并且RoundingMode 不要选择 UNNECESSARY，否则很可能会遇到 ArithmeticException（无法除尽出现无限循环小数的时候），其中 scale 表示要保留几位小数，roundingMode 代表保留规则。\n大小比较 a.compareTo(b) : 返回 -1 表示 a 小于 b，0 表示 a 等于 b ， 1 表示 a 大于 b。\n1 2 3 BigDecimal a = new BigDecimal(\u0026#34;1.0\u0026#34;); BigDecimal b = new BigDecimal(\u0026#34;0.9\u0026#34;); System.out.println(a.compareTo(b));// 1 保留几位小数 通过 setScale方法设置保留几位小数以及保留规则。保留规则有挺多种，不需要记，IDEA 会提示。\n1 2 3 BigDecimal m = new BigDecimal(\u0026#34;1.255433\u0026#34;); BigDecimal n = m.setScale(3,RoundingMode.HALF_DOWN); System.out.println(n);// 1.255 等值比较问题 1 2 3 4 BigDecimal a = new BigDecimal(\u0026#34;1\u0026#34;); BigDecimal b = new BigDecimal(\u0026#34;1.0\u0026#34;); System.out.println(a.equals(b));//false System.out.println(a.compareTo(b));//0 40. 集合 Java集合也称为容器，所有容器都由两大接口派生而来，分别是Collection、Map。Collection接口的实现类只要用于存放单一的元素，Map接口的实现类主要用于存放键值对，其中Collection接口有三个主要的子接口：List、Set、Queue。\n四种主要容器的区别 List：存放有序的、可重复的元素（处理有序的元素） Set：存放无序的、不可重复的元素（主要用于处理不可重复的场景） Queue：存放有序的、可重复的元素，但是会根据要求限制先后顺序（例如排队等功能） Map：存储键值对，其中key是无序的、不可重复的 如何选用集合? 主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 Map 接口下的集合，需要排序时选择 TreeMap,不需要排序时就选择 HashMap,需要保证线程安全就选用 ConcurrentHashMap。\n当我们只需要存放元素值时，就选择实现Collection 接口的集合，需要保证元素唯一时选择实现 Set 接口的集合比如 TreeSet 或 HashSet，不需要就选择实现 List 接口的比如 ArrayList 或 LinkedList，然后再根据实现这些接口的集合的特点来选用。\n为什么要使用集合？ 当我们需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，这个容器就是数组，但是，使用数组存储对象具有一定的弊端， 因为我们在实际开发中，存储的数据的类型是多种多样的，于是，就出现了“集合”，集合同样也是用来存储多个数据的。\n数组的缺点是一旦声明之后，长度就不可变了；同时，声明数组时的数据类型也决定了该数组存储的数据的类型；而且，数组存储的数据是有序的、可重复的，特点单一。 但是集合提高了数据存储的灵活性，Java 集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据。\n集合的使用方法 我们在使用集合的时候通常都是使用四种接口然后指向其子类，所以下面主要介绍几个接口总提供的方法进行介绍。\nCollection 方法 作用 int size() 容器中存放的对象数量 boolean contains(Object) 容器中是否包含形参对象 boolean containsAll(Collection\u003c?\u003e c) 若容器中包含形参容器中的所有元素，返回true iterator() 迭代器 T[] toArray() 将容器中的对象转化为一个数组进行返回 T[] toArray(T[] a) 控制返回类型的数组，作用同上 boolean add(E e) 向容器中添加元素 boolean addAll(Collection\u0026lt;? extends E\u0026gt; c) 将形参容器中的所有元素添加到容器中 boolean remove(Object o) 从容器中移除元素 boolean removeAll(Collection\u003c?\u003e c) 从容器中移除形参容器中的所以元素 boolean retainAll(Collection\u003c?\u003e c) 保留容器中存在与形参容器中的元素 void clear() 清空容器 List 方法 作用 boolean addAll(int index, Collection\u0026lt;? extends E\u0026gt; c) 在index下表开始添加形参中的元素 default void replaceAll(UnaryOperator operator) 将容器中的每一个元素替换为operator运算后的结果 void sort(Comparator\u0026lt;? super E\u0026gt; c) 根据比较器对容器中的元素进行排 E get(int index) 获取下标为index的元素 E set(int index, E element) 设置下表为index的元素为element void add(int index, E element) 在下标为index的地方插入元素element E remove(int index) 移除下标为index的元素 int indexOf(Object o) 获取元素在容器中的下标 int lastIndexOf(Object o) 获取元素在容器中最后一次出现的索引 ListIterator listIterator() 返回词容器的列表迭代器 ListIterator listIterator(int index) 返回从index开始的列表迭代器 List subList(int fromIndex, int toIndex) 返回子序列（前闭后开，相同时返回为空） 大部分方法通过方法名就可以知道其作用，通常这些方法也是最常用的。\nSet Set中的方法都继承自Collection，其通过Map实现，因为Map中的Key是唯一的，因此满足Set不重复、乱序的特点。\nQueue 方法 作用 boolean offer(E e) 在不违反容量限制的条件下，立即将指定的元素插入队列中 E remove() 删除队列的头元素，若队列为空将抛出异常 E poll() 退出队列的头元素，队列为空则返回null E element() 检查队列的头元素，若队列为空抛出异常 E peek() 检测队列的头元素，若队列为空返回null Map 方法 作用 int size() 返回映射中的键值对数量 boolean containsKey(Object key) 映射中是否包含键为key的键值对 boolean containsValue(Object value) 映射中是否有键值对映射到该value上 V get(Object key) 根据提供的key获得value V put(K key, V value) 向映射中添加键值对，若原来已经存在则替换value V remove(Object key) 根据value从映射中移除键值对 void putAll(Map\u0026lt;? extends K, ? extends V\u0026gt; m) 将形参映射中所有的键值对添加到映射中 void clear() 清空映射 Set keySet() 返回映射中key构成的Set类型对象 Collection values() 返回映射中value构成的Collection对象 Set\u0026lt;Map.Entry\u0026lt;K, V\u0026raquo; entrySet() 返回映射中键值对构成的Set类型对象 V getOrDefault(Object key, V defaultValue) 返回key映射到的值，若不存在则返回默认值 void forEach(BiConsumer\u0026lt;? super K, ? super V\u0026gt; action) 对映射中的所有键值对执行指定操作 void replaceAll(BiFunction\u0026lt;? super K, ? super V, ? extends V\u0026gt; function) 对映射中的所有键值对执行指定操作，与foreach方法的区别在于执行的操作会改变value的值，而foreach不会 V putIfAbsent(K key, V value) 如果指定的键尚未与值关联（或映射到 null），则将其与给定值关联并返回 null，否则返回当前值。 boolean remove(Object key, Object value) 仅当指定键当前映射到指定值时，才删除该项。 boolean replace(K key, V oldValue, V newValue) 更新指定键值对的值 V replace(K key, V value) 仅当指定键当前映射到某个值时，才替换该项 V computeIfAbsent(K key, Function\u0026lt;? super K, ? extends V\u0026gt; mappingFunction) 如果指定的键尚未与值关联（或映射到 null），则尝试使用给定的映射函数计算其值，并将其输入到此映射中，除非为 null。如果函数返回 null，则不记录任何映射。如果函数本身引发（未选中的）异常，则会重新引发异常，并且不会记录任何映射 V computeIfPresent(K key, BiFunction\u0026lt;? super K, ? super V, ? extends V\u0026gt; remappingFunction) 如果指定键的值存在且非 null，则尝试在给定键及其当前映射值的情况下计算新映射 V compute(K key, BiFunction\u0026lt;? super K, ? super V, ? extends V\u0026gt; remappingFunction) 尝试计算指定键及其当前映射值的映射（如果没有当前映射，则为 null） V merge(K key, V value, BiFunction\u0026lt;? super V, ? super V, ? extends V\u0026gt; remappingFunction) 如果指定的键尚未与值关联或与 null 关联，则将其与给定的非 null 值相关联。否则，将关联的值替换为给定重映射函数的结果，如果结果为 null，则删除。当组合一个键的多个映射值时，此方法可能有用 boolean isEmpty() 判断映射是否为空 ","permalink":"https://jinchaojjj.github.io/posts/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","summary":"Java基本语法 1. 注释 Java中存在三种注释：单行注释、多行注释、文档注释 单行注释采用//的方式进行，在本行中的所有内容在编译时都将忽略 多行","title":"Java基本语法"},{"content":"1. Java语言的特点 简单易学，相较于python等语言具有较好的严谨性以及报错机制；\n面向对象（封装，继承，多态），Java中所有内容都是基于类进行扩展的，由类创建的实体称为对象，并且对象之间存在不同的关系，由此发展出了继承、多态等语言特性；\n平台无关性（ Java 虚拟机实现平台无关性），Java语言通过JVM运行字节码文件的方式解决了平台间迁移代码的问题。Java分为编译与运行两部分，编译时只将Java代码转化为.class字节码的过程（其他语言例如在安卓平台推广的Kotlin等，通过自己的编译器同样可以编译为字节码文件，满足JVM运行字节码文件的格式要求即可），然后JVM只需要运行字节码文件即可。但是在不同平台上运行的JVM是需要重新编写和编译的，但是这个步骤已经由oracle公司帮你完成了（当然也可以自己下载源码然后自己编译，并且可以修改JVM的内容，设计成你自己满意的虚拟机）\n支持多线程（ C++ 语言早期没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；\n可靠性、安全性，Java语言提供了GC-垃圾收集器，极大的便利了程序员不必设计类似于cpp中的析构函数以及对象的释放了；\n支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；\n编译与解释并存（java-\u0026gt;.class是编译，.class-\u0026gt;运行是解释），虚拟机在运行代码时首先由类加载器加载字节码文件（生成了Class对象），然后通过解释器一步步执行，虽然在字节码中已经比较偏向与底层了，但是由解释器转化为机器码仍然消耗时间，所以在执行效率上相较于cpp、go等还是稍显逊色。\n2. JVM、JDK、JRE三者的关系 JVM就是Java虚拟机，是运行字节码文件的虚拟机。但是虚拟机并不是只有一种，常用的是HotSpot（oracle的）还有J9、JRockit等都是其他公司设置的，不同的虚拟机中使用的垃圾收集器-GC的逻辑、内存模型等都有区别，我们在平时使用时使用oracle提供的就可以（最常用的）。 JRE - Java Runtime Environment，Java运行时环境，其中包含了JVM、Java类库、java命令和一些基础组件，可以直接运行字节码文件，但是不能对Java代码进行编译。 JDK - Java Development Kit，包含了JRE以及javac等命令，可以进行Java文件等编译等。 3. 注释 4. 标识符 和 关键字 7. continue、break、return的区别 三者的作用效果是不同的，continue是跳出本次循环，若循环没有满足结束条件则会继续下次循环，break是直接跳出循环，return是直接跳出方法，当return所在的方法返回值类型不为void时需要返回一个值。\n8. 成员变量与局部变量 成员变量属于类，可以使用static、final关键词进行修饰，使用static关键字修饰是变量存在于方法区，当没有采用static关键字进行修饰时，变量随对象的创建一同创建，对象存在于堆内，所以变量也存在于堆内。成员变量会由虚拟机进行一次初始化为默认值的过程，因此可以不进行初始化也能使用。\n局部变量属于方法，可以使用final进行修饰，局部变量在方法被调用时创建，同时局部变量也需要初始化后使用，因为调用方法并不会对局部变量进行默认的初始化。\n9. 静态变量 与 常量 静态变量值的是可以直接通过类进行访问的变量，与对象无关。\n当变量没有使用final进行修饰时，变量的值是可以改变的，可以通过类也可以通过对象。当使用final进行修饰后，该变量就被称为常量，因为这个变量是一个不会变化的变量，并且通过类就可以直接访问得到。\n10. 静态方法 静态方法中不可以使用非静态成员，因为静态成员在调用的时候可能还有类的对象被创建，但是非静态成员变量又存储在对象实例中，一个已经存在并且被调用的方法，是无法访问一个还没有被创造出来的对象的。\n11. 重载 与 重写 方法重写指得是将继承自父类的方向重新进行实现，而重载指的是同一个方法根据形参的不同设置不同的实现。\n1 2 3 4 5 6 7 8 9 10 11 public class A { public void method2 (){} // 重载 public void method1 (){} public void method1 (int a){} } public class B extends A{ // 重写 public void method2 (){} } 12. 可变长参数 可变长参数指的是调用方法时可以传入多个参数（参数的数量是不固定的），本质是数组是编译阶段的语法糖。\n并且一个方法只能有一个可变长参数，并且可变长参数必须是所有参数中的最后一点，可变长参数前面的参数在调用时不可省略。\n若遇到方法重载时，其中一种使用了可变长参数，两个方法同时满足调用要求时，在运行时实际调用的应该是哪个方法呢？ \u0026ndash; 答案是 优先调用不含邮可变长参数的方法。\n1 2 3 4 5 6 7 public void method (String ... args){ } // 等价 public void method (String[] args){ } 13. 包装类 包装类是基本数据类型封装得到的引用类型对象，可以在范型中使用，同时每种包装类型都对一定范围中的数据进行了封装例如Integer封装了-128，127。\n虽然进行缓存封装，但是直接采用new关键字创建对象时还是会重写去创建一个新的对象，并不会直接使用缓存中的，若想使用缓存中的可以使用valueOf方法。\n同时引用类型若存在对象比较是否相同时，一定要采用equals方法。\n14. 自动拆箱、装箱 自动拆箱会在需要使用基本类型的地方自动将封装类的对象转化为基本类型，而在需要使用封装类的地方自动进行装箱。\n浮点值存在精度问题，因为在计算机中存储的是二进制，无法表示无限不得小数位的，若想避免这种问题可以使用BigDecimal和BigInteget。\n15. 面向对象 a) 面向对象与面向过程的区别 两者的区别是解决问题的思路不同：\n面向过程是将解决问题的过程分解为一个个方法，通过一个个的调用方法来解决问题\n面向对象是根据问题抽象出一个个对象，然后用对象执行方法的方式来解决问题\n根据这两种不同的设计思路，得到了大量不同的编程语言，例如c、js等是面向过程的，Java、cpp是面向对象的。那面向过程的语言运行效率一定比面向对象高？\u0026ndash;并不一定，c与cpp的运行效率基本差不多没有很大的区别，让人感觉Java运行效率低的原因是Java是半编程语言，在编译阶段编译得到的只是字节码，并不是可以直接在计算机上运行的程序，在jvm运行时还有解释器存在，将字节码转化为机器码，很多解释型的面向过程的语言的执行效率还不如Java呢，因此语言的执行效率和语言语法的结构没有什么关系。\nb) 对象的创建 ClassTest classTest = new ClassTest()\n这是一个创建对象的语句，这句话可以分为两部分：ClassTest classTest和new ClassTest()。其中前半句话的作用是创建一个类对象的引用，若语句位于类内，则该引用会在对象创建的时候在堆内一同被创建，若语句位于方法内会在方法被调用时在虚拟机栈中创建方法的引用；后半句是使用new关键字进行对象的创建，会在堆中开辟一块区域用于存放对象，并将创建对象的位置作为引用赋予刚刚声明的引用。\nc) 对象的比较 同一个类的两个对象的比较建议使用重写后的equals方法，双等号直接比较内存中的地址，大多是情况下这是无效的（无法达到你预期的效果，除非你真多想直接比较两个对象是不是就是指向一个对象）。\nd) 构造方法 名字与类名相同。 没有返回值，但不能用 void 声明构造函数。 生成类的对象时自动执行，无需调用。 可以重载，不能重写，可以使用super调用父类的构造方法 16. 面向对象的三大特征 封装、继承、多态\n封装 封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性，通常指的是getset方法\n继承 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有，这点可以通过Class对象进行验证。 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法（重写）。 Java只支持单继承、但可以实现多个接口 多态 表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。\n多态的特点:\n对象类型和引用类型之间具有继承（类）/实现（接口）的关系； 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定； 多态不能调用“只在子类存在但在父类不存在”的方法； 如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public interface A{ public void method(); } public class B implements A{ public void method(){ System.out.println(\u0026#34;B\u0026#34;); } } public class C implements A{ public void method(){ System.out.println(\u0026#34;C\u0026#34;); } } // main函数 public static void main(String ... args){ A a = new B(); a.method();// 输出B } 接口和抽象类的共同点和区别 共同点 ：\n都不能被实例化。 都可以包含抽象方法。 都可以有默认实现的方法（Java 8 可以用 default 关键字在接口中定义默认方法）。 区别 ：\n接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。（因此在各大开源框架中常用的结构都是通过接口定义较为底层的接口，然后采用抽象类继承接口提供一个基础的实现类，然后用户可以继承抽象类进行实现，通常此时用户只需要实现核心方法即可） 一个类只能继承一个类，但是可以实现多个接口。 接口中的成员变量只能是 public static final 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值 17. 引用拷贝、浅拷贝、深拷贝 浅拷贝与深拷贝都需要实现Cloneable接口，区别在于clone方法的实现，深拷贝需要调用每一个引用类型对象的clone方法（都实现的情况下）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 // Object的clone方法是protected修饰的，因此需要重写并且权限改为public才能调用clone方法 // 浅拷贝 为了代码的简洁使用了lombok @AllArgsConstructor @NoArgsConstructor @Getter @Setter class A implements Cloneable{ private int id; private String name; private B b; @Override public A clone() throws CloneNotSupportedException { A a = new A(); a.id = this.id; a.name = this.name; a.b = this.b; return a; } } @Getter @Setter @AllArgsConstructor class B { private int id; } public static void main(String[] args) throws CloneNotSupportedException { A a1 = new A(2, \u0026#34;king\u0026#34;, new B(44)); A a2= a1.clone(); System.out.println(a1.getB().hashCode() == a2.getB().hashCode());// true System.out.println(a2.getB().getId());//44 a1.getB().setId(77); System.out.println(a2.getB().getId());//77 // 这个地方就是深浅拷贝的区别，浅拷贝中的引用类型都是指向的同一个对象，一个改变了另一个就改变了，String不用担心，因为String本身是不可变的不存在这个问题。 } // 深拷贝 @AllArgsConstructor @NoArgsConstructor @Getter @Setter class A implements Cloneable{ private int id; private String name; private B b; @Override public A clone() throws CloneNotSupportedException { A a = new A(); a.id = this.id; a.name = this.name; a.b = this.b.clone(); return a; } } @Getter @Setter @AllArgsConstructor class B implements Cloneable{ private int id; @Override public B clone() throws CloneNotSupportedException { B b = new B(this.id); return b; } } public static void main(String[] args) throws CloneNotSupportedException { A a1 = new A(2, \u0026#34;king\u0026#34;, new B(44)); A a2= a1.clone(); System.out.println(a1.getB().hashCode() == a2.getB().hashCode());// false System.out.println(a2.getB().getId());//44 a1.getB().setId(77); System.out.println(a2.getB().getId());//44 } 18. String、StringBuffer、StringBuilder 可变性\nString 是不可变的（后面会详细分析原因）。\nStringBuilder 与 StringBuffer 是可变的，都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串，不过没有使用 final 和 private 关键字修饰。\n线程安全性\nString 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。\n性能\n每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。\n对于三者使用的总结：\n操作少量的数据: 适用 String 单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder 多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer 我们知道被 final 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，final 关键字修饰的数组保存字符串并不是 String不可变的根本原因，因为这个数组保存的字符串是可变的（final 修饰引用类型变量的情况）。\nString 真正不可变有下面几点原因：\n保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供/暴露修改这个字符串的方法。 String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。 JVM重载了+运算符，可以用于字符串的相加，本质上字符串的相加编译器还是会转化为StringBuffer调用append方法，但是在循环中不断使用+时，编译器并不会自动进行优化，创建一个StringBuffer进行相加，此时在循环中会不断创建新的StringBuffer，这时候自己创建StringBuffer进行优化是有必要的。\n19. Exception、Error 异常使用有哪些需要注意的地方？ 不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。 抛出的异常信息一定要有意义。 建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出NumberFormatException而不是其父类IllegalArgumentException。 使用日志打印异常之后就不要再抛出异常了（两者不要同时存在一段代码逻辑中）。 20. 泛型 21. 反射 22. 注解 何谓注解？ Annotation （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。\n注解本质是一个继承了Annotation 的特殊接口：\n1 2 3 4 5 6 7 8 9 @Target(ElementType.METHOD) @Retention(RetentionPolicy.SOURCE) public @interface Override { } public interface Override extends Annotation{ } JDK 提供了很多内置的注解（比如 @Override 、@Deprecated），同时，我们还可以自定义注解。\n注解的解析方法有哪种？ 注解只有被解析之后才会生效，常见的解析方法有两种：\n编译期直接扫描 ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用@Override 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。 运行期通过反射处理 ：像框架中自带的注解(比如 Spring 框架的 @Value 、@Component)都是通过反射来进行处理的。 23. 值传递 在c++中存在值传递与引用传递，但是在Java中只存在值传递。\n概念 值传递：值传递指的是在方法调用时，实参中传递的是具体的值，在方法中得到的值是拷贝变量后得到的。 引用传递：与值传递不同的是，引用传递在实惨中传递的不是拷贝后的变量，而是将方法调用中的变量地址直接进行传递。 值传递的差异与引用传递的差异类似上图，以常见的引用类型为例，若是值传递，则在被调用方法中获取到的是指向对象的地址的一个副本，效果就是两个调用方法与被调用方法中的两个变量都指向了同一个对象，在被调用方法中更改对象的值，在调用方法指向的对象同样更改了。\n通常在编程语言中，创建一个引用都是在栈中开辟一块内存地址，该内存地址将会指向堆中的的一个对象。而上图中a1实际上就是一个名称，指向栈中的引用，而引用传递就是新设置一个名称同样适用的是这一个引用。\n上述两者的区别就是，指向堆内存的地址是拷贝一个新的还是公用同一个。\n24. Java序列化 25. 泛型、通配符 26. Java反射机制 27. BigDecimal 28. Maven maven项目最核心的就是pom文件，学习maven的使用就是学习pom的编写。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;org.example\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;MavenTest\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/project\u0026gt; groupId、artifactId、version这三个元素合在一起，用于唯一区别每个项目，别人如果需要将我们编写的代码作为依赖，那么就必须通过这三个元素来定位我们的项目，我们称为一个项目的基本坐标，所有的项目一般都有自己的Maven坐标，因此我们通过Maven导入其他的依赖只需要填写这三个基本元素就可以了，无需再下载Jar文件，而是Maven自动帮助我们下载依赖并导入。\ngroupId 一般用于指定组名称，命名规则一般和包名一致，比如我们这里使用的是org.example，一个组下面可以有很多个项目。\nartifactId 一般用于指定项目在当前组中的唯一名称，也就是说在组中用于区分于其他项目的标记。\nversion 代表项目版本，随着我们项目的开发和改进，版本号也会不断更新，就像LOL一样，每次赛季更新都会有一个大版本更新，我们的Maven项目也是这样，我们可以手动指定当前项目的版本号，其他人使用我们的项目作为依赖时，也可以根本版本号进行选择（这里的SNAPSHOT代表快照，一般表示这是一个处于开发中的项目，正式发布项目一般只带版本号）\nproperties中一般都是一些变量和选项的配置，我们这里指定了JDK的源代码和编译版本为1.8，无需进行修改。\n依赖导入 1 2 3 \u0026lt;dependencies\u0026gt; //里面填写的就是所有的依赖 \u0026lt;/dependencies\u0026gt; 在dependencies中填写需要使用到的依赖，例如：\n1 2 3 4 5 6 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.22\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; 在dependency中除了三个基本的属性用于定位坐标外，依赖还可以添加以下属性：\ntype：依赖的类型，对于项目坐标定义的packaging。大部分情况下，该元素不必声明，其默认值为jar\nscope：依赖的范围（作用域，着重讲解）\noptional：标记依赖是否可选\nexclusions：用来排除传递性依赖（一个项目有可能依赖于其他项目，就像我们的项目，如果别人要用我们的项目作为依赖，那么就需要一起下载我们项目的依赖，如Lombok）\n我们着重来讲解一下scope属性，它决定了依赖的作用域范围：\ncompile ：为默认的依赖有效范围。如果在定义依赖关系的时候，没有明确指定依赖有效范围的话，则默认采用该依赖有效范围。此种依赖，在编译、运行、测试时均有效。\nprovided ：在编译、测试时有效，但是在运行时无效，也就是说，项目在运行时，不需要此依赖，比如我们上面的Lombok，我们只需要在编译阶段使用它，编译完成后，实际上已经转换为对应的代码了，因此Lombok不需要在项目运行时也存在。\nruntime ：在运行、测试时有效，但是在编译代码时无效。比如我们如果需要自己写一个JDBC实现，那么肯定要用到JDK为我们指定的接口，但是实际上在运行时是不用自带JDK的依赖，因此只保留我们自己写的内容即可。\ntest ：只在测试时有效，例如：JUnit，我们一般只会在测试阶段使用JUnit，而实际项目运行时，我们就用不到测试了，那么我们来看看，导入JUnit的依赖：\n那么就有人提问了，如果我需要的依赖没有上传的远程仓库，而是只有一个Jar怎么办呢？我们可以使用第四种作用域：\nsystem：作用域和provided是一样的，但是它不是从远程仓库获取，而是直接导入本地Jar包： 1 2 3 4 5 6 7 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.jntm\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lbwnb\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;system\u0026lt;/scope\u0026gt; \u0026lt;systemPath\u0026gt;C://学习资料/4K高清无码/test.jar\u0026lt;/systemPath\u0026gt; \u0026lt;/dependency\u0026gt; Maven可选依赖 当项目中的某些依赖不希望被使用此项目作为依赖的项目使用时，我们可以给依赖添加optional标签表示此依赖是可选的，默认在导入依赖时，不会导入可选的依赖：\n1 \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; Maven排除依赖 我们了解了可选依赖，现在我们可以让使用此项目作为依赖的项目默认不使用可选依赖，但是如果存在那种不是可选依赖，但是我们导入此项目有不希望使用此依赖该怎么办呢，这个时候我们就可以通过排除依赖来防止添加不必要的依赖：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.junit.jupiter\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-jupiter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.8.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.junit.jupiter\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-jupiter-engine\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; Maven继承关系 在idea中可以通过新建模块来创建子模块，父子模块的pom文件均会发生变化：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!-- 父 --\u0026gt; \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;ChildModel\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; \u0026lt;!-- 子 --\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;artifactId\u0026gt;MavenTest\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;org.example\u0026lt;/groupId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; 子模块会之间继承父模块的dependencies部分。\nMaven常用命令 我们可以看到在IDEA右上角Maven板块中，每个Maven项目都有一个生命周期，实际上这些是Maven的一些插件，每个插件都有各自的功能，比如：\nclean命令，执行后会清理整个target文件夹，在之后编写Springboot项目时可以解决一些缓存没更新的问题。\nvalidate命令可以验证项目的可用性。\ncompile命令可以将项目编译为.class文件。\ninstall命令可以将当前项目安装到本地仓库，以供其他项目导入作为依赖使用\nverify命令可以按顺序执行每个默认生命周期阶段（validate，compile，package等）\nMaven测试项目 通过使用test命令，可以一键测试所有位于test目录下的测试案例，请注意有以下要求：\n测试类的名称必须是以Test结尾，比如MainTest\n测试方法上必须标注@Test注解，实测@RepeatedTest无效\nMaven打包项目 我们的项目在编写完成之后，要么作为Jar依赖，供其他模型使用，要么就作为一个可以执行的程序，在控制台运行，我们只需要直接执行package命令就可以直接对项目的代码进行打包，生成jar文件。\n29. SPI 机制 30. 语法糖 语法糖的本质是简化开发人员代码书写的，并且在编译阶段就会被编译器转化为普通的语法，我们平时使用的例如foreach、可变长参数、使用String的swatch、枚举类等等，都是通过语法糖实现的。\n31. 集合总结 底层实现 List ArrayList： Object[] 数组 Vector：Object[] 数组 LinkedList： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环) ArrayList 和 Vector 的区别? ArrayList 是 List 的主要实现类，底层使用 Object[]存储，适用于频繁的查找工作，线程不安全 ； Vector 是 List 的古老实现类，底层使用Object[] 存储，线程安全的 ArrayList 与 LinkedList 区别? 是否保证线程安全： ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全； 底层数据结构： ArrayList 底层使用的是 Object 数组；LinkedList 底层使用的是 双向链表 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。） 插入和删除是否受元素位置的影响： ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 LinkedList 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（add(E e)、addFirst(E e)、addLast(E e)、removeFirst() 、 removeLast()），时间复杂度为 O(1)，如果是要在指定位置 i 插入和删除元素的话（add(int index, E element)，remove(Object o)）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入。 是否支持快速随机访问： LinkedList 不支持高效的随机元素访问，而 ArrayList（实现了RandomAccess接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。 内存空间占用： ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。 我们在项目中一般是不会使用到 LinkedList 的，需要用到 LinkedList 的场景几乎都可以使用 ArrayList 来代替，并且，性能通常会更好！就连 LinkedList 的作者约书亚 · 布洛克（Josh Bloch）自己都说从来不会使用 LinkedList 。\n另外，不要下意识地认为 LinkedList 作为链表就最适合元素增删的场景。我在上面也说了，LinkedList 仅仅在头尾插入或者删除元素的时候时间复杂度近似 O(1)，其他情况增删元素的时间复杂度都是 O(n) 。\n补充内容:RandomAccess 接口 1 2 public interface RandomAccess { } 查看源码我们发现实际上 RandomAccess 接口中什么都没有定义。所以，在我看来 RandomAccess 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。\n在 binarySearch() 方法中，它要判断传入的 list 是否 RandomAccess 的实例，如果是，调用indexedBinarySearch()方法，如果不是，那么调用iteratorBinarySearch()方法\n1 2 3 4 5 6 7 public static \u0026lt;T\u0026gt; int binarySearch(List\u0026lt;? extends Comparable\u0026lt;? super T\u0026gt;\u0026gt; list, T key) { if (list instanceof RandomAccess || list.size()\u0026lt;BINARYSEARCH_THRESHOLD) return Collections.indexedBinarySearch(list, key); else return Collections.iteratorBinarySearch(list, key); } ArrayList 实现了 RandomAccess 接口， 而 LinkedList 没有实现。为什么呢？我觉得还是和底层数据结构有关！ArrayList 底层是数组，而 LinkedList 底层是链表。数组天然支持随机访问，时间复杂度为 O(1)，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n)，所以不支持快速随机访问。，ArrayList 实现了 RandomAccess 接口，就表明了他具有快速随机访问功能。 RandomAccess 接口只是标识，并不是说 ArrayList 实现 RandomAccess 接口才具有快速随机访问功能的！\n说一说 ArrayList 的扩容机制吧 见这篇文章:ArrayList 扩容机制分析open in new window\nSet HashSet(无序，唯一): 基于 HashMap 实现的，底层采用 HashMap 来保存元素 LinkedHashSet: LinkedHashSet 是 HashSet 的子类，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的 LinkedHashMap 其内部是基于 HashMap 实现一样，不过还是有一点点区别的 TreeSet(有序，唯一): 红黑树(自平衡的排序二叉树) Comparable 和 Comparator 的区别 comparable接口实际上是出自java.lang包,它有一个compareTo(Object obj)方法用来排序 comparator接口实际上是出自java.util包,它有一个compare(Object obj1, Object obj2)方法用来排序 以Arrays.sort方法对两种方法对使用为例，在对一般的Ojbect[]进行排序的时候，可以直接使用sort方法，在方法中会去判断时候是Comparable类型子类，若不是该类型的子类时会报ClassCastException错，此时就需要实现该接口，并且实现compareTo方法用于排序。有时候需要进行排序但是类又是别人实现好的不方便再去实现Comparable接口，此时Comparator接口就派上了用处。\n在Arrays中还有一种sort方法的实现：\u0026lt;T\u0026gt; void sort(T[] a, Comparator\u0026lt;? super T\u0026gt; c)，使用时可以再传入一个Comparator实现类的对象用于排队（一般都是直接用匿名内部实现了，不会专门去定义一个真正的类），在方法中就会调用这个实现类的compare方法进行排序。\n比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同 HashSet、LinkedHashSet 和 TreeSet 都是 Set 接口的实现类，都能保证元素唯一，并且都不是线程安全的。 HashSet、LinkedHashSet 和 TreeSet 的主要区别在于底层数据结构不同。HashSet 的底层数据结构是哈希表（基于 HashMap 实现）。LinkedHashSet 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。TreeSet 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。 底层数据结构不同又导致这三者的应用场景不同。HashSet 用于不需要保证元素插入和取出顺序的场景，LinkedHashSet 用于保证元素的插入和取出顺序满足 FIFO 的场景，TreeSet 用于支持对元素自定义排序规则的场景。 Queue PriorityQueue: Object[] 数组来实现二叉堆 ArrayQueue: Object[] 数组 + 双指针 Queue 与 Deque 的区别 Queue 是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循 先进先出（FIFO） 规则。\nQueue 扩展了 Collection 的接口，根据 因为容量问题而导致操作失败后处理方式的不同 可以分为两类方法: 一种在操作失败后会抛出异常，另一种则会返回特殊值。\nQueue 接口 抛出异常 返回特殊值 插入队尾 add(E e) offer(E e) 删除队首 remove() poll() 查询队首元素 element() peek() Deque 是双端队列，在队列的两端均可以插入或删除元素。\nDeque 扩展了 Queue 的接口, 增加了在队首和队尾进行插入和删除的方法，同样根据失败后处理方式的不同分为两类：\nDeque 接口 抛出异常 返回特殊值 插入队首 addFirst(E e) offerFirst(E e) 插入队尾 addLast(E e) offerLast(E e) 删除队首 removeFirst() pollFirst() 删除队尾 removeLast() pollLast() 查询队首元素 getFirst() peekFirst() 查询队尾元素 getLast() peekLast() 事实上，Deque 还提供有 push() 和 pop() 等其他方法，可用于模拟栈。\nArrayDeque 与 LinkedList 的区别 ArrayDeque 和 LinkedList 都实现了 Deque 接口，两者都具有队列的功能，但两者有什么区别呢？\nArrayDeque 是基于可变长的数组和双指针来实现，而 LinkedList 则通过链表来实现。 ArrayDeque 不支持存储 NULL 数据，但 LinkedList 支持。 ArrayDeque 是在 JDK1.6 才被引入的，而LinkedList 早在 JDK1.2 时就已经存在。 ArrayDeque 插入时可能存在扩容过程, 不过均摊后的插入操作依然为 O(1)。虽然 LinkedList 不需要扩容，但是每次插入数据时均需要申请新的堆空间，均摊性能相比更慢。 从性能的角度上，选用 ArrayDeque 来实现队列要比 LinkedList 更好。此外，ArrayDeque 也可以用于实现栈。\nPriorityQueue PriorityQueue 是在 JDK1.5 中被引入的, 其与 Queue 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。\n这里列举其相关的一些要点：\nPriorityQueue 利用了二叉堆的数据结构来实现的，底层使用可变长的数组来存储数据 PriorityQueue 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。 PriorityQueue 是非线程安全的，且不支持存储 NULL 和 non-comparable 的对象。 PriorityQueue 默认是小顶堆，但可以接收一个 Comparator 作为构造参数，从而来自定义元素优先级的先后。 PriorityQueue 在面试中可能更多的会出现在手撕算法的时候，典型例题包括堆排序、求第K大的数、带权图的遍历等，所以需要会熟练使用才行。\nMap HashMap： JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间 LinkedHashMap： LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：《LinkedHashMap 源码详细分析（JDK1.8）》open in new window Hashtable： 数组+链表组成的，数组是 Hashtable 的主体，链表则是主要为了解决哈希冲突而存在的 TreeMap： 红黑树（自平衡的排序二叉树） ","permalink":"https://jinchaojjj.github.io/posts/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/java%E5%9F%BA%E7%A1%80%E6%8F%90%E5%8D%87/","summary":"1. Java语言的特点 简单易学，相较于python等语言具有较好的严谨性以及报错机制； 面向对象（封装，继承，多态），Java中所有内容都是基于","title":"Java基本提升"},{"content":"设计模式 常见的设计模式有23种，分别分为3种类型：创建型、结构型和行为型。具体的设计模式如下：\n创建型模式（5种）：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式（7种）：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式（11种）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式和解释器模式。\n首先先推荐一个设计模式的网站：refactoring guru\n1. 设计原则 开闭原则 软件实体应当对扩展开放，对修改关闭。其中，对扩展开放是针对提供方来说的，对修改关闭是针对调用方来说的。\n开闭原则的两个要求：对扩展开放，对修改关闭。简单来说就是当软件、系统需要新的功能的时候可以不修改原有的代码就可以实现功能上的扩展。\n里氏替换原则 所有引用基类的地方必须能透明地使用其子类的对象。\n简单的说就是，子类可以扩展父类的功能，但不能改变父类原有的功能：\n子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。 子类可以增加自己特有的方法。 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入/入参）要比父类方法的输入参数更宽松。 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的输出/返回值）要比父类更严格或与父类一样。 下面代码对基类功能进行了扩展，符合里氏替换原则：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public abstract class Coder { public void coding() { System.out.println(\u0026#34;我会打代码\u0026#34;); } class JavaCoder extends Coder{ /** * 子类除了会打代码之外，还会打游戏 */ public void game(){ System.out.println(\u0026#34;艾欧尼亚最强王者已上号\u0026#34;); } } } 下面代码对基类方法进行了覆盖，违背了里氏替换原则：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public abstract class Coder { public void coding() { System.out.println(\u0026#34;我会打代码\u0026#34;); } class JavaCoder extends Coder{ public void game(){ System.out.println(\u0026#34;艾欧尼亚最强王者已上号\u0026#34;); } /** * 这里我们对父类的行为进行了重写，现在它不再具备父类原本的能力了 */ public void coding() { System.out.println(\u0026#34;摆烂了，啊对对对\u0026#34;); } } } 依赖倒转原则 高层模块不应该依赖低层模块，二者都应该依赖其抽象。 抽象不应该依赖细节，细节应该依赖抽象。 依赖倒转的中心思想是面向接口编程。 依赖倒转的设计理念为：相对于细节的多变性，抽象的东西要稳定的多。以抽象的基础搭建的架构比以细节为基础的架构要稳定的多。在java中，抽象指的是接口或抽象类，细节就是具体的实现类。 使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。 依赖倒转原则（Dependence Inversion Principle）也是我们一直在使用的，最明显的就是我们的Spring框架了。\n三种实现方式 下面的案例中实现的是IOpenAndClose接口的实现类对ITV接口的对象进行控制，就是IOpenAndClose使用ITV。\n接口传递：\n1 2 3 4 5 6 7 8 9 10 11 12 13 interface IOpenAndClose { public void open(ITV tv); } interface ITV { public void play(); } class OpenAndClose implements IOpenAndClose { @Override public void open(ITV tv) { tv.play(); } } 构造方法传递：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 interface IOpenAndClose { public void open(); } interface ITV { public void play(); } class OpenAndClose implements IOpenAndClose { private ITV tv; public OpenAndClose(ITV tv) { this.tv = tv; } @Override public void open() { this.tv.play(); } } setter方法传递\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 interface IOpenAndClose { public void open(); public void setTv(ITV tv); } interface ITV { public void play(); } class OpenAndClose implements IOpenAndClose { private ITV tv; @Override public void setTv(ITV tv) { this.tv = tv; } @Override public void open() { this.tv.play(); } } 可以看到三种实现方法中都不是在OpenAndClose中将需要使用的对象写死（强耦合），而是在运行时通过构造函数等方式动态等获得该对象，然后通过open方法进行控制。Spring中本质也是通过setter方法或者构造函数完成注入的。\n接口隔离原则 接口隔离原则（Interface Segregation Principle, ISP）实际上是对接口的细化。\n客户端只依赖于它所需要的接口；它需要什么接口就提供什么接口，把不需要的接口剔除掉。\n类间的依赖关系应建立在最小的接口上。\n也就是说: 接口尽量细化，接口中的方法尽量少\n我们在定义接口的时候，一定要注意控制接口的粒度，比如下面的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 interface Device { String getCpu(); String getType(); String getMemory(); } //电脑就是一种电子设备，那么我们就实现此接口 class Computer implements Device { @Override public String getCpu() { return \u0026#34;i9-12900K\u0026#34;; } @Override public String getType() { return \u0026#34;电脑\u0026#34;; } @Override public String getMemory() { return \u0026#34;32G DDR5\u0026#34;; } } //电风扇也算是一种电子设备 class Fan implements Device { @Override public String getCpu() { return null; //就一个破风扇，还需要CPU？ } @Override public String getType() { return \u0026#34;风扇\u0026#34;; } @Override public String getMemory() { return null; //风扇也不需要内存吧 } } 虽然我们定义了一个Device接口，但是由于此接口的粒度不够细，虽然比较契合电脑这种设备，但是不适合风扇这种设备，因为风扇压根就不需要CPU和内存，所以风扇完全不需要这些方法。这时我们就必须要对其进行更细粒度的划分：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 interface SmartDevice { //智能设备才有getCpu和getMemory String getCpu(); String getType(); String getMemory(); } interface NormalDevice { //普通设备只有getType String getType(); } class Computer implements SmartDevice { @Override public String getCpu() { return \u0026#34;i9-12900K\u0026#34;; } @Override public String getType() { return \u0026#34;电脑\u0026#34;; } @Override public String getMemory() { return \u0026#34;32G DDR5\u0026#34;; } } class Fan implements NormalDevice { @Override public String getType() { return \u0026#34;风扇\u0026#34;; } } 这样，我们就将接口进行了细粒度的划分，不同类型的电子设备就可以根据划分去实现不同的接口了。当然，也不能划分得太小，还是要根据实际情况来进行决定。\n单一职责原则 单一职责原则（Simple Responsibility Pinciple，SRP）是最简单的面向对象设计原则，它用于控制类的粒度大小。\n一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。\n比如我们现在有一个People类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //一个人类 public class People { /** * 人类会编程 */ public void coding(){ System.out.println(\u0026#34;int mian() {\u0026#34;); System.out.println(\u0026#34; printf(\\\u0026#34;Holle Wrold!\\\u0026#34;);\u0026#34;); System.out.println(\u0026#34;}\u0026#34;); System.out.println(\u0026#34;啊嘞，怎么运行不起？明明照着老师敲的啊\u0026#34;); } /** * 工厂打螺丝也会 */ public void work(){ System.out.println(\u0026#34;真开心，能进到富土康打螺丝\u0026#34;); System.out.println(\u0026#34;诶，怎么工友都提桶跑路了\u0026#34;); } /** * 送外卖也会 */ public void ride(){ System.out.println(\u0026#34;今天终于通过美团最终面，加入了梦寐以求的大厂了\u0026#34;); System.out.println(\u0026#34;感觉面试挺简单的，就是不知道为啥我同学是现场做一道力扣接雨水，而我是现场问会不会骑车\u0026#34;); System.out.println(\u0026#34;（迫不及待穿上外卖服装）\u0026#34;); } } 复制代码 我们可以看到，这个People类可以说是十八般武艺样样精通了，啥都会，显然这个People太过臃肿（我们需要修改任意一种行为都需要修改People类，它拥有不止一个引起它变化的原因），所以根据单一职责原则，我们下需要进行更明确的划分，同种类型的操作我们一般才放在一起：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Coder{ /** * 程序员会编程 */ public void coding(){ System.out.println(\u0026#34;int mian() {\u0026#34;); System.out.println(\u0026#34; printf(\\\u0026#34;Hello World!\\\u0026#34;)\u0026#34;); System.out.println(\u0026#34;}\u0026#34;); System.out.println(\u0026#34;啊嘞，怎么运行不起？明明照着老师敲的啊\u0026#34;); } } class Worker{ /** * 工人会打螺丝 */ public void work(){ System.out.println(\u0026#34;真开心，能进到富土康打螺丝\u0026#34;); System.out.println(\u0026#34;诶，怎么工友都提桶跑路了\u0026#34;); } } class Rider { /** * 骑手会送外卖 */ public void ride(){ System.out.println(\u0026#34;今天终于通过美团最终面，加入了梦寐以求的大厂\u0026#34;); System.out.println(\u0026#34;感觉面试挺简单的，就是不知道为啥我同学是现场做一道力扣接雨水，我是现场问会不会骑车\u0026#34;); System.out.println(\u0026#34;（迫不及待穿上外卖服装）\u0026#34;); } } 复制代码 我们将类的粒度进行更近一步的划分，这样就很清晰了，包括我们以后在设计Mapper、Service、Controller等等，根据不同的业务进行划分，都可以采用单一职责原则，以它作为我们实现高内聚低耦合的指导方针。实际上我们的微服务也是参考了单一职责原则，每个微服务只应担负一个职责。\n合成复用原则 合成复用原则（Composite Reuse Principle）的核心就是委派。\n优先使用对象组合，而不是通过继承来达到复用的目的。\n在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分，新的对象通过向这些对象的委派达到复用已有功能的目的。实际上我们在考虑将某个类通过继承关系在子类得到父类已经实现的方法之外（比如A类实现了连接数据库的功能，恰巧B类中也需要，我们就可以通过继承来获得A已经写好的连接数据库的功能，这样就能直接复用A中已经写好的逻辑）我们应该应该优先地去考虑使用合成的方式来实现复用。\n比如下面这个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 class A { public void connectDatabase(){ System.out.println(\u0026#34;我是连接数据库操作！\u0026#34;); } } class B extends A{ //直接通过继承的方式，得到A的数据库连接逻辑 public void test(){ System.out.println(\u0026#34;我是B的方法，我也需要连接数据库！\u0026#34;); connectDatabase(); //直接调用父类方法就行 } } 虽然这样看起来没啥毛病，但是还是存在我们之前说的那个问题，耦合度太高了。\n可以看到通过继承的方式实现复用，我们是将类B直接指定继承自类A的，那么如果有一天，由于业务的更改，我们的数据库连接操作，不再由A来负责，而是由新来的C去负责，那么这个时候，我们就不得不将需要复用A中方法的子类全部进行修改，很显然这样是费时费力的。\n并且还有一个问题就是，通过继承子类会得到一些父类中的实现细节，比如某些字段或是方法，这样直接暴露给子类，并不安全。\n所以，当我们需要实现复用时，可以优先考虑以下操作：\n1 2 3 4 5 6 7 8 9 10 11 12 class A { public void connectDatabase(){ System.out.println(\u0026#34;我是连接数据库操作！\u0026#34;); } } class B { //不进行继承，而是在用的时候给我一个A，当然也可以抽象成一个接口，更加灵活 public void test(A a){ System.out.println(\u0026#34;我是B的方法，我也需要连接数据库！\u0026#34;); a.connectDatabase(); //在通过传入的对象A去执行 } } 或是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class A { public void connectDatabase(){ System.out.println(\u0026#34;我是连接数据库操作！\u0026#34;); } } class B { A a; public B(A a){ //在构造时就指定好 this.a = a; } public void test(){ System.out.println(\u0026#34;我是B的方法，我也需要连接数据库！\u0026#34;); a.connectDatabase(); //也是通过对象A去执行 } } 通过对象之间的组合，我们就大大降低了类之间的耦合度，并且A的实现细节我们也不会直接得到了。\n迪米特法则 迪米特法则（Law of Demeter）又称最少知识原则，是对程序内部数据交互的限制。\n每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。\n简单来说就是，一个类/模块对其他的类/模块有越少的交互越好。当一个类发生改动，那么，与其相关的类（比如用到此类啥方法的类）需要尽可能少的受影响（比如修改了方法名、字段名等，可能其他用到这些方法或是字段的类也需要跟着修改）这样我们在维护项目的时候会更加轻松一些，我们还是来看一个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Main { public static void main(String[] args) throws IOException { Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 8080); //假设我们当前的程序需要进行网络通信 Test test = new Test(); test.test(socket); //现在需要执行test方法来做一些事情 } static class Test { /** * 比如test方法需要得到我们当前Socket连接的本地地址 */ public void test(Socket socket){ System.out.println(\u0026#34;IP地址：\u0026#34;+socket.getLocalAddress()); } } } 可以看到，虽然上面这种写法没有问题，我们提供直接提供一个Socket对象，然后再由test方法来取出IP地址，但是这样显然违背了迪米特法则，实际上这里的test方法只需要一个IP地址即可，我们完全可以直接传入一个字符串，而不是整个Socket对象，我们需要保证与其他类的交互尽可能的少。\n要是某一天，Socket类中的这些方法发生修改了，那我们就得连带着去修改这些类，很麻烦。所以，我们来改进改进：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class Main { public static void main(String[] args) throws IOException { Socket socket = new Socket(\u0026#34;localhost\u0026#34;, 8080); Test test = new Test(); test.test(socket.getLocalAddress().getHostAddress()); //在外面解析好就行了 } static class Test { public void test(String str){ //一个字符串就能搞定，就没必要丢整个对象进来 System.out.println(\u0026#34;IP地址：\u0026#34;+str); } } } 这样，类与类之间的耦合度再次降低。\n2. UML类图 3. 创建型 创建型的设计模式是有关于对象创建的，创建型的设计模式一种有五种：\n工厂方法模式 抽象工厂模式 建造者模式 单例模式 原型模式 工厂模式 简单工厂、工厂方法模式、抽象工厂模式三者的区别 原文，下面对原文的内容做出总结：\n简单工厂模式：描述了一个类，在类中包含一个大量条件语句的构造方法，方法可以通过参数来选择何种产品进行初始化并将其返回。（简单工厂模式通常是引入工厂方法、抽象工厂模式时的一个中间步骤，两种工厂模式通过继承的方式提供了多种不同对象的创建方法，但是并没有提供进行对象选择的方法；此时采用简单工厂进行工厂的选择是非常好的）\n工厂方法模式：是一种创建型设计模式，在父类工厂中提供了一个创建对象的方法，允许子类决定实例化对象的类型\n抽象工厂模式：用来创建一系列相关或者相互依赖的对象，而无需指定具体类；用网站中介绍抽象工厂时的例子进行讲解：当客户端需要三种相同风格的家具时，创建不同风格家具的工厂类，在工厂类中对产生的家具的风格进行统一，用户只要选择好风格后，从该工厂中获得的家具风格是统一的（也就是定义中所说的相互依赖的）\n3. 结构型设计模式 ","permalink":"https://jinchaojjj.github.io/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","summary":"设计模式 常见的设计模式有23种，分别分为3种类型：创建型、结构型和行为型。具体的设计模式如下： 创建型模式（5种）：工厂方法模式、抽象工厂模式","title":"设计模式"},{"content":"Maven 1. 什么是Maven maven是一个项目管理工具，可以对Java项目进行构建、依赖管理（也可以构建和管理其他语言的项目）\n2. Maven的主要功能 构建 文档生成 报告 依赖 3. Maven约定的目录结构 目录 目的 ${basedir} 存放pom.xml和所有的子目录 ${basedir}/src/main/java 项目的java源代码 ${basedir}/src/main/resources 项目的资源，比如说property文件，springmvc.xml ${basedir}/src/test/java 项目的测试类，比如说Junit代码 ${basedir}/src/test/resources 测试用的资源 ${basedir}/src/main/webapp/WEB-INF web应用文件目录，web项目的信息，比如存放web.xml、本地图片、jsp视图页面 ${basedir}/target 打包输出目录 ${basedir}/target/classes 编译输出目录 ${basedir}/target/test-classes 测试编译输出目录 Test.java Maven只会自动运行符合该命名规则的测试类 ~/.m2/repository Maven默认的本地仓库目录位置 4. Maven POM POM( Project Object Model，项目对象模型 ) 是 Maven 工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。\n执行任务或目标时，Maven 会在当前目录中查找 POM。它读取 POM，获取所需的配置信息，然后执行目标。\nPOM 中可以指定以下配置：\n项目依赖 插件 执行目标 项目构建 profile 项目版本 项目开发者列表 相关邮件列表信息 在创建 POM 之前，我们首先需要描述项目组 (groupId), 项目的唯一ID。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;project xmlns = \u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi = \u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation = \u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;!-- 模型版本 --\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --\u0026gt; \u0026lt;groupId\u0026gt;com.companyname.project-group\u0026lt;/groupId\u0026gt; \u0026lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --\u0026gt; \u0026lt;artifactId\u0026gt;project\u0026lt;/artifactId\u0026gt; \u0026lt;!-- 版本号 --\u0026gt; \u0026lt;version\u0026gt;1.0\u0026lt;/version\u0026gt; \u0026lt;/project\u0026gt; 所有 POM 文件都需要 project 元素和三个必需字段：groupId，artifactId，version。\n节点 描述 project 工程的根标签。 modelVersion 模型版本需要设置为 4.0。 groupId 这是工程组的标识。它在一个组织或者项目中通常是唯一的。例如，一个银行组织 com.companyname.project-group 拥有所有的和银行相关的项目。 artifactId 这是工程的标识。它通常是工程的名称。例如，消费者银行。groupId 和 artifactId 一起定义了 artifact 在仓库中的位置。 version 这是工程的版本号。在 artifact 的仓库中，它用来区分不同的版本。例如：com.company.bank:consumer-banking:1.0 com.company.bank:consumer-banking:1.1 父（Super）POM是 Maven 默认的 POM。所有的 POM 都继承自一个父 POM（无论是否显式定义了这个父 POM）。父 POM 包含了一些可以被继承的默认设置。因此，当 Maven 发现需要下载 POM 中的 依赖时，它会到 Super POM 中配置的默认仓库 http://repo1.maven.org/maven2 去下载。\nMaven 使用 effective pom（Super pom 加上工程自己的配置）来执行相关的目标，它帮助开发者在 pom.xml 中做尽可能少的配置，当然这些配置可以被重写。\nPOM标签大全：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd\u0026#34;\u0026gt; \u0026lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 version。 --\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;!--被继承的父项目的构件标识符 --\u0026gt; \u0026lt;artifactId /\u0026gt; \u0026lt;!--被继承的父项目的全球唯一标识符 --\u0026gt; \u0026lt;groupId /\u0026gt; \u0026lt;!--被继承的父项目的版本 --\u0026gt; \u0026lt;version /\u0026gt; \u0026lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 --\u0026gt; \u0026lt;relativePath /\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app --\u0026gt; \u0026lt;groupId\u0026gt;asia.banseon\u0026lt;/groupId\u0026gt; \u0026lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源码，二进制发布和WARs等。 --\u0026gt; \u0026lt;artifactId\u0026gt;banseon-maven2\u0026lt;/artifactId\u0026gt; \u0026lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 --\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;!--项目的名称, Maven产生的文档用 --\u0026gt; \u0026lt;name\u0026gt;banseon-maven\u0026lt;/name\u0026gt; \u0026lt;!--项目主页的URL, Maven产生的文档用 --\u0026gt; \u0026lt;url\u0026gt;http://www.baidu.com/banseon\u0026lt;/url\u0026gt; \u0026lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 --\u0026gt; \u0026lt;description\u0026gt;A maven project to study maven.\u0026lt;/description\u0026gt; \u0026lt;!--描述了这个项目构建环境中的前提条件。 --\u0026gt; \u0026lt;prerequisites\u0026gt; \u0026lt;!--构建该项目或使用该插件所需要的Maven的最低版本 --\u0026gt; \u0026lt;maven /\u0026gt; \u0026lt;/prerequisites\u0026gt; \u0026lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --\u0026gt; \u0026lt;issueManagement\u0026gt; \u0026lt;!--问题管理系统（例如jira）的名字， --\u0026gt; \u0026lt;system\u0026gt;jira\u0026lt;/system\u0026gt; \u0026lt;!--该项目使用的问题管理系统的URL --\u0026gt; \u0026lt;url\u0026gt;http://jira.baidu.com/banseon\u0026lt;/url\u0026gt; \u0026lt;/issueManagement\u0026gt; \u0026lt;!--项目持续集成信息 --\u0026gt; \u0026lt;ciManagement\u0026gt; \u0026lt;!--持续集成系统的名字，例如continuum --\u0026gt; \u0026lt;system /\u0026gt; \u0026lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --\u0026gt; \u0026lt;url /\u0026gt; \u0026lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --\u0026gt; \u0026lt;notifiers\u0026gt; \u0026lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者 --\u0026gt; \u0026lt;notifier\u0026gt; \u0026lt;!--传送通知的途径 --\u0026gt; \u0026lt;type /\u0026gt; \u0026lt;!--发生错误时是否通知 --\u0026gt; \u0026lt;sendOnError /\u0026gt; \u0026lt;!--构建失败时是否通知 --\u0026gt; \u0026lt;sendOnFailure /\u0026gt; \u0026lt;!--构建成功时是否通知 --\u0026gt; \u0026lt;sendOnSuccess /\u0026gt; \u0026lt;!--发生警告时是否通知 --\u0026gt; \u0026lt;sendOnWarning /\u0026gt; \u0026lt;!--不赞成使用。通知发送到哪里 --\u0026gt; \u0026lt;address /\u0026gt; \u0026lt;!--扩展配置项 --\u0026gt; \u0026lt;configuration /\u0026gt; \u0026lt;/notifier\u0026gt; \u0026lt;/notifiers\u0026gt; \u0026lt;/ciManagement\u0026gt; \u0026lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --\u0026gt; \u0026lt;inceptionYear /\u0026gt; \u0026lt;!--项目相关邮件列表信息 --\u0026gt; \u0026lt;mailingLists\u0026gt; \u0026lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --\u0026gt; \u0026lt;mailingList\u0026gt; \u0026lt;!--邮件的名称 --\u0026gt; \u0026lt;name\u0026gt;Demo\u0026lt;/name\u0026gt; \u0026lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --\u0026gt; \u0026lt;post\u0026gt;banseon@126.com\u0026lt;/post\u0026gt; \u0026lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --\u0026gt; \u0026lt;subscribe\u0026gt;banseon@126.com\u0026lt;/subscribe\u0026gt; \u0026lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --\u0026gt; \u0026lt;unsubscribe\u0026gt;banseon@126.com\u0026lt;/unsubscribe\u0026gt; \u0026lt;!--你可以浏览邮件信息的URL --\u0026gt; \u0026lt;archive\u0026gt;http:/hi.baidu.com/banseon/demo/dev/\u0026lt;/archive\u0026gt; \u0026lt;/mailingList\u0026gt; \u0026lt;/mailingLists\u0026gt; \u0026lt;!--项目开发者列表 --\u0026gt; \u0026lt;developers\u0026gt; \u0026lt;!--某个项目开发者的信息 --\u0026gt; \u0026lt;developer\u0026gt; \u0026lt;!--SCM里项目开发者的唯一标识符 --\u0026gt; \u0026lt;id\u0026gt;HELLO WORLD\u0026lt;/id\u0026gt; \u0026lt;!--项目开发者的全名 --\u0026gt; \u0026lt;name\u0026gt;banseon\u0026lt;/name\u0026gt; \u0026lt;!--项目开发者的email --\u0026gt; \u0026lt;email\u0026gt;banseon@126.com\u0026lt;/email\u0026gt; \u0026lt;!--项目开发者的主页的URL --\u0026gt; \u0026lt;url /\u0026gt; \u0026lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色 --\u0026gt; \u0026lt;roles\u0026gt; \u0026lt;role\u0026gt;Project Manager\u0026lt;/role\u0026gt; \u0026lt;role\u0026gt;Architect\u0026lt;/role\u0026gt; \u0026lt;/roles\u0026gt; \u0026lt;!--项目开发者所属组织 --\u0026gt; \u0026lt;organization\u0026gt;demo\u0026lt;/organization\u0026gt; \u0026lt;!--项目开发者所属组织的URL --\u0026gt; \u0026lt;organizationUrl\u0026gt;http://hi.baidu.com/banseon\u0026lt;/organizationUrl\u0026gt; \u0026lt;!--项目开发者属性，如即时消息如何处理等 --\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;dept\u0026gt;No\u0026lt;/dept\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;!--项目开发者所在时区， -11到12范围内的整数。 --\u0026gt; \u0026lt;timezone\u0026gt;-5\u0026lt;/timezone\u0026gt; \u0026lt;/developer\u0026gt; \u0026lt;/developers\u0026gt; \u0026lt;!--项目的其他贡献者列表 --\u0026gt; \u0026lt;contributors\u0026gt; \u0026lt;!--项目的其他贡献者。参见developers/developer元素 --\u0026gt; \u0026lt;contributor\u0026gt; \u0026lt;name /\u0026gt; \u0026lt;email /\u0026gt; \u0026lt;url /\u0026gt; \u0026lt;organization /\u0026gt; \u0026lt;organizationUrl /\u0026gt; \u0026lt;roles /\u0026gt; \u0026lt;timezone /\u0026gt; \u0026lt;properties /\u0026gt; \u0026lt;/contributor\u0026gt; \u0026lt;/contributors\u0026gt; \u0026lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --\u0026gt; \u0026lt;licenses\u0026gt; \u0026lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --\u0026gt; \u0026lt;license\u0026gt; \u0026lt;!--license用于法律上的名称 --\u0026gt; \u0026lt;name\u0026gt;Apache 2\u0026lt;/name\u0026gt; \u0026lt;!--官方的license正文页面的URL --\u0026gt; \u0026lt;url\u0026gt;http://www.baidu.com/banseon/LICENSE-2.0.txt\u0026lt;/url\u0026gt; \u0026lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 --\u0026gt; \u0026lt;distribution\u0026gt;repo\u0026lt;/distribution\u0026gt; \u0026lt;!--关于license的补充信息 --\u0026gt; \u0026lt;comments\u0026gt;A business-friendly OSS license\u0026lt;/comments\u0026gt; \u0026lt;/license\u0026gt; \u0026lt;/licenses\u0026gt; \u0026lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --\u0026gt; \u0026lt;scm\u0026gt; \u0026lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --\u0026gt; \u0026lt;connection\u0026gt;scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk)\u0026lt;/connection\u0026gt; \u0026lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读 --\u0026gt; \u0026lt;developerConnection\u0026gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk \u0026lt;/developerConnection\u0026gt; \u0026lt;!--当前代码的标签，在开发阶段默认为HEAD --\u0026gt; \u0026lt;tag /\u0026gt; \u0026lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --\u0026gt; \u0026lt;url\u0026gt;http://svn.baidu.com/banseon\u0026lt;/url\u0026gt; \u0026lt;/scm\u0026gt; \u0026lt;!--描述项目所属组织的各种属性。Maven产生的文档用 --\u0026gt; \u0026lt;organization\u0026gt; \u0026lt;!--组织的全名 --\u0026gt; \u0026lt;name\u0026gt;demo\u0026lt;/name\u0026gt; \u0026lt;!--组织主页的URL --\u0026gt; \u0026lt;url\u0026gt;http://www.baidu.com/banseon\u0026lt;/url\u0026gt; \u0026lt;/organization\u0026gt; \u0026lt;!--构建项目需要的信息 --\u0026gt; \u0026lt;build\u0026gt; \u0026lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --\u0026gt; \u0026lt;sourceDirectory /\u0026gt; \u0026lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --\u0026gt; \u0026lt;scriptSourceDirectory /\u0026gt; \u0026lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --\u0026gt; \u0026lt;testSourceDirectory /\u0026gt; \u0026lt;!--被编译过的应用程序class文件存放的目录。 --\u0026gt; \u0026lt;outputDirectory /\u0026gt; \u0026lt;!--被编译过的测试class文件存放的目录。 --\u0026gt; \u0026lt;testOutputDirectory /\u0026gt; \u0026lt;!--使用来自该项目的一系列构建扩展 --\u0026gt; \u0026lt;extensions\u0026gt; \u0026lt;!--描述使用到的构建扩展。 --\u0026gt; \u0026lt;extension\u0026gt; \u0026lt;!--构建扩展的groupId --\u0026gt; \u0026lt;groupId /\u0026gt; \u0026lt;!--构建扩展的artifactId --\u0026gt; \u0026lt;artifactId /\u0026gt; \u0026lt;!--构建扩展的版本 --\u0026gt; \u0026lt;version /\u0026gt; \u0026lt;/extension\u0026gt; \u0026lt;/extensions\u0026gt; \u0026lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值 --\u0026gt; \u0026lt;defaultGoal /\u0026gt; \u0026lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 --\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;!--这个元素描述了项目相关或测试相关的所有资源路径 --\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如${project.build.outputDirectory}）。举个例 子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --\u0026gt; \u0026lt;targetPath /\u0026gt; \u0026lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --\u0026gt; \u0026lt;filtering /\u0026gt; \u0026lt;!--描述存放资源的目录，该路径相对POM路径 --\u0026gt; \u0026lt;directory /\u0026gt; \u0026lt;!--包含的模式列表，例如**/*.xml. --\u0026gt; \u0026lt;includes /\u0026gt; \u0026lt;!--排除的模式列表，例如**/*.xml --\u0026gt; \u0026lt;excludes /\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 --\u0026gt; \u0026lt;testResources\u0026gt; \u0026lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 --\u0026gt; \u0026lt;testResource\u0026gt; \u0026lt;targetPath /\u0026gt; \u0026lt;filtering /\u0026gt; \u0026lt;directory /\u0026gt; \u0026lt;includes /\u0026gt; \u0026lt;excludes /\u0026gt; \u0026lt;/testResource\u0026gt; \u0026lt;/testResources\u0026gt; \u0026lt;!--构建产生的所有文件存放的目录 --\u0026gt; \u0026lt;directory /\u0026gt; \u0026lt;!--产生的构件的文件名，默认值是${artifactId}-${version}。 --\u0026gt; \u0026lt;finalName /\u0026gt; \u0026lt;!--当filtering开关打开时，使用到的过滤器属性文件列表 --\u0026gt; \u0026lt;filters /\u0026gt; \u0026lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 --\u0026gt; \u0026lt;pluginManagement\u0026gt; \u0026lt;!--使用的插件列表 。 --\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!--plugin元素包含描述插件所需要的信息。 --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;!--插件在仓库里的group ID --\u0026gt; \u0026lt;groupId /\u0026gt; \u0026lt;!--插件在仓库里的artifact ID --\u0026gt; \u0026lt;artifactId /\u0026gt; \u0026lt;!--被使用的插件的版本（或版本范围） --\u0026gt; \u0026lt;version /\u0026gt; \u0026lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 --\u0026gt; \u0026lt;extensions /\u0026gt; \u0026lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;!--execution元素包含了插件执行需要的信息 --\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --\u0026gt; \u0026lt;id /\u0026gt; \u0026lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --\u0026gt; \u0026lt;phase /\u0026gt; \u0026lt;!--配置的执行目标 --\u0026gt; \u0026lt;goals /\u0026gt; \u0026lt;!--配置是否被传播到子POM --\u0026gt; \u0026lt;inherited /\u0026gt; \u0026lt;!--作为DOM对象的配置 --\u0026gt; \u0026lt;configuration /\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;!--项目引入插件所需要的额外依赖 --\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--参见dependencies/dependency元素 --\u0026gt; \u0026lt;dependency\u0026gt; ...... \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!--任何配置是否被传播到子项目 --\u0026gt; \u0026lt;inherited /\u0026gt; \u0026lt;!--作为DOM对象的配置 --\u0026gt; \u0026lt;configuration /\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/pluginManagement\u0026gt; \u0026lt;!--使用的插件列表 --\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!--参见build/pluginManagement/plugins/plugin元素 --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId /\u0026gt; \u0026lt;artifactId /\u0026gt; \u0026lt;version /\u0026gt; \u0026lt;extensions /\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id /\u0026gt; \u0026lt;phase /\u0026gt; \u0026lt;goals /\u0026gt; \u0026lt;inherited /\u0026gt; \u0026lt;configuration /\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--参见dependencies/dependency元素 --\u0026gt; \u0026lt;dependency\u0026gt; ...... \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;goals /\u0026gt; \u0026lt;inherited /\u0026gt; \u0026lt;configuration /\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;!--在列的项目构建profile，如果被激活，会修改构建处理 --\u0026gt; \u0026lt;profiles\u0026gt; \u0026lt;!--根据环境参数或命令行参数激活某个构建处理 --\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 --\u0026gt; \u0026lt;id /\u0026gt; \u0026lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它 能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。 --\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;!--profile默认是否激活的标志 --\u0026gt; \u0026lt;activeByDefault /\u0026gt; \u0026lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --\u0026gt; \u0026lt;jdk /\u0026gt; \u0026lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --\u0026gt; \u0026lt;os\u0026gt; \u0026lt;!--激活profile的操作系统的名字 --\u0026gt; \u0026lt;name\u0026gt;Windows XP\u0026lt;/name\u0026gt; \u0026lt;!--激活profile的操作系统所属家族(如 \u0026#39;windows\u0026#39;) --\u0026gt; \u0026lt;family\u0026gt;Windows\u0026lt;/family\u0026gt; \u0026lt;!--激活profile的操作系统体系结构 --\u0026gt; \u0026lt;arch\u0026gt;x86\u0026lt;/arch\u0026gt; \u0026lt;!--激活profile的操作系统版本 --\u0026gt; \u0026lt;version\u0026gt;5.1.2600\u0026lt;/version\u0026gt; \u0026lt;/os\u0026gt; \u0026lt;!--如果Maven检测到某一个属性（其值可以在POM中通过${名称}引用），其拥有对应的名称和值，Profile就会被激活。如果值 字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --\u0026gt; \u0026lt;property\u0026gt; \u0026lt;!--激活profile的属性的名称 --\u0026gt; \u0026lt;name\u0026gt;mavenVersion\u0026lt;/name\u0026gt; \u0026lt;!--激活profile的属性的值 --\u0026gt; \u0026lt;value\u0026gt;2.0.3\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --\u0026gt; \u0026lt;file\u0026gt; \u0026lt;!--如果指定的文件存在，则激活profile。 --\u0026gt; \u0026lt;exists\u0026gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ \u0026lt;/exists\u0026gt; \u0026lt;!--如果指定的文件不存在，则激活profile。 --\u0026gt; \u0026lt;missing\u0026gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ \u0026lt;/missing\u0026gt; \u0026lt;/file\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;!--构建项目所需要的信息。参见build元素 --\u0026gt; \u0026lt;build\u0026gt; \u0026lt;defaultGoal /\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;targetPath /\u0026gt; \u0026lt;filtering /\u0026gt; \u0026lt;directory /\u0026gt; \u0026lt;includes /\u0026gt; \u0026lt;excludes /\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;testResources\u0026gt; \u0026lt;testResource\u0026gt; \u0026lt;targetPath /\u0026gt; \u0026lt;filtering /\u0026gt; \u0026lt;directory /\u0026gt; \u0026lt;includes /\u0026gt; \u0026lt;excludes /\u0026gt; \u0026lt;/testResource\u0026gt; \u0026lt;/testResources\u0026gt; \u0026lt;directory /\u0026gt; \u0026lt;finalName /\u0026gt; \u0026lt;filters /\u0026gt; \u0026lt;pluginManagement\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!--参见build/pluginManagement/plugins/plugin元素 --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId /\u0026gt; \u0026lt;artifactId /\u0026gt; \u0026lt;version /\u0026gt; \u0026lt;extensions /\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id /\u0026gt; \u0026lt;phase /\u0026gt; \u0026lt;goals /\u0026gt; \u0026lt;inherited /\u0026gt; \u0026lt;configuration /\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--参见dependencies/dependency元素 --\u0026gt; \u0026lt;dependency\u0026gt; ...... \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;goals /\u0026gt; \u0026lt;inherited /\u0026gt; \u0026lt;configuration /\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/pluginManagement\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!--参见build/pluginManagement/plugins/plugin元素 --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId /\u0026gt; \u0026lt;artifactId /\u0026gt; \u0026lt;version /\u0026gt; \u0026lt;extensions /\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;id /\u0026gt; \u0026lt;phase /\u0026gt; \u0026lt;goals /\u0026gt; \u0026lt;inherited /\u0026gt; \u0026lt;configuration /\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--参见dependencies/dependency元素 --\u0026gt; \u0026lt;dependency\u0026gt; ...... \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;goals /\u0026gt; \u0026lt;inherited /\u0026gt; \u0026lt;configuration /\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --\u0026gt; \u0026lt;modules /\u0026gt; \u0026lt;!--发现依赖和扩展的远程仓库列表。 --\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;!--参见repositories/repository元素 --\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;releases\u0026gt; \u0026lt;enabled /\u0026gt; \u0026lt;updatePolicy /\u0026gt; \u0026lt;checksumPolicy /\u0026gt; \u0026lt;/releases\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled /\u0026gt; \u0026lt;updatePolicy /\u0026gt; \u0026lt;checksumPolicy /\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;id /\u0026gt; \u0026lt;name /\u0026gt; \u0026lt;url /\u0026gt; \u0026lt;layout /\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --\u0026gt; \u0026lt;pluginRepositories\u0026gt; \u0026lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --\u0026gt; \u0026lt;pluginRepository\u0026gt; \u0026lt;releases\u0026gt; \u0026lt;enabled /\u0026gt; \u0026lt;updatePolicy /\u0026gt; \u0026lt;checksumPolicy /\u0026gt; \u0026lt;/releases\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled /\u0026gt; \u0026lt;updatePolicy /\u0026gt; \u0026lt;checksumPolicy /\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;id /\u0026gt; \u0026lt;name /\u0026gt; \u0026lt;url /\u0026gt; \u0026lt;layout /\u0026gt; \u0026lt;/pluginRepository\u0026gt; \u0026lt;/pluginRepositories\u0026gt; \u0026lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--参见dependencies/dependency元素 --\u0026gt; \u0026lt;dependency\u0026gt; ...... \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!--不赞成使用. 现在Maven忽略该元素. --\u0026gt; \u0026lt;reports /\u0026gt; \u0026lt;!--该元素包括使用报表插件产生报表的规范。当用户执行\u0026#34;mvn site\u0026#34;，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素 --\u0026gt; \u0026lt;reporting\u0026gt; ...... \u0026lt;/reporting\u0026gt; \u0026lt;!--参见dependencyManagement元素 --\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--参见dependencies/dependency元素 --\u0026gt; \u0026lt;dependency\u0026gt; ...... \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;!--参见distributionManagement元素 --\u0026gt; \u0026lt;distributionManagement\u0026gt; ...... \u0026lt;/distributionManagement\u0026gt; \u0026lt;!--参见properties元素 --\u0026gt; \u0026lt;properties /\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/profiles\u0026gt; \u0026lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --\u0026gt; \u0026lt;modules /\u0026gt; \u0026lt;!--发现依赖和扩展的远程仓库列表。 --\u0026gt; \u0026lt;repositories\u0026gt; \u0026lt;!--包含需要连接到远程仓库的信息 --\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;!--如何处理远程仓库里发布版本的下载 --\u0026gt; \u0026lt;releases\u0026gt; \u0026lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --\u0026gt; \u0026lt;enabled /\u0026gt; \u0026lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --\u0026gt; \u0026lt;updatePolicy /\u0026gt; \u0026lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --\u0026gt; \u0026lt;checksumPolicy /\u0026gt; \u0026lt;/releases\u0026gt; \u0026lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --\u0026gt; \u0026lt;snapshots\u0026gt; \u0026lt;enabled /\u0026gt; \u0026lt;updatePolicy /\u0026gt; \u0026lt;checksumPolicy /\u0026gt; \u0026lt;/snapshots\u0026gt; \u0026lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --\u0026gt; \u0026lt;id\u0026gt;banseon-repository-proxy\u0026lt;/id\u0026gt; \u0026lt;!--远程仓库名称 --\u0026gt; \u0026lt;name\u0026gt;banseon-repository-proxy\u0026lt;/name\u0026gt; \u0026lt;!--远程仓库URL，按protocol://hostname/path形式 --\u0026gt; \u0026lt;url\u0026gt;http://192.168.1.169:9999/repository/\u0026lt;/url\u0026gt; \u0026lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --\u0026gt; \u0026lt;layout\u0026gt;default\u0026lt;/layout\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;/repositories\u0026gt; \u0026lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --\u0026gt; \u0026lt;pluginRepositories\u0026gt; \u0026lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --\u0026gt; \u0026lt;pluginRepository\u0026gt; ...... \u0026lt;/pluginRepository\u0026gt; \u0026lt;/pluginRepositories\u0026gt; \u0026lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;!--依赖的group ID --\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven\u0026lt;/groupId\u0026gt; \u0026lt;!--依赖的artifact ID --\u0026gt; \u0026lt;artifactId\u0026gt;maven-artifact\u0026lt;/artifactId\u0026gt; \u0026lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --\u0026gt; \u0026lt;version\u0026gt;3.8.1\u0026lt;/version\u0026gt; \u0026lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应，尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。 --\u0026gt; \u0026lt;type\u0026gt;jar\u0026lt;/type\u0026gt; \u0026lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 --\u0026gt; \u0026lt;classifier\u0026gt;\u0026lt;/classifier\u0026gt; \u0026lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如${java.home}。 --\u0026gt; \u0026lt;systemPath\u0026gt;\u0026lt;/systemPath\u0026gt; \u0026lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!--不赞成使用. 现在Maven忽略该元素. --\u0026gt; \u0026lt;reports\u0026gt;\u0026lt;/reports\u0026gt; \u0026lt;!--该元素描述使用报表插件产生报表的规范。当用户执行\u0026#34;mvn site\u0026#34;，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 --\u0026gt; \u0026lt;reporting\u0026gt; \u0026lt;!--true，则，网站不包括默认的报表。这包括\u0026#34;项目信息\u0026#34;菜单中的报表。 --\u0026gt; \u0026lt;excludeDefaults /\u0026gt; \u0026lt;!--所有产生的报表存放到哪里。默认值是${project.build.directory}/site。 --\u0026gt; \u0026lt;outputDirectory /\u0026gt; \u0026lt;!--使用的报表插件和他们的配置。 --\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!--plugin元素包含描述报表插件需要的信息 --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;!--报表插件在仓库里的group ID --\u0026gt; \u0026lt;groupId /\u0026gt; \u0026lt;!--报表插件在仓库里的artifact ID --\u0026gt; \u0026lt;artifactId /\u0026gt; \u0026lt;!--被使用的报表插件的版本（或版本范围） --\u0026gt; \u0026lt;version /\u0026gt; \u0026lt;!--任何配置是否被传播到子项目 --\u0026gt; \u0026lt;inherited /\u0026gt; \u0026lt;!--报表插件的配置 --\u0026gt; \u0026lt;configuration /\u0026gt; \u0026lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 --\u0026gt; \u0026lt;reportSets\u0026gt; \u0026lt;!--表示报表的一个集合，以及产生该集合的配置 --\u0026gt; \u0026lt;reportSet\u0026gt; \u0026lt;!--报表集合的唯一标识符，POM继承时用到 --\u0026gt; \u0026lt;id /\u0026gt; \u0026lt;!--产生报表集合时，被使用的报表的配置 --\u0026gt; \u0026lt;configuration /\u0026gt; \u0026lt;!--配置是否被继承到子POMs --\u0026gt; \u0026lt;inherited /\u0026gt; \u0026lt;!--这个集合里使用到哪些报表 --\u0026gt; \u0026lt;reports /\u0026gt; \u0026lt;/reportSet\u0026gt; \u0026lt;/reportSets\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/reporting\u0026gt; \u0026lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。 --\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--参见dependencies/dependency元素 --\u0026gt; \u0026lt;dependency\u0026gt; ...... \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 --\u0026gt; \u0026lt;distributionManagement\u0026gt; \u0026lt;!--部署项目产生的构件到远程仓库需要的信息 --\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素 --\u0026gt; \u0026lt;uniqueVersion /\u0026gt; \u0026lt;id\u0026gt;banseon-maven2\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;banseon maven2\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;file://${basedir}/target/deploy\u0026lt;/url\u0026gt; \u0026lt;layout /\u0026gt; \u0026lt;/repository\u0026gt; \u0026lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素 --\u0026gt; \u0026lt;snapshotRepository\u0026gt; \u0026lt;uniqueVersion /\u0026gt; \u0026lt;id\u0026gt;banseon-maven2\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;Banseon-maven2 Snapshot Repository\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;scp://svn.baidu.com/banseon:/usr/local/maven-snapshot\u0026lt;/url\u0026gt; \u0026lt;layout /\u0026gt; \u0026lt;/snapshotRepository\u0026gt; \u0026lt;!--部署项目的网站需要的信息 --\u0026gt; \u0026lt;site\u0026gt; \u0026lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --\u0026gt; \u0026lt;id\u0026gt;banseon-site\u0026lt;/id\u0026gt; \u0026lt;!--部署位置的名称 --\u0026gt; \u0026lt;name\u0026gt;business api website\u0026lt;/name\u0026gt; \u0026lt;!--部署位置的URL，按protocol://hostname/path形式 --\u0026gt; \u0026lt;url\u0026gt; scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web \u0026lt;/url\u0026gt; \u0026lt;/site\u0026gt; \u0026lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 --\u0026gt; \u0026lt;downloadUrl /\u0026gt; \u0026lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --\u0026gt; \u0026lt;relocation\u0026gt; \u0026lt;!--构件新的group ID --\u0026gt; \u0026lt;groupId /\u0026gt; \u0026lt;!--构件新的artifact ID --\u0026gt; \u0026lt;artifactId /\u0026gt; \u0026lt;!--构件新的版本号 --\u0026gt; \u0026lt;version /\u0026gt; \u0026lt;!--显示给用户的，关于移动的额外信息，例如原因。 --\u0026gt; \u0026lt;message /\u0026gt; \u0026lt;/relocation\u0026gt; \u0026lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从 Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。 --\u0026gt; \u0026lt;status /\u0026gt; \u0026lt;/distributionManagement\u0026gt; \u0026lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是\u0026lt;name\u0026gt;value\u0026lt;/name\u0026gt;。 --\u0026gt; \u0026lt;properties /\u0026gt; \u0026lt;/project\u0026gt; 5. 依赖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;\u0026lt;/type\u0026gt; \u0026lt;classifier\u0026gt;\u0026lt;/classifier\u0026gt; \u0026lt;scope\u0026gt;\u0026lt;/scope\u0026gt; \u0026lt;systemPath\u0026gt;\u0026lt;/systemPath\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;artifactId\u0026gt;\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;\u0026lt;/groupId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;optional\u0026gt;\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 配置说明 ：\ndependencies ： 一个 pom.xml 文件中只能存在一个这样的标签，是用来管理依赖的总标签。 dependency：包含在 dependencies 标签中，可以有多个，每一个表示项目的一个依赖。 groupId,artifactId,version(必要)：依赖的基本坐标，对于任何一个依赖来说，基本坐标是最重要的，Maven 根据坐标才能找到需要的依赖。我们在上面解释过这些元素的具体意思，这里就不重复提了。 type(可选)：依赖的类型，对应于项目坐标定义的 packaging。大部分情况下，该元素不必声明，其默认值是 jar。 scope(可选)：依赖的范围，默认值是 compile。 optional(可选)： 标记依赖是否可选 exclusions(可选)：用来排除传递性依赖,例如 jar 包冲突 依赖范围 classpath 用于指定 .class 文件存放的位置，类加载器会从该路径中加载所需的 .class 文件到内存中。\nMaven 在编译、执行测试、实际运行有着三套不同的 classpath：\n编译 classpath ：编译主代码有效 测试 classpath ：编译、运行测试代码有效 运行 classpath ：项目运行时有效 Maven 的依赖范围如下：\ncompile：编译依赖范围（默认），使用此依赖范围对于编译、测试、运行三种都有效，即在编译、测试和运行的时候都要使用该依赖 Jar 包。 test：测试依赖范围，从字面意思就可以知道此依赖范围只能用于测试，而在编译和运行项目时无法使用此类依赖，典型的是 JUnit，它只用于编译测试代码和运行测试代码的时候才需要。 provided ：此依赖范围，对于编译和测试有效，而对运行时无效。比如 servlet-api.jar 在 Tomcat 中已经提供了，我们只需要的是编译期提供而已。 runtime：运行时依赖范围，对于测试和运行有效，但是在编译主代码时无效，典型的就是 JDBC 驱动实现。 system：系统依赖范围，使用 system 范围的依赖时必须通过 systemPath 元素显示地指定依赖文件的路径，不依赖 Maven 仓库解析，所以可能会造成建构的不可移植。 传递依赖性 依赖冲突 1、对于 Maven 而言，同一个 groupId 同一个 artifactId 下，只能使用一个 version。\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;in.hocg.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.48\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 只会使用 1.0.49 这个版本的依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;in.hocg.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.49\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 若相同类型但版本不同的依赖存在于同一个 pom 文件，只会引入后一个声明的依赖。\n2、项目的两个依赖同时引入了某个依赖。\n举个例子，项目存在下面这样的依赖关系：\n1 2 依赖链路一：A -\u0026gt; B -\u0026gt; C -\u0026gt; X(1.0) 依赖链路二：A -\u0026gt; D -\u0026gt; X(2.0) 这两条依赖路径上有两个版本的 X，为了避免依赖重复，Maven 只会选择其中的一个进行解析。\n哪个版本的 X 会被 Maven 解析使用呢?\nMaven 在遇到这种问题的时候，会遵循 路径最短优先 和 声明顺序优先 两大原则。解决这个问题的过程也被称为 Maven 依赖调解 。\n路径最短优先\n1 2 依赖链路一：A -\u0026gt; B -\u0026gt; C -\u0026gt; X(1.0) // dist = 3 依赖链路二：A -\u0026gt; D -\u0026gt; X(2.0) // dist = 2 依赖链路二的路径最短，因此，X(2.0)会被解析使用。\n不过，你也可以发现。路径最短优先原则并不是通用的，像下面这种路径长度相等的情况就不能单单通过其解决了：\n1 2 依赖链路一：A -\u0026gt; B -\u0026gt; X(1.0) // dist = 3 依赖链路二：A -\u0026gt; D -\u0026gt; X(2.0) // dist = 2 因此，Maven 又定义了声明顺序优先原则。\n依赖调解第一原则不能解决所有问题，比如这样的依赖关系：A-\u0026gt;B-\u0026gt;Y(1.0)、A-\u0026gt; C-\u0026gt;Y(2.0)，Y(1.0)和 Y(2.0)的依赖路径长度是一样的，都为 2。Maven 定义了依赖调解的第二原则：\n声明顺序优先\n在依赖路径长度相等的前提下，在 pom.xml 中依赖声明的顺序决定了谁会被解析使用，顺序最前的那个依赖优胜。该例中，如果 B 的依赖声明在 D 之前，那么 X (1.0)就会被解析使用。\n1 2 3 4 5 6 7 \u0026lt;!-- A pom.xml --\u0026gt; \u0026lt;dependencies\u0026gt; ... dependency B ... dependency D \u0026lt;/dependencies\u0026gt; 排除依赖 单纯依赖 Maven 来进行依赖调解，在很多情况下是不适用的，需要我们手动排除依赖。\n举个例子，当前项目存在下面这样的依赖关系：\n1 2 依赖链路一：A -\u0026gt; B -\u0026gt; C -\u0026gt; X(1.5) // dist = 3 依赖链路二：A -\u0026gt; D -\u0026gt; X(1.0) // dist = 2 根据路径最短优先原则，X(1.0) 会被解析使用，也就是说实际用的是 1.0 版本的 X。\n但是！！！这会一些问题：如果 D 依赖用到了 1.5 版本的 X 中才有的一个类，运行项目就会报NoClassDefFoundError错误。如果 D 依赖用到了 1.5 版本的 X 中才有的一个方法，运行项目就会报NoSuchMethodError错误。\n现在知道为什么你的 Maven 项目总是会报NoClassDefFoundError和NoSuchMethodError错误了吧？\n如何解决呢？ 我们可以通过exclusive标签手动将 X(1.0) 给排除。\n1 2 3 4 5 6 7 8 9 \u0026lt;dependencyD\u0026gt; ...... \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;artifactId\u0026gt;x\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;org.apache.x\u0026lt;/groupId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; 一般我们在解决依赖冲突的时候，都会优先保留版本较高的。这是因为大部分 jar 在升级的时候都会做到向下兼容。\n如果高版本修改了低版本的一些类或者方法的话，这个时候就能直接保留高版本了，而是应该考虑优化上层依赖，比如升级上层依赖的版本。\n还是上面的例子：\n1 2 依赖链路一：A -\u0026gt; B -\u0026gt; C -\u0026gt; X(1.5) // dist = 3 依赖链路二：A -\u0026gt; D -\u0026gt; X(1.0) // dist = 2 我们保留了 1.5 版本的 X，但是这个版本的 X 删除了 1.0 版本中的某些类。这个时候，我们可以考虑升级 D 的版本到一个 X 兼容的版本。\n6. Maven 生命周期 Maven 的生命周期就是为了对所有的构建过程进行抽象和统一，包含了项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成等几乎所有构建步骤。\nMaven 定义了 3 个生命周期META-INF/plexus/components.xml：\ndefault 生命周期 clean生命周期 site生命周期 这些生命周期是相互独立的，每个生命周期包含多个阶段(phase)。并且，这些阶段是有序的，也就是说，后面的阶段依赖于前面的阶段。当执行某个阶段的时候，会先执行它前面的阶段。\n执行 Maven 生命周期的命令格式如下：\n1 mvn 阶段 [阶段2] ...[阶段n] default 生命周期 default生命周期是在没有任何关联插件的情况下定义的，是 Maven 的主要生命周期，用于构建应用程序，共包含 23 个阶段。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 \u0026lt;phases\u0026gt; \u0026lt;!-- 验证项目是否正确，并且所有必要的信息可用于完成构建过程 --\u0026gt; \u0026lt;phase\u0026gt;validate\u0026lt;/phase\u0026gt; \u0026lt;!-- 建立初始化状态，例如设置属性 --\u0026gt; \u0026lt;phase\u0026gt;initialize\u0026lt;/phase\u0026gt; \u0026lt;!-- 生成要包含在编译阶段的源代码 --\u0026gt; \u0026lt;phase\u0026gt;generate-sources\u0026lt;/phase\u0026gt; \u0026lt;!-- 处理源代码 --\u0026gt; \u0026lt;phase\u0026gt;process-sources\u0026lt;/phase\u0026gt; \u0026lt;!-- 生成要包含在包中的资源 --\u0026gt; \u0026lt;phase\u0026gt;generate-resources\u0026lt;/phase\u0026gt; \u0026lt;!-- 将资源复制并处理到目标目录中，为打包阶段做好准备。 --\u0026gt; \u0026lt;phase\u0026gt;process-resources\u0026lt;/phase\u0026gt; \u0026lt;!-- 编译项目的源代码 --\u0026gt; \u0026lt;phase\u0026gt;compile\u0026lt;/phase\u0026gt; \u0026lt;!-- 对编译生成的文件进行后处理，例如对 Java 类进行字节码增强/优化 --\u0026gt; \u0026lt;phase\u0026gt;process-classes\u0026lt;/phase\u0026gt; \u0026lt;!-- 生成要包含在编译阶段的任何测试源代码 --\u0026gt; \u0026lt;phase\u0026gt;generate-test-sources\u0026lt;/phase\u0026gt; \u0026lt;!-- 处理测试源代码 --\u0026gt; \u0026lt;phase\u0026gt;process-test-sources\u0026lt;/phase\u0026gt; \u0026lt;!-- 生成要包含在编译阶段的测试源代码 --\u0026gt; \u0026lt;phase\u0026gt;generate-test-resources\u0026lt;/phase\u0026gt; \u0026lt;!-- 处理从测试代码文件编译生成的文件 --\u0026gt; \u0026lt;phase\u0026gt;process-test-resources\u0026lt;/phase\u0026gt; \u0026lt;!-- 编译测试源代码 --\u0026gt; \u0026lt;phase\u0026gt;test-compile\u0026lt;/phase\u0026gt; \u0026lt;!-- 处理从测试代码文件编译生成的文件 --\u0026gt; \u0026lt;phase\u0026gt;process-test-classes\u0026lt;/phase\u0026gt; \u0026lt;!-- 使用合适的单元测试框架（Junit 就是其中之一）运行测试 --\u0026gt; \u0026lt;phase\u0026gt;test\u0026lt;/phase\u0026gt; \u0026lt;!-- 在实际打包之前，执行任何的必要的操作为打包做准备 --\u0026gt; \u0026lt;phase\u0026gt;prepare-package\u0026lt;/phase\u0026gt; \u0026lt;!-- 获取已编译的代码并将其打包成可分发的格式，例如 JAR、WAR 或 EAR 文件 --\u0026gt; \u0026lt;phase\u0026gt;package\u0026lt;/phase\u0026gt; \u0026lt;!-- 在执行集成测试之前执行所需的操作。 例如，设置所需的环境 --\u0026gt; \u0026lt;phase\u0026gt;pre-integration-test\u0026lt;/phase\u0026gt; \u0026lt;!-- 处理并在必要时部署软件包到集成测试可以运行的环境 --\u0026gt; \u0026lt;phase\u0026gt;integration-test\u0026lt;/phase\u0026gt; \u0026lt;!-- 执行集成测试后执行所需的操作。 例如，清理环境 --\u0026gt; \u0026lt;phase\u0026gt;post-integration-test\u0026lt;/phase\u0026gt; \u0026lt;!-- 运行任何检查以验证打的包是否有效并符合质量标准。 --\u0026gt; \u0026lt;phase\u0026gt;verify\u0026lt;/phase\u0026gt; \u0026lt;!-- 将包安装到本地仓库中，可以作为本地其他项目的依赖 --\u0026gt; \u0026lt;phase\u0026gt;install\u0026lt;/phase\u0026gt; \u0026lt;!-- 将最终的项目包复制到远程仓库中与其他开发者和项目共享 --\u0026gt; \u0026lt;phase\u0026gt;deploy\u0026lt;/phase\u0026gt; \u0026lt;/phases\u0026gt; 根据前面提到的阶段间依赖关系理论，当我们执行 mvn test命令的时候，会执行从 validate 到 test 的所有阶段，这也就解释了为什么执行测试的时候，项目的代码能够自动编译。\nclean 生命周期 clean 生命周期的目的是清理项目，共包含 3 个阶段：\npre-clean clean post-clean 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;phases\u0026gt; \u0026lt;!-- 执行一些需要在clean之前完成的工作 --\u0026gt; \u0026lt;phase\u0026gt;pre-clean\u0026lt;/phase\u0026gt; \u0026lt;!-- 移除所有上一次构建生成的文件 --\u0026gt; \u0026lt;phase\u0026gt;clean\u0026lt;/phase\u0026gt; \u0026lt;!-- 执行一些需要在clean之后立刻完成的工作 --\u0026gt; \u0026lt;phase\u0026gt;post-clean\u0026lt;/phase\u0026gt; \u0026lt;/phases\u0026gt; \u0026lt;default-phases\u0026gt; \u0026lt;clean\u0026gt; org.apache.maven.plugins:maven-clean-plugin:2.5:clean \u0026lt;/clean\u0026gt; \u0026lt;/default-phases\u0026gt; 根据前面提到的阶段间依赖关系理论，当我们执行 mvn clean 的时候，会执行 clean 生命周期中的 pre-clean 和 clean 阶段。\nsite 生命周期 site 生命周期的目的是建立和发布项目站点，共包含 4 个阶段：\npre-site site post-site site-deploy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;phases\u0026gt; \u0026lt;!-- 执行一些需要在生成站点文档之前完成的工作 --\u0026gt; \u0026lt;phase\u0026gt;pre-site\u0026lt;/phase\u0026gt; \u0026lt;!-- 生成项目的站点文档作 --\u0026gt; \u0026lt;phase\u0026gt;site\u0026lt;/phase\u0026gt; \u0026lt;!-- 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备 --\u0026gt; \u0026lt;phase\u0026gt;post-site\u0026lt;/phase\u0026gt; \u0026lt;!-- 将生成的站点文档部署到特定的服务器上 --\u0026gt; \u0026lt;phase\u0026gt;site-deploy\u0026lt;/phase\u0026gt; \u0026lt;/phases\u0026gt; \u0026lt;default-phases\u0026gt; \u0026lt;site\u0026gt; org.apache.maven.plugins:maven-site-plugin:3.3:site \u0026lt;/site\u0026gt; \u0026lt;site-deploy\u0026gt; org.apache.maven.plugins:maven-site-plugin:3.3:deploy \u0026lt;/site-deploy\u0026gt; \u0026lt;/default-phases\u0026gt; Maven 能够基于 pom.xml 所包含的信息，自动生成一个友好的站点，方便团队交流和发布项目信息。\n","permalink":"https://jinchaojjj.github.io/posts/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/maven/","summary":"Maven 1. 什么是Maven maven是一个项目管理工具，可以对Java项目进行构建、依赖管理（也可以构建和管理其他语言的项目） 2. Maven的主要功","title":"Maven"},{"content":"git 1. Git 的三种状态 Git 有三种状态，你的文件可能处于其中之一：\n已提交（committed）：数据已经安全的保存在本地数据库中。 已修改（modified）：已修改表示修改了文件，但还没保存到数据库中。 已暂存（staged）：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 由此引入 Git 项目的三个工作区域的概念：Git 仓库(.git directory)、工作目录(Working Directory) 以及 暂存区域(Staging Area) 。\n基本的 Git 工作流程如下：\n在工作目录中修改文件。 暂存文件，将文件的快照放入暂存区域。 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。 2. 获取 Git 仓库 有两种取得 Git 项目仓库的方法。\n在现有目录中初始化仓库: 进入项目目录运行 git init 命令,该命令将创建一个名为 .git 的子目录。 从一个服务器克隆一个现有的 Git 仓库: git clone [url] 自定义本地仓库的名字: git clone [url] directoryname 3. 记录每次更新到仓库 检测当前文件状态 : git status 提出更改（把它们添加到暂存区）：git add filename (针对特定文件)、git add *(所有文件)、git add *.txt（支持通配符，所有 .txt 文件） 忽略文件：.gitignore 文件 提交更新: git commit -m \u0026quot;代码提交信息\u0026quot; （每次准备提交前，先用 git status 看下，是不是都已暂存起来了， 然后再运行提交命令 git commit） 跳过使用暂存区域更新的方式 : git commit -a -m \u0026quot;代码提交信息\u0026quot;。 git commit 加上 -a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤。 移除文件 ：git rm filename （从暂存区域移除，然后提交。） 对文件重命名 ：git mv README.md README(这个命令相当于mv README.md README、git rm README.md、git add README 这三条命令的集合) 4. 一个好的 Git 提交消息 一个好的 Git 提交消息如下：\n1 2 3 4 5 标题行：用这一行来描述和解释你的这次提交 主体部分可以是很少的几行，来加入更多的细节来解释提交，最好是能给出一些相关的背景或者解释这个提交能修复和解决什么问题。 主体部分当然也可以有几段，但是一定要注意换行和句子不要太长。因为这样在使用 \u0026#34;git log\u0026#34; 的时候会有缩进比较好看。 提交的标题行描述应该尽量的清晰和尽量的一句话概括。这样就方便相关的 Git 日志查看工具显示和其他人的阅读。\n推送改动到远程仓库 如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：git remote add origin \u0026lt;server\u0026gt; ,比如我们要让本地的一个仓库和 Github 上创建的一个仓库关联可以这样git remote add origin https://github.com/Snailclimb/test.git\n将这些改动提交到远端仓库：git push origin master (可以把 master 换成你想要推送的任何分支)\n如此你就能够将你的改动推送到所添加的服务器上去了。\n远程仓库的移除与重命名 将 test 重命名为 test1：git remote rename test test1 移除远程仓库 test1:git remote rm test1 查看提交历史 在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 git log 命令。git log 会按提交时间列出所有的更新，最近的更新排在最上面。\n可以添加一些参数来查看自己希望看到的内容：\n只看某个人的提交记录：\n1 git log --author=bob 撤销操作 有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 --amend 选项的提交命令尝试重新提交：\n1 git commit --amend 取消暂存的文件\n1 git reset filename 撤消对文件的修改:\n1 git checkout -- filename 假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：\n1 2 git fetch origin git reset --hard origin/master 分支 分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认”的分支。在其他分支上进行开发，完成后再将它们合并到主分支上。\n我们通常在开发新功能、修复一个紧急 bug 等等时候会选择创建分支。单分支开发好还是多分支开发好，还是要看具体场景来说。\n创建一个名字叫做 test 的分支\n1 git branch test 切换当前分支到 test（当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样）\n1 git checkout test 你也可以直接这样创建分支并切换过去(上面两条命令的合写)\n1 git checkout -b feature_x 切换到主分支\n1 git checkout master 合并分支(可能会有冲突)\n1 git merge test 把新建的分支删掉\n1 git branch -d feature_x 将分支推送到远端仓库（推送成功后其他人可见）：\n1 git push origin ","permalink":"https://jinchaojjj.github.io/posts/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/git/","summary":"git 1. Git 的三种状态 Git 有三种状态，你的文件可能处于其中之一： 已提交（committed）：数据已经安全的保存在本地数据库中。 已修改（modifi","title":"Git"},{"content":"Docker 文章链接\n","permalink":"https://jinchaojjj.github.io/posts/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/docker/","summary":"Docker 文章链接","title":"Docker"},{"content":"Servlet Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。\n使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。\nJava Servlet 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。但是相比于 CGI，Servlet 有以下几点优势：\n性能明显更好。 Servlet 在 Web 服务器的地址空间内执行。这样它就没有必要再创建一个单独的进程来处理每个客户端请求。 Servlet 是独立于平台的，因为它们是用 Java 编写的。 服务器上的 Java 安全管理器执行了一系列限制，以保护服务器计算机上的资源。因此，Servlet 是可信的。 Java 类库的全部功能对 Servlet 来说都是可用的。它可以通过 sockets 和 RMI 机制与 applets、数据库或其他软件进行交互。 Servlet 架构 下图显示了 Servlet 在 Web 应用程序中的位置。\nServlet 任务 Servlet 执行以下主要任务：\n读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单。 读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。 处理数据并生成结果。这个过程可能需要访问数据库，执行 RMI 或 CORBA 调用，调用 Web 服务，或者直接计算得出对应的响应。 发送显式的数据（即文档）到客户端（浏览器）。该文档的格式可以是多种多样的，包括文本文件（HTML 或 XML）、二进制文件（GIF 图像）、Excel 等。 发送隐式的 HTTP 响应到客户端（浏览器）。这包括告诉浏览器或其他客户端被返回的文档类型（例如 HTML），设置 cookies 和缓存参数，以及其他类似的任务。 Servlet 包 Java Servlet 是运行在带有支持 Java Servlet 规范的解释器的 web 服务器上的 Java 类。\nServlet 可以使用 javax.servlet 和 javax.servlet.http 包创建，它是 Java 企业版的标准组成部分，Java 企业版是支持大型开发项目的 Java 类库的扩展版本。\n这些类实现 Java Servlet 和 JSP 规范。在写本教程的时候，二者相应的版本分别是 Java Servlet 2.5 和 JSP 2.1。\nJava Servlet 就像任何其他的 Java 类一样已经被创建和编译。在您安装 Servlet 包并把它们添加到您的计算机上的 Classpath 类路径中之后，您就可以通过 JDK 的 Java 编译器或任何其他编译器来编译 Servlet。\nServlet是什么 Servlet对象是用于处理请求的实体，首先Web服务器在接受到请求后，会根据请求类型（通常是Http请求）封装为一个ServletRequest对象（Http请求对应的就是HttpServletRequest对象，是ServletRequest的子类）；然后根据请求路径判断处理该请求的Servlet类是哪个，首先判断该类型是否已经创建了对象，若该类型还没有创建实例对象则创建一个对象，在创建对象后将ServletRequest、ServletResponse对象传递给Servlet方法，Servlet方法根据编写好的代码对请求进行处理，在处理完成后将需要的数据放入一并传输过来的ServletResponse对象中即可，Web服务器根据ServletResponse中设置的返回信息将信息封装为Http响应发送给前段。\nServlet需要学的东西 Servlet中比较重要的东西：一次请求、一次会话、一次运行、过滤器、监听器\n一次请求指的是一次HTTP请求，其中涉及到啦HttpServlet、HttpServletRequest、HttpServletResponse\n一次会话指的是浏览器打开期间一直在这个网站中访问的过程，涉及到Cookie、Session\n一次运行指的是服务器从开始运行到关闭这段时间，涉及到：ServletContext\n过滤器用于对发送往服务器的请求进行过滤：Filter\n监听器主要作用是对一些行为进行监听：Listener\nHttpServletRequest 讲述HttpServletRequest中的内容其实应该先对Http请求做介绍，不过这部分在计算机网络再进行介绍。\nHttpServletRequest 接口，它继承自 ServletRequest 接口。HttpServletRequest 对象专门用于封装 HTTP 请求消息，简称 request 对象。\nHTTP 请求消息分为请求行、请求消息头和请求消息体三部分，所以 HttpServletRequest 接口中定义了获取请求行、请求头和请求消息体的相关方法。\n获取请求行信息 HTTP 请求的请求行中包含请求方法、请求资源名、请求路径等信息，HttpServletRequest 接口定义了一系列获取请求行信息的方法，如下表。\n返回值类型 方法声明 描述 String getMethod() 该方法用于获取 HTTP 请求方式（如 GET、POST 等）。 String getRequestURI() 该方法用于获取请求行中的资源名称部分，即位于 URL 的主机和端口之后，参数部分之前的部分。 String getQueryString() 该方法用于获取请求行中的参数部分，也就是 URL 中“?”以后的所有内容。 String getContextPath() 返回当前 Servlet 所在的应用的名字（上下文）。对于默认（ROOT）上下文中的 Servlet，此方法返回空字符串\u0026quot;\u0026quot;。 String getServletPath() 该方法用于获取 Servlet 所映射的路径。 String getRemoteAddr() 该方法用于获取客户端的 IP 地址。 String getRemoteHost() 该方法用于获取客户端的完整主机名，如果无法解析出客户机的完整主机名，则该方法将会返回客户端的 IP 地址。 获取请求头信息 当浏览器发送请求时，需要通过请求头向服务器传递一些附加信息，例如客户端可以接收的数据类型、压缩方式、语言等。为了获取请求头中的信息， HttpServletRequest 接口定义了一系列用于获取 HTTP 请求头字段的方法，如下表所示。\n返回值类型 方法声明 描述 String getHeader(String name) 该方法用于获取一个指定头字段的值。 如果请求消息中包含多个指定名称的头字段，则该方法返回其中第一个头字段的值。 Enumeration getHeaders(String name) 该方法返回指定头字段的所有值的枚举集合， 在多数情况下，一个头字段名在请求消息中只出现一次，但有时可能会出现多次。 Enumeration getHeaderNames() 该方法返回请求头中所有头字段的枚举集合。 String getContentType() 该方法用于获取 Content-Type 头字段的值。 int getContentLength() 该方法用于获取 Content-Length 头字段的值 。 String getCharacterEncoding() 该方法用于返回请求消息的字符集编码 。 获取 form 表单的数据 在实际开发中，我们经常需要获取用户提交的表单数据，例如用户名和密码等。为了方便获取表单中的请求参数，ServletRequest 定义了一系列获取请求参数的方法，如下表所示。\n返回值类型 方法声明 功能描述 String getParameter(String name) 返回指定参数名的参数值。 String [ ] getParameterValues (String name) 以字符串数组的形式返回指定参数名的所有参数值（HTTP 请求中可以有多个相同参数名的参数）。 Enumeration getParameterNames() 以枚举集合的形式返回请求中所有参数名。 Map getParameterMap() 用于将请求中的所有参数名和参数值装入一个 Map 对象中返回。 HttpServlet HttpServlet继承自Servlet，其中Servlet的框架的核心是javax.servlet.Servlet接口,所有的Servlet都必须实现这一接口。在Servlet接口中定义了5个方法,其中有3个方法代表了Servlet的声明周期:\ninit方法,负责初始化Servlet对象 service方法,负责相应客户的请求 destory方法,当Servlet对象退出声明周期时,负责释放占有的资源\n当Web容器接收到某个Servlet请求时,Servlet把请求封装成一个HttpServletRequest对象,然后把对象传给Servlet的对应的服务方法.\nHTTP的请求方式包括DELETE,GET,OPTIONS,POST,PUT和TRACE,在HttpServlet类中分别提供了相应的服务方法,它们是,doDelete(),doGet(),doOptions(),doPost(), doPut()和doTrace().\n在没有重写service方法时，Http Servlet的做法是判断http请求的请求方式，然后调用对应请求方式的方法。\nHttpServletResponse Servlet 中的 doXXX 方法的目的就是根据请求计算得到响应, 然后把响应的数据设置到HttpServletResponse 对象中， 然后 Tomcat 就会把这个 HttpServletResponse 对象按照 HTTP 协议的格式, 转成一个字符串, 并通过Socket 写回给浏览器；\n核心方法 方法 描述 void setStatus(int sc) 设置响应状态码 void setHeader(String name,String value) 设置一个带有给定的名称和值的Header，如果name已经存在，则覆盖旧的值 void addHeader(int sc) 设置一个带有给定的名称和值的Header，如果name存在，不会覆盖旧的值，并列添加新的值 void setContentType(String type) 设置被发送到客户端的响应的内容类型 void setCharacterEncoding( String charset) 设置被发送到客户端的响应的字符编码(MIME 字符集) void sendRedirect(String location) 使用指定的重定向位置 URL 发送临时重定向响应到客户端 PrintWriter getWriter() 用于往 body 中写入文本格式数据 OutputStream getOutStream() 用于往 body 中写入二进制格式数据 Cookie \u0026amp; Session cookie其实就是一些记录在浏览器中的键值对（这些键值对在浏览器中保存时存在时间限制），并且请求时这些cookie的值就会带过来，后端并不会对cookie中的值进行保存（在不就行主动保存的情况下）。\nSession可以的主要作用就是根据cookie中的JSESSIONID创建一个用于保存本次会话期间一直存在的对象，比如保存了登陆的信息啊等等等，因为cookie信息是保存在前端可以篡改的，不要直接在cookie中保存信息用于校验。而session信息是保存在后端的，虽然用户可以更改JSESSIONID用于骗取信息，但是由于是随机生成的，相对来说更加安全一点，并且session的信息是存储在后端的。\nsession对象在后端中保存的时间存在限制，通常是30分钟，虽然有时候前段网页关闭后JSESSIONID值就已经消失了，但是后端的session还是存在的，要等到超时后才会删除。\nFilter 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import javax.servlet.*; import javax.servlet.annotation.WebFilter; import java.io.IOException; @WebFilter(\u0026#34;/*\u0026#34;) public class MyFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\u0026#34;对request进行过滤\u0026#34;); //下面这行代码就是放行 filterChain.doFilter(servletRequest,servletResponse); System.out.println(\u0026#34;对response进行过滤\u0026#34;); } } 主要通过上述的方式进行过滤，通常是判断请求路径是否合规，是否对相关信息处理等。\n","permalink":"https://jinchaojjj.github.io/posts/%E6%A1%86%E6%9E%B6/servlet/","summary":"Servlet Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。 使用 Serv","title":"Servlet"},{"content":"Spring 在学习Spring的过程中首先需要明确一点，并不是只有在Web开发中使用到例如SSM框架的时候才可以使用Spring，尤其是Spring核心，他提供的两大功能是IoC与AOP。两个功能分别表示控制反转与面向切面编程，很多教程往往在介绍的时候将Spring放在Web开发的语境下，这是不对的，Spring的最主要的目的是解耦合，所以在任何你希望降低耦合度的场景中都是可以使用到Spring的，而不是局限在Web开发中。\nSpring主要实现了两个功能：IOC和AOP。IOC指的是控制反转，其中需要了解的内容有：\nBean注册的方式（注解、XML两种方式） 容器中Bean的生命周期 IOC 首先看下面的代码\n1 2 3 4 5 6 7 8 9 10 11 12 class A{ private List\u0026lt;B\u0026gt; list; public B test(B b){ return null; } } class C{ public C(B b){} } class B{ } 可以看到，A和C在大量地直接使用B，但是某一天，这个B的实现已经过时了，此时来了个把功能实现的更好的D，我们需要用这个新的类来完成业务了，但是更新之后可能源代码就无法使用了，需要更改非常多的地方，这就是耦合，大家都牵连在一起，牵一发而动全身。\nIOC是Inversion of Control的缩写，翻译为：“控制反转”，把复杂系统分解成相互合作的对象，这些对象类通过封装以后，内部实现对外部是透明的，从而降低了解决问题的复杂度，而且可以灵活地被重用和扩展。\n我们可以将对象交给IoC容器进行管理，比如当我们需要一个接口的实现时，由它根据配置文件来决定到底给我们哪一个实现类，这样，我们就可以不用再关心我们要去使用哪一个实现类了，我们只需要关心，给到我的一定是一个可以正常使用的实现类，能用就完事了，反正接口定义了啥，我只管调，这样，我们就可以放心地让一个人去写视图层的代码，一个人去写业务层的代码，开发效率那是高的一匹啊。\n还是之前的代码，但是有了IoC容器加持之后：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public static void main(String[] args) { A a = new A(); a.test(IoC.getBean(Service.class)); //瞎编的一个容器类，但是是那个意思 //比如现在在IoC容器中管理的Service的实现是B，那么我们从里面拿到的Service实现就是B } class A{ private List\u0026lt;Service\u0026gt; list; //一律使用Service，具体实现由IoC容器提供 public Service test(Service b){ return null; } } interface Service{ } //使用Service做一个顶层抽象 class B implements Service{} //B依然是具体实现类，并交给IoC容器管理 上图中使用到了接口，可能有小伙伴要问接口要是改了怎么办，一般认为在项目开发中接口的指定是需要提前规划制定好的，最好不要去轻易更改。可以更改什么呢，可以更改其实现类，这样就可以很方便的替换实现的对象了。\n当具体实现类发生修改时，我们同样只需要将新的实现类交给IoC容器管理，这样我们无需修改之前的任何代码：\n1 2 3 interface Service{ } class D implements Service{} //现在实现类变成了D，但是之前的代码并不会报错 这样，即使我们的底层实现类发生了修改，也不会导致与其相关联的类出现错误，而进行大面积修改，通过定义抽象+容器管理的形式，我们就可以将原有的强关联解除。\n高内聚，低耦合，是现代软件的开发的设计目标，而Spring框架就给我们提供了这样的一个IoC容器进行对象的的管理，一个由Spring IoC容器实例化、组装和管理的对象，我们称其为Bean。(在这种结构中，接口的定义好坏很大程度上决定了项目的维护成本，接口的定义就是架构师的事情了，咱都是打工人啊)\n第一个Spring项目 首先一定要明确，使用Spring首要目的是为了使得软件项目进行解耦，而不是为了去简化代码！通过它，就可以更好的对我们的Bean进行管理，这一部分我们来体验一下Spring的基本使用。\nSpring并不是一个独立的框架，它实际上包含了很多的模块：\n而我们首先要去学习的就是Core Container，也就是核心容器模块，只有了解了Spring的核心技术，我们才能真正认识这个框架为我们带来的便捷之处。\nSpring是一个非入侵式的框架，就像一个工具库一样，它可以很简单地加入到我们已有的项目中，因此，我们只需要直接导入其依赖就可以使用了，Spring核心框架的Maven依赖坐标：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.13\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; **注意：**与旧版教程不同的是，Spring 6要求你使用的Java版本为17及以上，包括后面我们在学习SpringMVC时，要求Tomcat版本必须为10以上。这个依赖中包含了如下依赖：\n这里我们就来尝试编写一个最简的Spring项目，我们在前面已经讲过了，Spring会给我们提供IoC容器用于管理Bean，但是我们得先为这个容器编写一个配置文件，我们可以通过配置文件告诉容器需要管理哪些Bean以及Bean的属性、依赖关系等等。\n首先我们需要在resource中创建一个Spring配置文件（在resource中创建的文件，会在编译时被一起放到类路径下），命名为test.xml，直接右键点击即可创建：\n1 2 3 4 5 6 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;/beans\u0026gt; Spring为我们提供了一个IoC容器，用于去存放我们需要使用的对象，我们可以将对象交给IoC容器进行管理，当我们需要使用对象时，就可以向IoC容器去索要，并由它来决定给我们哪一个对象。而我们如果需要使用Spring为我们提供的IoC容器，那么就需要创建一个应用程序上下文，它代表的就是IoC容器，它会负责实例化、配置和组装Bean：\n1 2 3 4 5 public static void main(String[] args) { //ApplicationContext是应用程序上下文的顶层接口，它有很多种实现，这里我们先介绍第一种 //因为这里使用的是XML配置文件，所以说我们就使用 ClassPathXmlApplicationContext 这个实现类 ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;test.xml\u0026#34;); //这里写上刚刚的名字 } 下面需要将对象交给Bean管理，这时候需要在XML中配置相关信息\n1 \u0026lt;bean name=\u0026#34;student\u0026#34; class=\u0026#34;com.test.bean.Student\u0026#34;/\u0026gt; 里我们就在配置文件中编写好了对应Bean的信息，之后容器就会根据这里的配置进行处理了。\n现在，这个对象不需要我们再去创建了，而是由IoC容器自动进行创建并提供，我们可以直接从上下文中获取到它为我们创建的对象：\n1 2 3 4 5 public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;test.xml\u0026#34;); Student student = context.getBean(Student.class); student.hello(); } Bean注册与配置 前面我们通过一个简单例子体验了一下如何使用Spring来管理我们的对象，并向IoC容器索要被管理的对象。\n在使用IOC的这个流程中可以分为两部分：不同的注册的方式和配置内容、以及不同的获取Bean的方式。在这节中先介绍Bean的注册和配置\n注册 但是为了简单起见，我们还是从单配置文件开始讲起，首先我们需要知道如何配置Bean并注册。\n要配置一个Bean，只需要添加：\n1 2 \u0026lt;bean/\u0026gt; 复制代码 但是这样写的话，Spring无法得知我们要配置的Bean到底是哪一个类，所以说我们还得指定对应的类才可以：\n1 \u0026lt;bean class=\u0026#34;com.test.bean.Student\u0026#34;/\u0026gt; 可以看到类的旁边出现了Bean的图标，表示我们的Bean已经注册成功了，这样，我们就可以根据类型向容器索要Bean实例对象了：\n1 2 3 4 5 6 7 public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;test.xml\u0026#34;); //getBean有多种形式，其中第一种就是根据类型获取对应的Bean //容器中只要注册了对应类的Bean或是对应类型子类的Bean，都可以获取到 Student student = context.getBean(Student.class); student.hello(); } name 不过在有些时候，Bean的获取可能会出现歧义，我们可以来分别注册两个子类的Bean：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class ArtStudent extends Student{ public void art(){ System.out.println(\u0026#34;我爱画画\u0026#34;); } } public class SportStudent extends Student{ public void sport(){ System.out.println(\u0026#34;我爱运动\u0026#34;); } } \u0026lt;bean class=\u0026#34;com.test.bean.ArtStudent\u0026#34;/\u0026gt; \u0026lt;bean class=\u0026#34;com.test.bean.SportStudent\u0026#34;/\u0026gt; 但是此时我们在获取Bean时却是索要的它们的父类：\n1 2 Student student = context.getBean(Student.class); student.hello(); 运行时得到如下报错：\n这里出现了一个Bean定义不唯一异常，很明显，因为我们需要的类型是Student，但是此时有两个Bean定义都满足这个类型，它们都是Student的子类，此时IoC容器不知道给我们返回哪一个Bean，所以就只能抛出异常了。\n因此，如果我们需要一个Bean并且使用类型进行获取，那么必须要指明类型并且不能出现歧义：\n1 2 ArtStudent student = context.getBean(ArtStudent.class); student.art(); 那要是两个Bean的类型都是一样的呢？\n1 2 \u0026lt;bean class=\u0026#34;com.test.bean.Student\u0026#34;/\u0026gt; \u0026lt;bean class=\u0026#34;com.test.bean.Student\u0026#34;/\u0026gt; 这种情况下，就无法使用Class来进行区分了，除了为Bean指定对应类型之外，我们也可以为Bean指定一个名称用于区分：\n1 2 \u0026lt;bean name=\u0026#34;art\u0026#34; class=\u0026#34;com.test.bean.ArtStudent\u0026#34;/\u0026gt; \u0026lt;bean name=\u0026#34;sport\u0026#34; class=\u0026#34;com.test.bean.SportStudent\u0026#34;/\u0026gt; name属性就是为这个Bean设定一个独一无二的名称（id属性也可以，跟name功能相同，但是会检查命名是否规范，否则会显示黄标），不同的Bean名字不能相同，否则报错：\n1 2 \u0026lt;bean name=\u0026#34;a\u0026#34; class=\u0026#34;com.test.bean.Student\u0026#34;/\u0026gt; \u0026lt;bean name=\u0026#34;b\u0026#34; class=\u0026#34;com.test.bean.Student\u0026#34;/\u0026gt; 这样，这两个Bean我们就可以区分出来了：\n1 2 Student student = (Student) context.getBean(\u0026#34;a\u0026#34;); student.hello(); 虽然目前这两Bean定义都是一模一样的，也没什么区别，但是这确实是两个不同的Bean，只是类型一样而已，之后我们还可以为这两个Bean分别设置不同的其他属性。\n别名 我们可以给Bean起名字，也可以起别名，就行我们除了有一个名字之外，可能在家里还有自己的小名：\n1 2 \u0026lt;bean name=\u0026#34;a\u0026#34; class=\u0026#34;com.test.bean.Student\u0026#34;/\u0026gt; \u0026lt;alias name=\u0026#34;a\u0026#34; alias=\u0026#34;test\u0026#34;/\u0026gt; 这样，我们使用别名也是可以拿到对应的Bean的：\n1 2 Student student = (Student) context.getBean(\u0026#34;test\u0026#34;); student.hello(); 创建方式 那么现在又有新的问题了，IoC容器创建的Bean是只有一个还是每次索要的时候都会给我们一个新的对象？我们现在在主方法中连续获取两次Bean对象：\n1 2 3 Student student1 = context.getBean(Student.class); Student student2 = context.getBean(Student.class); System.out.println(student1 == student2); //默认为单例模式，对象始终为同一个 我们发现，最后得到的结果为true，那么说明每次从IoC容器获取到的对象，始终都是同一个，默认情况下，通过IoC容器进行管理的Bean都是单例模式的，这个对象只会被创建一次。\n如果我们希望每次拿到的对象都是一个新的，我们也可以将其作用域进行修改：\n这里一共有两种作用域，第一种是singleton，默认情况下就是这一种，当然还有prototype，表示为原型模式（为了方便叫多例模式也行）这种模式每次得到的对象都是一个新的：\n1 2 3 Student student1 = context.getBean(Student.class); //原型模式下，对象不再始终是同一个了 Student student2 = context.getBean(Student.class); System.out.println(student1 == student2); 实际上，当Bean的作用域为单例模式时，那么它会在一开始（容器加载配置时）就被创建，我们之后拿到的都是这个对象。而处于原型模式下，只有在获取时才会被创建，也就是说，单例模式下，Bean会被IoC容器存储，只要容器没有被销毁，那么此对象将一直存在，而原型模式才是相当于在要用的时候直接new了一个对象，并不会被保存。\n懒加载 当然，如果我们希望单例模式下的Bean不用再一开始就加载，而是一样等到需要时再加载（加载后依然会被容器存储，之后一直使用这个对象了，不会再创建新的）我们也可以开启懒加载：\n1 \u0026lt;bean class=\u0026#34;com.test.bean.Student\u0026#34; lazy-init=\u0026#34;true\u0026#34;/\u0026gt; 开启懒加载后，只有在真正第一次使用时才会创建对象。\n加载顺序依赖 因为单例模式下Bean是由IoC容器加载，但是加载顺序我们并不清楚，如果我们需要维护Bean的加载顺序（比如某个Bean必须要在另一个Bean之前创建）那么我们可以使用depends-on来设定前置加载Bean，这样被依赖的Bean一定会在之前加载，比如Teacher应该在Student之前加载：\n1 2 \u0026lt;bean name=\u0026#34;teacher\u0026#34; class=\u0026#34;com.test.bean.Teacher\u0026#34;/\u0026gt; \u0026lt;bean name=\u0026#34;student\u0026#34; class=\u0026#34;com.test.bean.Student\u0026#34; depends-on=\u0026#34;teacher\u0026#34;/\u0026gt; 这样就可以保证Bean的加载顺序了。\n依赖注入 基本注入 依赖注入(Dependency Injection, DI)是一种设计模式，也是Spring框架的核心概念之一。现在我们已经了解了如何注册和使用一个Bean，但是这样还远远不够，还记得我们一开始说的，消除类之间的强关联吗？比如现在有一个教师接口：\n1 2 3 public interface Teacher { void teach(); } 具体的实现有两个：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class ArtTeacher implements Teacher{ @Override public void teach() { System.out.println(\u0026#34;我是美术老师，我教你画画！\u0026#34;); } } public class ProgramTeacher implements Teacher{ @Override public void teach() { System.out.println(\u0026#34;我是编程老师，我教你学Golang！\u0026#34;); } } 我们的学生一开始有一个老师教他，比如美术老师：\n1 2 3 4 5 6 7 public class Student { private Teacher teacher = new ArtTeacher(); //在以前，如果我们需要制定哪个老师教我们，直接new创建对应的对象就可以了 public void study(){ teacher.teach(); } } 但是我们发现，如果美术老师不教了，现在来了一个其他的老师教学生，那么就需要去修改Student类的定义：\n1 2 3 public class Student { private Teacher teacher = new ProgramTeacher(); ... 可以想象一下，如果现在冒出来各种各样的类都需要这样去用Teacher，那么一旦Teacher的实现发生变化，会导致我们挨个对之前用到Teacher的类进行修改，这就很难受了。\n而有了依赖注入之后，Student中的Teacher成员变量，可以由IoC容器来选择一个合适的Teacher对象进行赋值，也就是说，IoC容器在创建对象时，需要将我们预先给定的属性注入到对象中，非常简单，我们可以使用property标签来实现，我们将bean标签展开：\n1 2 3 4 \u0026lt;bean name=\u0026#34;teacher\u0026#34; class=\u0026#34;com.test.bean.ProgramTeacher\u0026#34;/\u0026gt; \u0026lt;bean name=\u0026#34;student\u0026#34; class=\u0026#34;com.test.bean.Student\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;teacher\u0026#34; ref=\u0026#34;teacher\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 同时我们还需要修改一下Student类，依赖注入要求对应的属性必须有一个set方法：\n1 2 3 4 5 6 7 public class Student { private Teacher teacher; //要使用依赖注入，我们必须提供一个set方法（无论成员变量的访问权限是什么）命名规则依然是驼峰命名法 public void setTeacher(Teacher teacher) { this.teacher = teacher; } ... 使用property来指定需要注入的值或是一个Bean，这里我们选择ProgramTeacher，那么在使用时，Student类中的得到的就是这个Bean的对象了：\n1 2 Student student = context.getBean(Student.class); student.study(); 可以看到，现在我们的Java代码中，没有出现任何的具体实现类信息（ArtTeacher、ProgramTeacher都没出现）取而代之的是那一堆xml配置，这样，就算我们切换老师的实现为另一个类，也不用去调整代码，只需要变动一下Bean的类型就可以：\n1 2 3 4 5 \u0026lt;!-- 只需要修改这里的class即可，现在改为ArtTeacher --\u0026gt; \u0026lt;bean name=\u0026#34;teacher\u0026#34; class=\u0026#34;com.test.bean.ArtTeacher\u0026#34;/\u0026gt; \u0026lt;bean name=\u0026#34;student\u0026#34; class=\u0026#34;com.test.bean.Student\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;teacher\u0026#34; ref=\u0026#34;teacher\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 这样，这个Bean的class就变成了新的类型，并且我们不需要再去调整其他位置的代码，再次启动程序：\n通过依赖注入，是不是开始逐渐感受到Spring为我们带来的便利了？当然，依赖注入并不一定要注入其他的Bean，也可以是一个简单的值：\n1 2 3 \u0026lt;bean name=\u0026#34;student\u0026#34; class=\u0026#34;com.test.bean.Student\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;king\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 直接使用value可以直接传入一个具体值。\n构造函数 实际上，在很多情况下，类中的某些参数是在构造方法中就已经完成的初始化，而不是创建之后，比如：\n1 2 3 4 5 6 7 public class Student { private final Teacher teacher; //构造方法中完成，所以说是一个final变量 public Student(Teacher teacher){ //Teacher属性是在构造方法中完成的初始化 this.teacher = teacher; } ... 我们前面说了，Bean实际上是由IoC容器进行创建的，但是现在我们修改了默认的无参构造，可以看到配置文件里面报错了：\n很明显，是因为我们修改了构造方法，IoC容器默认只会调用无参构造，所以，我们需要指明一个可以用的构造方法，我们展开bean标签，添加一个constructor-arg标签：\n1 2 3 4 \u0026lt;bean name=\u0026#34;teacher\u0026#34; class=\u0026#34;com.test.bean.ArtTeacher\u0026#34;/\u0026gt; \u0026lt;bean name=\u0026#34;student\u0026#34; class=\u0026#34;com.test.bean.Student\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;teacher\u0026#34; ref=\u0026#34;teacher\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 这里的constructor-arg就是构造方法的一个参数，这个参数可以写很多个，会自动匹配符合里面参数数量的构造方法，这里匹配的就是我们刚刚编写的需要一个参数的构造方法。\n通过这种方式，我们也能实现依赖注入，只不过现在我们将依赖注入的时机提前到了对象构造时。\n那要是出现这种情况呢？现在我们的Student类中是这样定义的：\n1 2 3 4 5 6 7 8 9 10 11 12 public class Student { private final String name; public Student(String name){ System.out.println(\u0026#34;我是一号构造方法\u0026#34;); this.name = name; } public Student(int age){ System.out.println(\u0026#34;我是二号构造方法\u0026#34;); this.name = String.valueOf(age); } } 此时我们希望使用的是二号构造方法，那么怎么才能指定呢？有2种方式，我们可以给标签添加类型：\n1 \u0026lt;constructor-arg value=\u0026#34;1\u0026#34; type=\u0026#34;int\u0026#34;/\u0026gt; 也可以指定为对应的参数名称：\n1 \u0026lt;constructor-arg value=\u0026#34;1\u0026#34; name=\u0026#34;age\u0026#34;/\u0026gt; 反正只要能够保证我们指定的参数匹配到目标构造方法即可。\n现在我们的类中出现了一个比较特殊的类型，它是一个集合类型：\n1 2 3 4 5 6 7 public class Student { private List\u0026lt;String\u0026gt; list; public void setList(List\u0026lt;String\u0026gt; list) { this.list = list; } } 对于这种集合类型，有着特殊的支持：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;bean name=\u0026#34;student\u0026#34; class=\u0026#34;com.test.bean.Student\u0026#34;\u0026gt; \u0026lt;!-- 对于集合类型，我们可以直接使用标签编辑集合的默认值 --\u0026gt; \u0026lt;property name=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;AAA\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;BBB\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;CCC\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 不仅仅是List，Map、Set这类常用集合类包括数组在内，都是支持这样编写的，比如Map类型，我们也可以使用entry来注入：\n1 2 3 4 5 6 7 8 9 \u0026lt;bean name=\u0026#34;student\u0026#34; class=\u0026#34;com.test.bean.Student\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;map\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;语文\u0026#34; value=\u0026#34;100.0\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;数学\u0026#34; value=\u0026#34;80.0\u0026#34;/\u0026gt; \u0026lt;entry key=\u0026#34;英语\u0026#34; value=\u0026#34;92.5\u0026#34;/\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 至此，我们就已经完成了两种依赖注入的学习：\nSetter依赖注入：通过成员属性对应的set方法完成注入。 构造方法依赖注入：通过构造方法完成注入。 自动装配 在之前，如果我们需要使用依赖注入的话，我们需要对property参数进行配置：\n1 2 3 \u0026lt;bean name=\u0026#34;student\u0026#34; class=\u0026#34;com.test.bean.Student\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;teacher\u0026#34; ref=\u0026#34;teacher\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 但是有些时候为了方便，我们也可以开启自动装配。自动装配就是让IoC容器自己去寻找需要填入的值，我们只需要将set方法提供好就可以了，这里需要添加autowire属性：\n1 \u0026lt;bean name=\u0026#34;student\u0026#34; class=\u0026#34;com.test.bean.Student\u0026#34; autowire=\u0026#34;byType\u0026#34;/\u0026gt; autowire属性有两个值普通，一个是byName，还有一个是byType，顾名思义，一个是根据类型去寻找合适的Bean自动装配，还有一个是根据名字去找，这样我们就不需要显式指定property了。\n此时set方法旁边会出现一个自动装配图标，效果和上面是一样的。\n对于使用构造方法完成的依赖注入，也支持自动装配，我们只需要将autowire修改为：\n1 \u0026lt;bean name=\u0026#34;student\u0026#34; class=\u0026#34;com.test.bean.Student\u0026#34; autowire=\u0026#34;constructor\u0026#34;/\u0026gt; 这样，我们只需要提供一个对应参数的构造方法就可以了（这种情况默认也是byType寻找的）：\n这样同样可以完成自动注入：\n自动化的东西虽然省事，但是太过机械，有些时候，自动装配可能会遇到一些问题，比如出现了下面的情况：\n此时，由于autowire的规则为byType，存在两个候选Bean，但是我们其实希望ProgramTeacher这个Bean在任何情况下都不参与到自动装配中，此时我们就可以将它的自动装配候选关闭：\n1 2 3 \u0026lt;bean name=\u0026#34;teacher\u0026#34; class=\u0026#34;com.test.bean.ArtTeacher\u0026#34;/\u0026gt; \u0026lt;bean name=\u0026#34;teacher2\u0026#34; class=\u0026#34;com.test.bean.ProgramTeacher\u0026#34; autowire-candidate=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;bean name=\u0026#34;student\u0026#34; class=\u0026#34;com.test.bean.Student\u0026#34; autowire=\u0026#34;byType\u0026#34;/\u0026gt; 当autowire-candidate设定false时，这个Bean将不再作为自动装配的候选Bean，此时自动装配候选就只剩下一个唯一的Bean了，报错消失，程序可以正常运行。\n除了这种方式，我们也可以设定primary属性，表示这个Bean作为主要的Bean，当出现歧义时，也会优先选择：\n1 2 3 \u0026lt;bean name=\u0026#34;teacher\u0026#34; class=\u0026#34;com.test.bean.ArtTeacher\u0026#34; primary=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;bean name=\u0026#34;teacher2\u0026#34; class=\u0026#34;com.test.bean.ProgramTeacher\u0026#34;/\u0026gt; \u0026lt;bean name=\u0026#34;student\u0026#34; class=\u0026#34;com.test.bean.Student\u0026#34; autowire=\u0026#34;byType\u0026#34;/\u0026gt; 这样写程序依然可以正常运行，并且选择的也是ArtTeacher\n生命周期与继承 除了修改构造方法，我们也可以为Bean指定初始化方法和销毁方法，以便在对象创建和被销毁时执行一些其他的任务：\n1 2 3 4 5 6 7 public void init(){ System.out.println(\u0026#34;我是对象初始化时要做的事情！\u0026#34;); } public void destroy(){ System.out.println(\u0026#34;我是对象销毁时要做的事情！\u0026#34;); } 我们可以通过init-method和destroy-method来指定：\n1 \u0026lt;bean name=\u0026#34;student\u0026#34; class=\u0026#34;com.test.bean.Student\u0026#34; init-method=\u0026#34;init\u0026#34; destroy-method=\u0026#34;destroy\u0026#34;/\u0026gt; 那么什么时候是初始化，什么时候又是销毁呢？\n1 2 3 4 //当容器创建时，默认情况下Bean都是单例的，那么都会在一开始就加载好，对象构造完成后，会执行init-method ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;test.xml\u0026#34;); //我们可以调用close方法关闭容器，此时容器内存放的Bean也会被一起销毁，会执行destroy-method context.close(); 所以说，最后的结果为：\n注意，如果Bean不是单例模式，而是采用的原型模式，那么就只会在获取时才创建，并调用init-method，而对应的销毁方法不会被调用（因此，对于原型模式下的Bean，Spring无法顾及其完整生命周期，而在单例模式下，Spring能够从Bean对象的创建一直管理到对象的销毁）\nBean之间也是具备继承关系的，只不过这里的继承并不是类的继承，而是属性的继承，比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class SportStudent { private String name; public void setName(String name) { this.name = name; } } public class ArtStudent { private String name; public void setName(String name) { this.name = name; } } 此时，我们先将ArtStudent注册一个Bean：\n1 2 3 \u0026lt;bean name=\u0026#34;artStudent\u0026#34; class=\u0026#34;com.test.bean.ArtStudent\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 这里我们会注入一个name的初始值，此时我们创建了一个SportStudent的Bean，我们希望这个Bean的属性跟刚刚创建的Bean属性是一样的，那么我们可以写一个一模一样的：\n1 2 3 \u0026lt;bean class=\u0026#34;com.test.bean.SportStudent\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 但是如果属性太多的话，是不是写起来有点麻烦？这种情况，我们就可以配置Bean之间的继承关系了，我们可以让SportStudent这个Bean直接继承ArtStudent这个Bean配置的属性：\n1 \u0026lt;bean class=\u0026#34;com.test.bean.SportStudent\u0026#34; parent=\u0026#34;artStudent\u0026#34;/\u0026gt; 这样，在ArtStudent Bean中配置的属性，会直接继承给SportStudent Bean（注意，所有配置的属性，在子Bean中必须也要存在，并且可以进行注入，否则会出现错误）当然，如果子类中某些属性比较特殊，也可以在继承的基础上单独配置：\n1 2 3 4 5 6 7 \u0026lt;bean name=\u0026#34;artStudent\u0026#34; class=\u0026#34;com.test.bean.ArtStudent\u0026#34; abstract=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;id\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean class=\u0026#34;com.test.bean.SportStudent\u0026#34; parent=\u0026#34;artStudent\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;id\u0026#34; value=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 如果我们只是希望某一个Bean仅作为一个配置模版供其他Bean继承使用，那么我们可以将其配置为abstract，这样，容器就不会创建这个Bean的对象了：\n1 2 3 4 \u0026lt;bean name=\u0026#34;artStudent\u0026#34; class=\u0026#34;com.test.bean.ArtStudent\u0026#34; abstract=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;name\u0026#34; value=\u0026#34;小明\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean class=\u0026#34;com.test.bean.SportStudent\u0026#34; parent=\u0026#34;artStudent\u0026#34;/\u0026gt; 注意，一旦声明为抽象Bean，那么就无法通过容器获取到其实例化对象了。\n不过Bean的继承使用频率不是很高，了解就行。\n这里最后再提一下，我们前面已经学习了各种各样的Bean配置属性，如果我们希望整个上下文中所有的Bean都采用某种配置，我们可以在最外层的beans标签中进行默认配置：\n这样，即使Bean没有配置某项属性，但是只要在最外层编写了默认配置，那么同样会生效，除非Bean自己进行配置覆盖掉默认配置。\n工厂模式和工厂Bean 前面我们介绍了IoC容器的Bean创建机制，默认情况下，容器会调用Bean对应类型的构造方法进行对象创建，但是在某些时候，我们可能不希望外界使用类的构造方法完成对象创建，比如在工厂方法设计模式中（详情请观看《Java设计模式》篇 视频教程）我们更希望 Spring不要直接利用反射机制通过构造方法创建Bean对象， 而是利用反射机制先找到对应的工厂类，然后利用工厂类去生成需要的Bean对象：\n1 2 3 4 5 6 7 8 9 10 11 12 public class Student { Student() { System.out.println(\u0026#34;我被构造了\u0026#34;); } } public class StudentFactory { public static Student getStudent(){ System.out.println(\u0026#34;欢迎光临电子厂\u0026#34;); return new Student(); } } 此时Student有一个工厂，我们正常情况下需要使用工厂才可以得到Student对象，现在我们希望Spring也这样做，不要直接去反射搞构造方法创建，我们可以通过factory-method进行指定：\n1 \u0026lt;bean class=\u0026#34;com.test.bean.StudentFactory\u0026#34; factory-method=\u0026#34;getStudent\u0026#34;/\u0026gt; 注意，这里的Bean类型需要填写为Student类的工厂类，并且添加factory-method指定对应的工厂方法，但是最后注册的是工厂方法的返回类型，所以说依然是Student的Bean：\n此时我们再去进行获取，拿到的也是通过工厂方法得到的对象：\n这里有一个误区，千万不要认为是我们注册了StudentFactory这个Bean，class填写为这个类这个只是为了告诉Spring我们的工厂方法在哪个位置，真正注册的是工厂方法提供的东西。\n可以发现，当我们采用工厂模式后，我们就无法再通过配置文件对Bean进行依赖注入等操作了，而是只能在工厂方法中完成，这似乎与Spring的设计理念背道而驰？\n当然，可能某些工厂类需要构造出对象之后才能使用，我们也可以将某个工厂类直接注册为工厂Bean：\n1 2 3 4 5 6 public class StudentFactory { public Student getStudent(){ System.out.println(\u0026#34;欢迎光临电子厂\u0026#34;); return new Student(); } } 现在需要StudentFactory对象才可以获取到Student，此时我们就只能先将其注册为Bean了：\n1 \u0026lt;bean name=\u0026#34;studentFactory\u0026#34; class=\u0026#34;com.test.bean.StudentFactory\u0026#34;/\u0026gt; 像这样将工厂类注册为Bean，我们称其为工厂Bean，然后再使用factory-bean来指定Bean的工厂Bean：\n1 \u0026lt;bean factory-bean=\u0026#34;studentFactory\u0026#34; factory-method=\u0026#34;getStudent\u0026#34;/\u0026gt; 注意，使用factory-bean之后，不再要求指定class，我们可以直接使用了：\n此时可以看到，工厂方法上同样有了图标，这种方式，由于工厂类被注册为Bean，此时我们就可以在配置文件中为工厂Bean配置依赖注入等内容了。\n这里还有一个很细节的操作，如果我们想获取工厂Bean为我们提供的Bean，可以直接输入工厂Bean的名称，这样不会得到工厂Bean的实例，而是工厂Bean生产的Bean的实例：\n1 Student bean = (Student) context.getBean(\u0026#34;studentFactory\u0026#34;); 当然，如果我们需要获取工厂类的实例，可以在名称前面添加\u0026amp;符号：\n1 StudentFactory bean = (StudentFactory) context.getBean(\u0026#34;\u0026amp;studentFactory\u0026#34;); 又是一个小细节\n使用注解开发 @Configuration 前面我们已经完成了大部分的配置文件学习，但是我们发现，使用配置文件进行配置，貌似有点太累了吧？可以想象一下，如果我们的项目非常庞大，整个配置文件将会充满Bean配置，并且会继续庞大下去，能否有一种更加高效的方法能够省去配置呢？还记得我们在JavaWeb阶段用到的非常方便东西吗？没错，就是注解。\n既然现在要使用注解来进行开发，那么我们就删掉之前的xml配置文件吧，我们来看看使用注解能有多方便。\n1 ApplicationContext context = new AnnotationConfigApplicationContext(); 现在我们使用AnnotationConfigApplicationContext作为上下文实现，它是注解配置的。\n既然现在采用注解，我们就需要使用类来编写配置文件，在之前，我们如果要编写一个配置的话，需要：\n1 2 3 4 5 6 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;/beans\u0026gt; 现在我们只需要创建一个配置类就可以了：\n1 2 3 @Configuration public class MainConfiguration { } 这两者是等价的，同样的，在一开始会提示我们没有配置上下文：\n这里按照要求配置一下就可以，同上，这个只是会影响IDEA的代码提示，不会影响程序运行。\n我们可以为AnnotationConfigApplicationContext指定一个默认的配置类：\n1 2 ApplicationContext context = new AnnotationConfigApplicationContext(MainConfiguration.class); //这个构造方法可以接收多个配置类（更准确的说是多个组件） @Bean 那么现在我们该如何配置Bean呢？\n1 2 3 4 5 6 7 @Configuration public class MainConfiguration { @Bean(\u0026#34;student\u0026#34;) public Student student(){ return new Student(); } } 这样写相对于配置文件中的：\n1 2 3 4 5 6 7 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\u0026#34;\u0026gt; \u0026lt;bean name = \u0026#34;student\u0026#34; class=\u0026#34;com.test.bean.Student\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; @Import 通过@Import还可以引入其他配置类：\n1 2 3 @Import(LBWConfiguration.class) //在讲解到Spring原理时，我们还会遇到它，目前只做了解即可。 @Configuration public class MainConfiguration { 只不过现在变成了由Java代码为我们提供Bean配置，这样会更加的灵活，也更加便于控制Bean对象的创建。\n1 2 3 ApplicationContext context = new AnnotationConfigApplicationContext(MainConfiguration.class); Student student = context.getBean(Student.class); System.out.println(student); 使用方法是相同的，这跟使用XML配置是一样的。\nInit、destroy、auto、scope、lazy、dependsOn 那么肯定就有小伙伴好奇了，我们之前使用的那么多特性在哪里配置呢？首先，初始化方法和摧毁方法、自动装配可以直接在@Bean注解中进行配置：\n1 2 3 4 @Bean(name = \u0026#34;\u0026#34;, initMethod = \u0026#34;\u0026#34;, destroyMethod = \u0026#34;\u0026#34;, autowireCandidate = false) public Student student(){ return new Student(); } 其次，我们可以使用一些其他的注解来配置其他属性，比如：\n1 2 3 4 5 6 7 @Bean @Lazy(true) //对应lazy-init属性 @Scope(\u0026#34;prototype\u0026#34;) //对应scope属性 @DependsOn(\u0026#34;teacher\u0026#34;) //对应depends-on属性 public Student student(){ return new Student(); } 对于那些我们需要通过构造方法或是Setter完成依赖注入的Bean，比如：\n1 2 3 4 \u0026lt;bean name=\u0026#34;teacher\u0026#34; class=\u0026#34;com.test.bean.ProgramTeacher\u0026#34;/\u0026gt; \u0026lt;bean name=\u0026#34;student\u0026#34; class=\u0026#34;com.test.bean.Student\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;teacher\u0026#34; ref=\u0026#34;teacher\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 像这种需要引入其他Bean进行的注入，我们可以直接将其作为形式参数放到方法中：\n1 2 3 4 5 6 7 8 9 10 11 12 @Configuration public class MainConfiguration { @Bean public Teacher teacher(){ return new Teacher(); } @Bean public Student student(Teacher teacher){ return new Student(teacher); } } 此时我们可以看到，旁边已经出现图标了：\n运行程序之后，我们发现，这样确实可以直接得到对应的Bean并使用。\n只不过，除了这种基于构造器或是Setter的依赖注入之外，我们也可以直接到Bean对应的类中使用自动装配：\n1 2 3 4 public class Student { @Autowired //使用此注解来进行自动装配，由IoC容器自动为其赋值 private Teacher teacher; } @Autowired 现在，我们甚至连构造方法和Setter都不需要去编写了，就能直接完成自动装配，是不是感觉比那堆配置方便多了？\n当然，@Autowired并不是只能用于字段，对于构造方法或是Setter，它同样可以：\n1 2 3 4 5 6 7 8 public class Student { private Teacher teacher; @Autowired public void setTeacher(Teacher teacher) { this.teacher = teacher; } } @Autowired默认采用byType的方式进行自动装配，也就是说会使用类型进行配，那么要是出现了多个相同类型的Bean，如果我们想要指定使用其中的某一个该怎么办呢？\n1 2 3 4 5 6 7 8 9 @Bean(\u0026#34;a\u0026#34;) public Teacher teacherA(){ return new Teacher(); } @Bean(\u0026#34;b\u0026#34;) public Teacher teacherB(){ return new Teacher(); } 此时，我们可以配合@Qualifier进行名称匹配：\n1 2 3 4 5 public class Student { @Autowired @Qualifier(\u0026#34;a\u0026#34;) //匹配名称为a的Teacher类型的Bean private Teacher teacher; } @Resource 这里需要提一下，在我们旧版本的SSM教程中讲解了@Resource这个注解，但是现在它没有了。\n随着Java版本的更新迭代，某些javax包下的包，会被逐渐弃用并移除。在JDK11版本以后，javax.annotation这个包被移除并且更名为jakarta.annotation（我们在JavaWeb篇已经介绍过为什么要改名字了）其中有一个非常重要的注解，叫做@Resource，它的作用与@Autowired时相同的，也可以实现自动装配，但是在IDEA中并不推荐使用@Autowired注解对成员字段进行自动装配，而是推荐使用@Resource，如果需要使用这个注解，还需要额外导入包：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;jakarta.annotation\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jakarta.annotation-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 使用方法一样，直接替换掉就可以了：\n1 2 3 4 public class Student { @Resource private Teacher teacher; } 只不过，他们两有些机制上的不同：\n@Resource默认ByName如果找不到则ByType，可以添加到set方法、字段上。 @Autowired默认是byType，只会根据类型寻找，可以添加在构造方法、set方法、字段、方法参数上。 因为@Resource的匹配机制更加合理高效，因此官方并不推荐使用@Autowired字段注入，当然，实际上Spring官方更推荐我们使用基于构造方法或是Setter的@Autowired注入，比如Setter 注入的一个好处是，Setter 方法使该类的对象能够在以后重新配置或重新注入。其实，最后使用哪个注解，还是看你自己，要是有强迫症不能忍受黄标但是又实在想用字段注入，那就用@Resource注解。\n除了这个注解之外，还有@PostConstruct和@PreDestroy，它们效果和init-method和destroy-method是一样的：\n1 2 3 4 5 6 7 8 9 @PostConstruct public void init(){ System.out.println(\u0026#34;我是初始化方法\u0026#34;); } @PreDestroy public void destroy(){ System.out.println(\u0026#34;我是销毁方法\u0026#34;); } 我们只需要将其添加到对应的方法上即可：\n1 2 3 AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfiguration.class); Student student = context.getBean(Student.class); context.close(); 可以看到效果是完全一样的，这些注解都是jakarta.annotation提供的，有关Spring和JakartaEE的渊源，还请各位小伙伴自行了解。\n@Component 前面我们介绍了使用@Bean来注册Bean，但是实际上我们发现，如果只是简单将一个类作为Bean的话，这样写还是不太方便，因为都是固定模式，就是单纯的new一个对象出来，能不能像之前一样，让容器自己反射获取构造方法去生成这个对象呢？\n肯定是可以的，我们可以在需要注册为Bean的类上添加@Component注解来将一个类进行注册**（现在最常用的方式）**，不过要实现这样的方式，我们需要添加一个自动扫描来告诉Spring，它需要在哪些包中查找我们提供的@Component声明的Bean。\n1 2 3 4 @Component(\u0026#34;lbwnb\u0026#34;) //同样可以自己起名字 public class Student { } @ComponentScan 要注册这个类的Bean，只需要添加@Component即可，然后配置一下包扫描：\n1 2 3 4 5 @Configuration @ComponentScan(\u0026#34;com.test.bean\u0026#34;) //包扫描，这样Spring就会去扫描对应包下所有的类 public class MainConfiguration { } Spring在扫描对应包下所有的类时，会自动将那些添加了@Component的类注册为Bean，是不是感觉很方便？只不过这种方式只适用于我们自己编写类的情况，如果是第三方包提供的类，只能使用前者完成注册，并且这种方式并不是那么的灵活。\n不过，无论是通过@Bean还是@Component形式注册的Bean，Spring都会为其添加一个默认的name属性，比如：\n1 2 3 @Component public class Student { } 它的默认名称生产规则依然是类名并按照首字母小写的驼峰命名法来的，所以说对应的就是student：\n1 2 Student student = (Student) context.getBean(\u0026#34;student\u0026#34;); //这样同样可以获取到 System.out.println(student); 同样的，如果是通过@Bean注册的，默认名称是对应的方法名称：\n1 2 3 4 5 6 7 @Bean public Student artStudent(){ return new Student(); } Student student = (Student) context.getBean(\u0026#34;artStudent\u0026#34;); System.out.println(student); 相比传统的XML配置方式，注解形式的配置确实能够减少我们很多工作量。并且，对于这种使用@Component注册的Bean，如果其构造方法不是默认无参构造，那么默认会对其每一个参数都进行自动注入：\n1 2 3 4 5 6 7 @Component public class Student { Teacher teacher; public Student(Teacher teacher){ //如果有Teacher类型的Bean，那么这里的参数会被自动注入 this.teacher = teacher; } } 最后，对于我们之前使用的工厂模式，Spring也提供了接口，我们可以直接实现接口表示这个Bean是一个工厂Bean：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Component public class StudentFactory implements FactoryBean\u0026lt;Student\u0026gt; { @Override public Student getObject() { //生产的Bean对象 return new Student(); } @Override public Class\u0026lt;?\u0026gt; getObjectType() { //生产的Bean类型 return Student.class; } @Override public boolean isSingleton() { //生产的Bean是否采用单例模式 return false; } } 实际上跟我们之前在配置文件中编写是一样的，这里就不多说了。\n请注意，使用注解虽然可以省事很多，代码也能变得更简洁，但是这并不代表XML配置文件就是没有意义的，它们有着各自的优点，在不同的场景下合理使用，能够起到事半功倍的效果，官方原文：\nAre annotations better than XML for configuring Spring?\nThe introduction of annotation-based configuration raised the question of whether this approach is “better” than XML. The short answer is “it depends.” The long answer is that each approach has its pros and cons, and, usually, it is up to the developer to decide which strategy suits them better. Due to the way they are defined, annotations provide a lot of context in their declaration, leading to shorter and more concise configuration. However, XML excels at wiring up components without touching their source code or recompiling them. Some developers prefer having the wiring close to the source while others argue that annotated classes are no longer POJOs and, furthermore, that the configuration becomes decentralized and harder to control.\nNo matter the choice, Spring can accommodate both styles and even mix them together. It is worth pointing out that through its JavaConfig option, Spring lets annotations be used in a non-invasive way, without touching the target components source code and that, in terms of tooling, all configuration styles are supported by the Spring Tools for Eclipse.\n至此，关于Spring的IoC基础部分，我们就全部介绍完了。在最后，留给各位小伙伴一个问题，现在有两个类：\n1 2 3 4 5 6 7 8 9 10 11 @Component public class Student { @Resource private Teacher teacher; } @Component public class Teacher { @Resource private Student student; } 这两个类互相需要注入对方的实例对象，这个时候Spring会怎么进行处理呢？如果Bean变成原型模式，Spring又会怎么处理呢？\n这个问题我们会在实现原理探究部分进行详细介绍。\nAOP面向切片 又是一个听起来很高大上的名词，AOP（Aspect Oriented Programming）思想实际上就是：在运行时，动态地将代码切入到类的指定方法、指定位置上。也就是说，我们可以使用AOP来帮助我们在方法执行前或执行之后，做一些额外的操作，实际上，它就是代理！\n通过AOP我们可以在保证原有业务不变的情况下，添加额外的动作，比如我们的某些方法执行完成之后，需要打印日志，那么这个时候，我们就可以使用AOP来帮助我们完成，它可以批量地为这些方法添加动作。可以说，它相当于将我们原有的方法，在不改变源代码的基础上进行了增强处理。\n相当于我们的整个业务流程，被直接斩断，并在断掉的位置添加了一个额外的操作，再连接起来，也就是在一个切点位置插入内容。它的原理实际上就是通过动态代理机制实现的，我们在JavaWeb阶段已经给大家讲解过动态代理了。不过Spring底层并不是使用的JDK提供的动态代理，而是使用的第三方库实现，它能够以父类的形式代理，而不仅仅是接口。\n使用配置实现AOP 在开始之前，我们先换回之前的XML配置模式，之后也会给大家讲解如何使用注解完成AOP操作，注意这里我们还加入了一些新的AOP相关的约束进来，建议直接CV下面的：\n1 2 3 4 5 6 7 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;/beans\u0026gt; Spring是支持AOP编程的框架之一（实际上它整合了AspectJ框架的一部分），要使用AOP我们需要先导入一个依赖：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-aspects\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;6.0.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 那么，如何使用AOP呢？首先我们要明确，要实现AOP操作，我们需要知道这些内容：\n需要切入的类，类的哪个方法需要被切入 切入之后需要执行什么动作 是在方法执行前切入还是在方法执行后切入 如何告诉Spring需要进行切入 比如现在我们希望对这个学生对象的study方法进行增强，在不修改源代码的情况下，增加一些额外的操作：\n1 2 3 4 5 6 7 8 public class Student { public void study(){ System.out.println(\u0026#34;室友还在打游戏，我狠狠的学Java，太爽了\u0026#34;); //现在我们希望在这个方法执行完之后，打印一些其他的内容，在不修改原有代码的情况下，该怎么做呢？ } } \u0026lt;bean class=\u0026#34;org.example.entity.Student\u0026#34;/\u0026gt; 那么我们按照上面的流程，依次来看，首先需要解决的问题是，找到需要切入的类，很明显，就是这个Student类，我们要切入的是这个study方法。\n第二步，我们切入之后要做什么呢？这里我们直接创建一个新的类，并将要执行的操作写成一个方法：\n1 2 3 4 5 6 public class StudentAOP { //这个方法就是我们打算对其进行的增强操作 public void afterStudy() { System.out.println(\u0026#34;好好学习。。。\u0026#34;); } } 注意这个类也得注册为Bean才可以：\n1 \u0026lt;bean id=\u0026#34;studentAOP\u0026#34; class=\u0026#34;org.example.entity.StudentAOP\u0026#34;/\u0026gt; 第三步，我们要明确这是在方法执行之前切入还是执行之后切入，很明显，按照上面的要求，我们需要执行之后进行切入。\n第四步，最关键的来了，我们怎么才能告诉Spring我们要进行切入操作呢？这里我们需要在配置文件中进行AOP配置：\n1 2 3 \u0026lt;aop:config\u0026gt; \u0026lt;/aop:config\u0026gt; 接着我们需要添加一个新的切点，首先填写ID，这个随便起都可以：\n1 \u0026lt;aop:pointcut id=\u0026#34;test\u0026#34; expression=\u0026#34;\u0026#34;/\u0026gt; 然后就是通过后面的expression表达式来选择到我们需要切入的方法，这个表达式支持很多种方式进行选择，Spring AOP支持以下AspectJ切点指示器（PCD）用于表达式：\nexecution：用于匹配方法执行连接点。这是使用Spring AOP时使用的主要点切割指示器。 within：限制匹配到某些类型的连接点（使用Spring AOP时在匹配类型中声明的方法的执行）。 this：限制与连接点匹配（使用Spring AOP时方法的执行），其中bean引用（Spring AOP代理）是给定类型的实例。 target：限制匹配连接点（使用Spring AOP时方法的执行），其中目标对象（正在代理的应用程序对象）是给定类型的实例。 args：限制与连接点匹配（使用Spring AOP时方法的执行），其中参数是给定类型的实例。 @target：限制匹配连接点（使用Spring AOP时方法的执行），其中执行对象的类具有给定类型的注释。 @args：限制匹配到连接点（使用Spring AOP时方法的执行），其中传递的实际参数的运行时类型具有给定类型的注释。 @within：限制与具有给定注释的类型中的连接点匹配（使用Spring AOP时在带有给定注释的类型中声明的方法的执行）。 @annotation：与连接点主体（在Spring AOP中运行的方法）具有给定注释的连接点匹配的限制。 更多详细内容请查阅：https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-pointcuts-designators\n其中，我们主要学习的execution填写格式如下：\n1 修饰符 包名.类名.方法名称(方法参数) 修饰符：public、protected、private、包括返回值类型、static等等（使用代表任意修饰符） 包名：如com.test（*代表全部，比如com.代表com包下的全部包） 类名：使用*也可以代表包下的所有类 方法名称：可以使用*代表全部方法 方法参数：填写对应的参数即可，比如(String, String)，也可以使用*来代表任意一个参数，使用..代表所有参数。 也可以使用其他属性来进行匹配，比如@annotation可以用于表示标记了哪些注解的方法被切入，这里我们就只是简单的执行，所以说只需要这样写就可以了：\n1 \u0026lt;aop:pointcut id=\u0026#34;test\u0026#34; expression=\u0026#34;execution(* org.example.entity.Student.study())\u0026#34;/\u0026gt; 这样，我们就指明了需要切入的方法，然后就是将我们的增强方法，我们在里面继续添加aop:aspect标签，并使用ref属性将其指向我们刚刚注册的AOP类Bean：\n1 2 3 4 5 6 \u0026lt;aop:config\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;test\u0026#34; expression=\u0026#34;execution(* org.example.entity.Student.study())\u0026#34;/\u0026gt; \u0026lt;aop:aspect ref=\u0026#34;studentAOP\u0026#34;\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt; 接着就是添加后续动作了，当然，官方支持的有多种多样的，比如执行前、执行后、抛出异常后、方法返回后等等：\n其中around方法为环绕方法，自定义度会更高，我们会在稍后介绍。这里我们按照上面的要求，直接添加后续动作，注意需要指明生效的切点：\n1 2 3 4 \u0026lt;aop:aspect ref=\u0026#34;studentAOP\u0026#34;\u0026gt; \u0026lt;!-- method就是我们的增强方法，pointcut-ref指向我们刚刚创建的切点 --\u0026gt; \u0026lt;aop:after method=\u0026#34;afterStudy\u0026#34; pointcut-ref=\u0026#34;test\u0026#34;/\u0026gt; \u0026lt;/aop:aspect\u0026gt; 这样，我们就成功配置好了，配置正确会在旁边出现图标：\n我们来试试看吧：\n1 2 3 4 5 public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;application.xml\u0026#34;); Student bean = context.getBean(Student.class); bean.study(); } 结果如下：\n可以看到在我们原本的方法执行完成之后，它还继续执行了我们的增强方法，这实际上就是动态代理做到的，实现在不修改原有代码的基础上，对方法的调用进行各种增强，在之后的SpringMVC学习中，我们甚至可以使用它来快速配置访问日志打印。\n前面我们说了，AOP是基于动态代理实现的，所以说我们如果直接获取Bean的类型，会发现不是原本的类型了：\n1 2 Student bean = context.getBean(Student.class); System.out.println(bean.getClass()); 这里其实是Spring通过CGLib为我们生成的动态代理类，也就不难理解为什么调用方法会直接得到增强之后的结果了。包括我们前面讲解Spring的异步任务调度时，为什么能够直接实现异步，其实就是利用了AOP机制实现的方法增强。\n虽然这些功能已经非常强大了，但是仅仅只能简单的切入还是不能满足一些需求，在某些情况下，我们可以需求方法执行的一些参数，比如方法执行之后返回了什么，或是方法开始之前传入了什么参数等等，现在我们修改一下Student中study方法的参数：\n1 2 3 4 5 public class Student { public void study(String str){ //现在方法有一个String类型的参数 System.out.println(\u0026#34;都别学Java了，快去卷\u0026#34;+str); } } 我们希望在增强的方法中也能拿到这个参数，然后进行处理：\n1 2 3 4 5 6 public class StudentAOP { public void afterStudy() { //这个str参数我们该从哪里拿呢？ System.out.println(\u0026#34;室友还在打游戏，我狠狠的学Java，太爽了\u0026#34; + arg); } } 这个时候，我们可以为我们切入的方法添加一个JoinPoint参数，通过此参数就可以快速获取切点位置的一些信息：\n1 2 3 4 public void afterStudy(JoinPoint point) { //JoinPoint实例会被自动传入 //这里我们直接通过getArgs()返回的参数数组获取第1个参数 System.out.println(\u0026#34;好好学习。。。\u0026#34; + point.getArgs()[0]); } 接着我们修改一下刚刚的AOP配置（因为方法参数有变动）看看结果吧：\n1 \u0026lt;aop:pointcut id=\u0026#34;test\u0026#34; expression=\u0026#34;execution(* org.example.entity.Student.study(String))\u0026#34;/\u0026gt; 现在我们来测试一下：\n1 2 3 4 5 public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;application.xml\u0026#34;); Student bean = context.getBean(Student.class); bean.study(\u0026#34;PHP\u0026#34;); } 是不是感觉大部分功能都可以通过AOP来完成了？\n我们接着来看自定义度更高的环绕方法，现在我们希望在方法执行前和执行后都加入各种各样的动作，如果还是一个一个切点写，有点太慢了，能不能直接写一起呢，此时我们就可以使用环绕方法。\n环绕方法相当于完全代理了此方法，它完全将此方法包含在中间，需要我们手动调用才可以执行此方法，并且我们可以直接获取更多的参数：\n1 2 3 4 5 6 public Object around(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\u0026#34;方法开始之前\u0026#34;); Object value = joinPoint.proceed(); //调用process方法来执行被代理的原方法，如果有返回值，可以使用value接收 System.out.println(\u0026#34;方法执行完成，结果为：\u0026#34;+value); return value; } 注意，如果代理方法存在返回值，那么环绕方法也需要有一个返回值，通过proceed方法来执行代理的方法，也可以修改参数之后调用proceed(Object[])，使用我们给定的参数再去执行：\n1 2 3 4 5 6 7 public Object around(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\u0026#34;方法开始之前\u0026#34;); String arg = joinPoint.getArgs()[0] + \u0026#34;king\u0026#34;; Object value = joinPoint.proceed(new Object[]{arg}); System.out.println(\u0026#34;方法执行完成，结果为：\u0026#34;+value); return value; } 这里我们还是以study方法为例，现在我们希望在调用前修改这个方法传入的参数值，改成我们自己的，然后在调用之后对返回值结果也进行处理：\n1 2 3 4 5 6 7 8 9 public String study(String str){ if(str.equals(\u0026#34;Java\u0026#34;)) System.out.println(\u0026#34;我的梦想是学Java\u0026#34;); else { System.out.println(\u0026#34;我就要学Java，不要修改我的梦想！\u0026#34;); str = \u0026#34;Java\u0026#34;; } return str; } 现在我们编写一个环绕方法，对其进行全方面处理：\n1 2 3 4 5 6 7 8 9 public Object around(ProceedingJoinPoint joinPoint) throws Throwable { System.out.println(\u0026#34;我是她的家长，他不能学Java，必须学Rust，这是为他好\u0026#34;); Object value = joinPoint.proceed(new Object[]{\u0026#34;Rust\u0026#34;}); if(value.equals(\u0026#34;Java\u0026#34;)) { System.out.println(\u0026#34;听话，学Rust以后进大厂！\u0026#34;); value = \u0026#34;Rust\u0026#34;; } return value; } 同样的，因为方法变动了，现在我们去修改一下我们的AOP配置：\n1 2 3 4 5 \u0026lt;aop:pointcut id=\u0026#34;test\u0026#34; expression=\u0026#34;execution(* org.example.entity.Student.study(String))\u0026#34;/\u0026gt; \u0026lt;aop:aspect ref=\u0026#34;studentAOP\u0026#34;\u0026gt; \u0026lt;aop:around method=\u0026#34;around\u0026#34; pointcut-ref=\u0026#34;test\u0026#34;/\u0026gt; \u0026lt;/aop:aspect\u0026gt; 复制代码 细心的小伙伴可能会发现，环绕方法的图标是全包的，跟我们之前的图标不太一样。\n现在我们来试试看吧：\n1 2 3 4 5 public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;application.xml\u0026#34;); Student bean = context.getBean(Student.class); System.out.println(\u0026#34;已报名：\u0026#34;+bean.study(\u0026#34;Java\u0026#34;)); } 这样，我们就实现了环绕方法，通过合理利用AOP带来的便捷，可以使得我们的代码更加清爽和优美。这里介绍一下 AOP 领域中的特性术语，防止自己下来看不懂文章：\n通知（Advice）: AOP 框架中的增强处理，通知描述了切面何时执行以及如何执行增强处理，也就是我们上面编写的方法实现。 连接点（join point）: 连接点表示应用执行过程中能够插入切面的一个点，这个点可以是方法的调用、异常的抛出，实际上就是我们在方法执行前或是执行后需要做的内容。 切点（PointCut）: 可以插入增强处理的连接点，可以是方法执行之前也可以方法执行之后，还可以是抛出异常之类的。 切面（Aspect）: 切面是通知和切点的结合，我们之前在xml中定义的就是切面，包括很多信息。 引入（Introduction）：引入允许我们向现有的类添加新的方法或者属性。 织入（Weaving）: 将增强处理添加到目标对象中，并创建一个被增强的对象，我们之前都是在将我们的增强处理添加到目标对象，也就是织入（这名字挺有文艺范的） 使用接口实现AOP 前面我们介绍了如何使用xml配置一个AOP操作，这节课我们来看看如何使用Advice实现AOP。\n它与我们之前学习的动态代理更接近一些，比如在方法开始执行之前或是执行之后会去调用我们实现的接口，首先我们需要将一个类实现Advice接口，只有实现此接口，才可以被通知，比如我们这里使用MethodBeforeAdvice表示是一个在方法执行之前的动作：\n1 2 3 4 5 6 public class StudentAOP implements MethodBeforeAdvice { @Override public void before(Method method, Object[] args, Object target) throws Throwable { System.out.println(\u0026#34;通过Advice实现AOP\u0026#34;); } } 我们发现，方法中包括了很多的参数，其中args代表的是方法执行前得到的实参列表，还有target表示执行此方法的实例对象。运行之后，效果和之前是一样的，但是在这里我们就可以快速获取到更多信息。还是以简单的study方法为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class Student { public void study(){ System.out.println(\u0026#34;我是学习方法！\u0026#34;); } } \u0026lt;bean id=\u0026#34;student\u0026#34; class=\u0026#34;org.example.entity.Student\u0026#34;/\u0026gt; \u0026lt;bean id=\u0026#34;studentAOP\u0026#34; class=\u0026#34;org.example.entity.StudentAOP\u0026#34;/\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;test\u0026#34; expression=\u0026#34;execution(* org.example.entity.Student.study())\u0026#34;/\u0026gt; \u0026lt;!-- 这里只需要添加我们刚刚写好的advisor就可以了，注意是Bean的名字 --\u0026gt; \u0026lt;aop:advisor advice-ref=\u0026#34;studentAOP\u0026#34; pointcut-ref=\u0026#34;test\u0026#34;/\u0026gt; \u0026lt;/aop:config\u0026gt; 我们来测试一下吧：\n除了此接口以外，还有其他的接口，比如AfterReturningAdvice就需要实现一个方法执行之后的操作：\n1 2 3 4 5 6 7 8 9 10 11 public class StudentAOP implements MethodBeforeAdvice, AfterReturningAdvice { @Override public void before(Method method, Object[] args, Object target) throws Throwable { System.out.println(\u0026#34;通过Advice实现AOP\u0026#34;); } @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable { System.out.println(\u0026#34;我是方法执行之后的结果，方法返回值为：\u0026#34;+returnValue); } } 因为使用的是接口，就非常方便，直接写一起，配置文件都不需要改了：\n我们也可以使用MethodInterceptor（同样也是Advice的子接口）进行更加环绕那样的自定义的增强，它用起来就真的像代理一样，例子如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Student { public String study(){ System.out.println(\u0026#34;我是学习方法！\u0026#34;); return \u0026#34;lbwnb\u0026#34;; } } public class StudentAOP implements MethodInterceptor { //实现MethodInterceptor接口 @Override public Object invoke(MethodInvocation invocation) throws Throwable { //invoke方法就是代理方法 Object value = invocation.proceed(); //跟之前一样，需要手动proceed()才能调用原方法 return value+\u0026#34;增强\u0026#34;; } } 我们来看看结果吧：\n使用起来还是挺简单的。\n使用注解实现AOP 接着我们来看看如何使用注解实现AOP操作，现在变回我们之前的注解开发，首先我们需要在主类添加@EnableAspectJAutoProxy注解，开启AOP注解支持：\n1 2 3 4 5 @EnableAspectJAutoProxy @ComponentScan(\u0026#34;org.example.entity\u0026#34;) @Configuration public class MainConfiguration { } 还是熟悉的玩法，类上直接添加@Component快速注册Bean：\n1 2 3 4 5 6 @Component public class Student { public void study(){ System.out.println(\u0026#34;我是学习方法！\u0026#34;); } } 接着我们需要在定义AOP增强操作的类上添加@Aspect注解和@Component将其注册为Bean即可，就像我们之前在配置文件中也要将其注册为Bean那样：\n1 2 3 4 5 @Aspect @Component public class StudentAOP { } 接着，我们可以在里面编写增强方法，并将此方法添加到一个切点中，比如我们希望在Student的study方法执行之前执行我们的before方法：\n1 2 3 public void before(){ System.out.println(\u0026#34;我是之前执行的内容！\u0026#34;); } 那么只需要添加@Before注解即可：\n1 2 3 4 @Before(\u0026#34;execution(* org.example.entity.Student.study())\u0026#34;) //execution写法跟之前一样 public void before(){ System.out.println(\u0026#34;我是之前执行的内容！\u0026#34;); } 这样，这个方法就会在指定方法执行之前执行了，是不是感觉比XML配置方便多了。我们来测试一下：\n1 2 3 4 5 public static void main(String[] args) { ApplicationContext context = new AnnotationConfigApplicationContext(MainConfiguration.class); Student bean = context.getBean(Student.class); bean.study(); } 同样的，我们可以为其添加JoinPoint参数来获取切入点信息，使用方法跟之前一样：\n1 2 3 4 5 @Before(\u0026#34;execution(* org.example.entity.Student.study())\u0026#34;) public void before(JoinPoint point){ System.out.println(\u0026#34;参数列表：\u0026#34;+ Arrays.toString(point.getArgs())); System.out.println(\u0026#34;我是之前执行的内容！\u0026#34;); } 为了更方便，我们还可以直接将参数放入，比如：\n1 2 3 public void study(String str){ System.out.println(\u0026#34;我是学习方法！\u0026#34;); } 使用命名绑定模式，可以快速得到原方法的参数：\n1 2 3 4 5 6 7 @Before(value = \u0026#34;execution(* org.example.entity.Student.study(..)) \u0026amp;\u0026amp; args(str)\u0026#34;, argNames = \u0026#34;str\u0026#34;) //命名绑定模式就是根据下面的方法参数列表进行匹配 //这里args指明参数，注意需要跟原方法保持一致，然后在argNames中指明 public void before(String str){ System.out.println(str); //可以快速得到传入的参数 System.out.println(\u0026#34;我是之前执行的内容！\u0026#34;); } 除了@Before，还有很多可以直接使用的注解，比如@AfterReturning、@AfterThrowing等，比如@AfterReturning：\n1 2 3 4 5 6 7 8 9 public String study(){ System.out.println(\u0026#34;我是学习方法！\u0026#34;); return \u0026#34;lbwnb\u0026#34;; } @AfterReturning(value = \u0026#34;execution(* org.example.entity.Student.study())\u0026#34;, argNames = \u0026#34;returnVal\u0026#34;, returning = \u0026#34;returnVal\u0026#34;) //使用returning指定接收方法返回值的参数returnVal public void afterReturn(Object returnVal){ System.out.println(\u0026#34;返回值是：\u0026#34;+returnVal); } 同样的，环绕也可以直接通过注解声明：\n1 2 3 4 5 6 7 8 @Around(\u0026#34;execution(* com.test.bean.Student.test(..))\u0026#34;) public Object around(ProceedingJoinPoint point) throws Throwable { System.out.println(\u0026#34;方法执行之前！\u0026#34;); Object val = point.proceed(); System.out.println(\u0026#34;方法执行之后！\u0026#34;); return val; } 复制代码 实际上，无论是使用注解或是XML配置，我们要做的流程都是一样的，在之后的学习中，我们还会遇到更多需要使用AOP的地方。\n","permalink":"https://jinchaojjj.github.io/posts/%E6%A1%86%E6%9E%B6/spring/","summary":"Spring 在学习Spring的过程中首先需要明确一点，并不是只有在Web开发中使用到例如SSM框架的时候才可以使用Spring，尤其是Spring核","title":"Spring"},{"content":"Spring MVC 1. 什么是Spring MVC MVC（Model–View–Controller）模式是软件工程中的一种软件架构模式，它把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。\nMVC 模式的目的是实现一种动态的程序设计，简化后续对程序的修改和扩展，并且使程序某一部分的重复利用成为可能。除此之外，MVC 模式通过对复杂度的简化，使程序的结构更加直观。软件系统在分离了自身的基本部分的同时，也赋予了各个基本部分应有的功能。专业人员可以通过自身的专长进行相关的分组：\n模型（Model）：程序员编写程序应有的功能（实现算法等）、数据库专家进行数据管理和数据库设计（可以实现具体的功能）； 控制器（Controller）：负责转发请求，对请求进行处理； 视图（View）：界面设计人员进行图形界面设计。 MVC 模式的描述如下图所示：\nMVC 模式中三个组件的详细介绍如下：\n模型（Model）：用于封装与应用程序业务逻辑相关的数据以及对数据的处理方法。Model 有对数据直接访问的权力，例如对数据库的访问。Model 不依赖 View 和 Controller，也就是说， Model 不关心它会被如何显示或是如何被操作。但是 Model 中数据的变化一般会通过一种刷新机制被公布。为了实现这种机制，那些用于监视此 Model 的 View 必须事先在此 Model 上注册，由此，View 可以了解在数据 Model 上发生的改变。（如，软件设计模式中的“观察者模式”）； 视图（View）：能够实现数据有目的的显示（理论上，这不是必需的）。在 View 中一般没有程序上的逻辑。为了实现 View 上的刷新功能，View 需要访问它监视的数据模型（即 Model），因此应该事先在被它监视的数据那里注册； 控制器（Controller）：起到不同层面间的组织作用，用于控制应用程序的流程。它处理事件并作出响应。“事件”包括用户的行为和数据 Model 上的改变。 从 MVC 模式的一般理解来看，视图层与模型层是存在直接联系的，并且模型层的变化会通过视图层反映出来，这确实是 MVC 模式的标准理解，不过在我目前接触到的实际应用中，更多的情况是，视图层与模型层是通过控制层联系起来的，两者之间并无直接的联系，三者之间的关系更类似下图所示：\n2. Spring MVC中不同层级与MVC中三层的关系 Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)\n通常我们编写后端代码时只需要负责上述代码即可，但是很多同学都搞不清楚这几个层级之间与MVC这几个之间的关系，看下图：\nView表示是视图就是用户看见的东西，在前后端分离的环境中Controller层通常只返回数据（JSON格式的），前段自己会根据得到的数据进行页面的渲染、显示等，这也就实现了前后分离的开发，通过HTTP响应报文中数据类型来控制（text/json这种格式）；而在传统的开发中，也就是后端根据模版引擎直接将前段页面实现的这种方式中，模版引擎其实代表的就是View，模版引擎在获得数据后渲染页面，然后将页面发送给前段。 Controller层是相互对应的 在Spring MVC中提供的类似Service、Dao等都是Modle层的东西，为了更好的对后端的开发进行抽象然后分出了这么多层级 3. SpringMVC的执行原理 SpringMVC本身的DispatcherServlet会对所有的请求做出拦截，然后根据请求信息选择合适的Controller。\n从本质上来说SMVC本身已经进行了一次Controller的选择，但是Controller中还会进一步会进行Service等的选择，因此这两部分是共同构成的MVC中的控制层，自己编写的Controller中进行了Service（model实现）的选择，并且在返回值中可以对返回的进行控制（返回值的格式、返回值的内容等）然后可以选择合适的模版引擎进行返回（可能是jsp、Thyeleaf等）\n4. HTTP请求 请求消息结构 由上图可看出，HTTP 请求由四部分组成：\n请求行：分别是请求方法+空格+URL+空格+协议版本+\\r\\n 请求头部：由多个请求头部键值对组成，中间以冒号:隔开，每个键值对最后是\\r\\n 空行：即\\r\\n 请求包体：包体部分 例子：\n1 2 3 GET / HTTP/1.0 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5) Accept: */* 其中：\n第1行是请求行，GET 为请求方法，/ 为URL，HTTP1.0 为协议版本，中间以空格隔开。 第2行与第3行是请求头。 请求头下面的空行，这里没有显示。 - 一般GET 请求不包含请求体，所以本请求中没有请求体。 响应消息结构 由上图可看出，HTTP 响应由四部分组成：\n状态行：分别是协议版本+空格+状态码+空格+状态码描述+\\r\\n 响应头部：由多个响应头部键值对组成，中间以冒号:隔开，每个键值对最后是\\r\\n 空行：即\\r\\n 响应包体：包体部分 例子：\n1 2 3 4 5 6 7 8 9 10 HTTP/1.0 200 OK Content-Type: text/plain Content-Length: 82 Expires: Thu, 05 Dec 1997 16:00:00 GMT Last-Modified: Wed, 5 August 1996 15:55:28 GMT Server: Apache 0.84 \u0026lt;html\u0026gt; \u0026lt;body\u0026gt;Hello HTTP\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 其中：\n第1行为响应状态行，HTTP/1.0 为协议版本，200 是响应状态码，OK是状态码描述，中间用空格隔开。 第2行到第6行为响应头。 第7行为空行。 第8行到第10行为响应内容。 HTTP 请求方法 HTTP 协议支持9 种请求方法，最常用的是GET 和POST 方法。\nHTTP GET 与POST 方法 GET 方法与POST 方法是最常用的两个HTTP 方法，来看下其异同点：\n请求内容存放位置不同：GET 方法一般没有请求体，其请求内容放在URL 参数中，POST 方法则将请求内容放在请求体中。 POST 方法 安全性更高：GET 请求一般是明文传输，不利于传输敏感数据。POST 请求内容在请求体中，更方便加密，提高安全性。 POST 方法传输的数据量更大：GET 请求内容在URL 中，因此有大小限制，而POST 请求 内容在请求体中，理论上没有大小限制。 HTTP 请求头字段 这里介绍一些常用的HTTP 请求头字段：\nHost：客户端端请求的域名。 Connection：告诉服务端，处理完本请求后，是否关闭连接。 User-Agent：客户端使用的浏览器或APP 类型/版本。 Accept：客户端支持哪些类型的文档。 Accept-Encoding ：客户端支持的编码类型。 Accept-Language ：客户端支持的语言类型。 Referer ：客户端从哪个网页过来的。 Cache-Control：指定缓存机制。\nHTTP 响应头字段 这里介绍一些常用的HTTP 响应头字段：\nAllow：表明服务器支持哪些请求方法，如GET，POST 等。 Content-Encoding：响应内容编码方法。 Content-Type：响应内容属于什么MIME 类型。 Content-Length：响应内容的长度。 Date：当前GMT 时间。 Expiress：响应内容过期时间，过期后将不再缓存内容。 Last-Modified：文档的最后改动时间。 Location：告诉客户端到哪里获取文档，一般用于重定向。 Refresh：浏览器在多少秒后刷新文档。 Server：服务器名字。 Set-Cookie：设置和页面关联的Cookie。 Date：表示消息发送时间。\nHTTP 响应状态码 服务器在向客户端返回内容时，会带有一个HTTP Status Code（状态码），用于告诉客户端的返回状态。\nHTTP 状态码分为5 种类型，由三个十进制数字组成。第一个数字（1-5）代表状态码的分类，后两位是其含义。\n常见状态码：\n5. Spring MVC的使用 a XML配置 创建基本的Java Web项目\n导入Spring MVC依赖jar包，版本需要根据Spring的版本进行选择\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;6.0.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 配置web.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;https://jakarta.ee/xml/ns/jakartaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd\u0026#34; version=\u0026#34;5.0\u0026#34;\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;mvc\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;!-- 指定我们刚刚创建在类路径下的XML配置文件 --\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:application.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;mvc\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt; 创建Spring配置文件，文件名是在3中注释所在的文件名\n1 2 3 4 5 6 7 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;/beans\u0026gt; 编写测试类\n1 2 3 4 5 6 7 8 @Controller public class HelloController { @ResponseBody @RequestMapping(\u0026#34;/\u0026#34;) public String hello(){ return \u0026#34;HelloWorld!\u0026#34;; } }\t开启注释扫描\n1 \u0026lt;context:component-scan base-package=\u0026#34;com.example\u0026#34;/\u0026gt; b 注解配置 编写主类，需要实现WebApplicationInitializer接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class MainInitializer implements WebApplicationInitializer { @Override public void onStartup(ServletContext servletContext) { // 创建注解配置WebApplicationContext AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext(); context.register(WebConfiguration.class); // 创建并注册DispatcherServlet DispatcherServlet servlet = new DispatcherServlet(context); servletContext .addServlet(\u0026#34;mvc\u0026#34;, servlet) //Servlet名称依然叫mvc .addMapping(\u0026#34;/\u0026#34;); //路径依然是\u0026#34;/\u0026#34;，跟之前XML配置一致 } } 编写配置类\n1 2 3 4 5 @Configuration @EnableWebMvc //快速配置SpringMvc注解 @ComponentScan(\u0026#34;com.example.controller\u0026#34;) public class WebConfiguration { } 这个时候就可以用a中的测试类了\nc 模版引擎配置 导入引擎\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.thymeleaf\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;thymeleaf-spring6\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.1.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 编写b中的配置类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @Configuration @EnableWebMvc @ComponentScan(\u0026#34;com.example.controller\u0026#34;) public class WebConfiguration { //我们需要使用ThymeleafViewResolver作为视图解析器，并解析我们的HTML页面 @Bean public ThymeleafViewResolver thymeleafViewResolver(SpringTemplateEngine springTemplateEngine){ ThymeleafViewResolver resolver = new ThymeleafViewResolver(); resolver.setOrder(1); //可以存在多个视图解析器，并且可以为他们设定解析顺序 resolver.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;); //编码格式是重中之重 resolver.setTemplateEngine(springTemplateEngine); //和之前JavaWeb阶段一样，需要使用模板引擎进行解析，所以这里也需要设定一下模板引擎 return resolver; } //配置模板解析器 @Bean public SpringResourceTemplateResolver templateResolver(){ SpringResourceTemplateResolver resolver = new SpringResourceTemplateResolver(); resolver.setSuffix(\u0026#34;.html\u0026#34;); //需要解析的后缀名称 resolver.setPrefix(\u0026#34;/\u0026#34;); //需要解析的HTML页面文件存放的位置，默认是webapp目录下，如果是类路径下需要添加classpath:前缀 return resolver; } //配置模板引擎Bean @Bean public SpringTemplateEngine springTemplateEngine(ITemplateResolver resolver){ SpringTemplateEngine engine = new SpringTemplateEngine(); engine.setTemplateResolver(resolver); //模板解析器，默认即可 return engine; } } 编写Controller\n1 2 3 4 5 6 7 8 9 @Controller //直接添加注解即可 public class HelloController { @RequestMapping(\u0026#34;/index\u0026#34;) //直接填写访问路径 public ModelAndView index(){ return new ModelAndView(\u0026#34;index\u0026#34;); //返回ModelAndView对象，这里填入了视图的名称 //返回后会经过视图解析器进行处理 } } 编写html\n1 2 3 4 5 6 7 8 9 10 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;测试\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;欢迎来到GayHub全球最大同性交友网站\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 注：在Controller中默认会使用ModelAndView对象进行数据的返回，模版引擎在配置中配置了解析的文件，会进行html的解析，可以使用@ResponseBody注解\n6. @RequestMapping详解 前面我们已经了解了如何创建一个控制器来处理我们的请求，接着我们只需要在控制器添加一个方法用于处理对应的请求即可，之前我们需要完整地编写一个Servlet来实现，而现在我们只需要添加一个@RequestMapping即可实现，其实从它的名字我们也能得知，此注解就是将请求和处理请求的方法建立一个映射关系，当收到请求时就可以根据映射关系调用对应的请求处理方法，那么我们就来先聊聊@RequestMapping吧，注解定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @Mapping public @interface RequestMapping { String name() default \u0026#34;\u0026#34;; @AliasFor(\u0026#34;path\u0026#34;) String[] value() default {}; @AliasFor(\u0026#34;value\u0026#34;) String[] path() default {}; RequestMethod[] method() default {}; String[] params() default {}; String[] headers() default {}; String[] consumes() default {}; String[] produces() default {}; } 复制代码 其中最关键的是path属性（等价于value），它决定了当前方法处理的请求路径，注意路径必须全局唯一，任何路径只能有一个方法进行处理，它是一个数组，也就是说此方法不仅仅可以只用于处理某一个请求路径，我们可以使用此方法处理多个请求路径：\n1 2 3 4 @RequestMapping({\u0026#34;/index\u0026#34;, \u0026#34;/test\u0026#34;}) public ModelAndView index(){ return new ModelAndView(\u0026#34;index\u0026#34;); } 现在我们访问/index或是/test都会经过此方法进行处理。\n我们也可以直接将@RequestMapping添加到类名上，表示为此类中的所有请求映射添加一个路径前缀，比如：\n1 2 3 4 5 6 7 8 9 @Controller @RequestMapping(\u0026#34;/yyds\u0026#34;) public class MainController { @RequestMapping({\u0026#34;/index\u0026#34;, \u0026#34;/test\u0026#34;}) public ModelAndView index(){ return new ModelAndView(\u0026#34;index\u0026#34;); } } 那么现在我们需要访问/yyds/index或是/yyds/test才可以得到此页面。我们可以直接在IDEA下方的端点板块中查看当前Web应用程序定义的所有请求映射，并且可以通过IDEA为我们提供的内置Web客户端直接访问某个路径。\n路径还支持使用通配符进行匹配：\n?：表示任意一个字符，比如@RequestMapping(\u0026quot;/index/x?\u0026quot;)可以匹配/index/xa、/index/xb等等。 *：表示任意0-n个字符，比如@RequestMapping(\u0026quot;/index/*\u0026quot;)可以匹配/index/lbwnb、/index/yyds等。 **：表示当前目录或基于当前目录的多级目录，比如@RequestMapping(\u0026quot;/index/**\u0026quot;)可以匹配/index、/index/xxx等。 我们接着来看下一个method属性，顾名思义，它就是请求的方法类型，我们可以限定请求方式，比如：\n1 2 3 4 @RequestMapping(value = \u0026#34;/index\u0026#34;, method = RequestMethod.POST) public ModelAndView index(){ return new ModelAndView(\u0026#34;index\u0026#34;); } 现在我们如果直接使用浏览器访问此页面，会显示405方法不支持，因为浏览器默认是直接使用GET方法获取页面，而我们这里指定为POST方法访问此地址，所以访问失败，我们现在再去端点中用POST方式去访问，成功得到页面。\n我们也可以使用衍生注解直接设定为指定类型的请求映射：\n1 2 3 4 @PostMapping(value = \u0026#34;/index\u0026#34;) public ModelAndView index(){ return new ModelAndView(\u0026#34;index\u0026#34;); } 这里使用了@PostMapping直接指定为POST请求类型的请求映射，同样的，还有@GetMapping可以直接指定为GET请求方式，这里就不一一列举了。\n我们可以使用params属性来指定请求必须携带哪些请求参数，比如：\n1 2 3 4 @RequestMapping(value = \u0026#34;/index\u0026#34;, params = {\u0026#34;username\u0026#34;, \u0026#34;password\u0026#34;}) public ModelAndView index(){ return new ModelAndView(\u0026#34;index\u0026#34;); } 比如这里我们要求请求中必须携带username和password属性，否则无法访问。它还支持表达式，比如我们可以这样编写：\n1 2 3 4 @RequestMapping(value = \u0026#34;/index\u0026#34;, params = {\u0026#34;!username\u0026#34;, \u0026#34;password\u0026#34;}) public ModelAndView index(){ return new ModelAndView(\u0026#34;index\u0026#34;); } 在username之前添加一个感叹号表示请求的不允许携带此参数，否则无法访问，我们甚至可以直接设定一个固定值：\n1 2 3 4 @RequestMapping(value = \u0026#34;/index\u0026#34;, params = {\u0026#34;username!=test\u0026#34;, \u0026#34;password=123\u0026#34;}) public ModelAndView index(){ return new ModelAndView(\u0026#34;index\u0026#34;); } 这样，请求参数username不允许为test，并且password必须为123，否则无法访问。\nheader属性用法与params一致，但是它要求的是请求头中需要携带什么内容，比如：\n1 2 3 4 @RequestMapping(value = \u0026#34;/index\u0026#34;, headers = \u0026#34;!Connection\u0026#34;) public ModelAndView index(){ return new ModelAndView(\u0026#34;index\u0026#34;); } 那么，如果请求头中携带了Connection属性，将无法访问。其他两个属性：\nconsumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html; produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回； 7. @RequestParam和@RequestHeader详解 我们接着来看，如何获取到请求中的参数。使用类似的请求方式进行时localhost:8080/webTest/index?name=aaa，如何获得name=aaa这部分信息。\n我们只需要为方法添加一个形式参数，并在形式参数前面添加@RequestParam注解即可：\n1 2 3 4 5 @RequestMapping(value = \u0026#34;/index\u0026#34;) public ModelAndView index(@RequestParam(\u0026#34;username\u0026#34;) String username){ System.out.println(\u0026#34;接受到请求参数：\u0026#34;+username); return new ModelAndView(\u0026#34;index\u0026#34;); } 我们需要在@RequestParam中填写参数名称，参数的值会自动传递给形式参数，我们可以直接在方法中使用，注意，如果参数名称与形式参数名称相同，即使不添加@RequestParam也能获取到参数值。\n一旦添加@RequestParam，那么此请求必须携带指定参数，我们也可以将require属性设定为false来将属性设定为非必须：\n1 2 3 4 5 @RequestMapping(value = \u0026#34;/index\u0026#34;) public ModelAndView index(@RequestParam(value = \u0026#34;username\u0026#34;, required = false) String username){ System.out.println(\u0026#34;接受到请求参数：\u0026#34;+username); return new ModelAndView(\u0026#34;index\u0026#34;); } 我们还可以直接设定一个默认值，当请求参数缺失时，可以直接使用默认值：\n1 2 3 4 5 @RequestMapping(value = \u0026#34;/index\u0026#34;) public ModelAndView index(@RequestParam(value = \u0026#34;username\u0026#34;, required = false, defaultValue = \u0026#34;伞兵一号\u0026#34;) String username){ System.out.println(\u0026#34;接受到请求参数：\u0026#34;+username); return new ModelAndView(\u0026#34;index\u0026#34;); } 如果需要使用Servlet原本的一些类，比如：\n1 2 3 4 5 @RequestMapping(value = \u0026#34;/index\u0026#34;) public ModelAndView index(HttpServletRequest request){ System.out.println(\u0026#34;接受到请求参数：\u0026#34;+request.getParameterMap().keySet()); return new ModelAndView(\u0026#34;index\u0026#34;); } 直接添加HttpServletRequest为形式参数即可，SpringMVC会自动传递该请求原本的HttpServletRequest对象，同理，我们也可以添加HttpServletResponse作为形式参数，甚至可以直接将HttpSession也作为参数传递：\n1 2 3 4 5 6 @RequestMapping(value = \u0026#34;/index\u0026#34;) public ModelAndView index(HttpSession session){ System.out.println(session.getAttribute(\u0026#34;test\u0026#34;)); session.setAttribute(\u0026#34;test\u0026#34;, \u0026#34;鸡你太美\u0026#34;); return new ModelAndView(\u0026#34;index\u0026#34;); } 我们还可以直接将请求参数传递给一个实体类：\n1 2 3 4 5 @Data public class User { String username; String password; } 注意必须携带set方法或是构造方法中包含所有参数，请求参数会自动根据类中的字段名称进行匹配：\n1 2 3 4 5 @RequestMapping(value = \u0026#34;/index\u0026#34;) public ModelAndView index(User user){ System.out.println(\u0026#34;获取到cookie值为：\u0026#34;+user); return new ModelAndView(\u0026#34;index\u0026#34;); } @RequestHeader与@RequestParam用法一致，不过它是用于获取请求头参数的，这里就不再演示了。\n8. @CookieValue和@SessionAttrbutie 通过使用@CookieValue注解，我们也可以快速获取请求携带的Cookie信息：\n1 2 3 4 5 6 7 @RequestMapping(value = \u0026#34;/index\u0026#34;) public ModelAndView index(HttpServletResponse response, @CookieValue(value = \u0026#34;test\u0026#34;, required = false) String test){ System.out.println(\u0026#34;获取到cookie值为：\u0026#34;+test); response.addCookie(new Cookie(\u0026#34;test\u0026#34;, \u0026#34;lbwnb\u0026#34;)); return new ModelAndView(\u0026#34;index\u0026#34;); } 同样的，Session也能使用注解快速获取：\n1 2 3 4 5 6 7 @RequestMapping(value = \u0026#34;/index\u0026#34;) public ModelAndView index(@SessionAttribute(value = \u0026#34;test\u0026#34;, required = false) String test, HttpSession session){ session.setAttribute(\u0026#34;test\u0026#34;, \u0026#34;xxxx\u0026#34;); System.out.println(test); return new ModelAndView(\u0026#34;index\u0026#34;); } 可以发现，通过使用SpringMVC框架，整个Web应用程序的开发变得非常简单，大部分功能只需要一个注解就可以搞定了，正是得益于Spring框架，SpringMVC才能大显身手。\n9. 重定向和请求转发 重定向和请求转发也非常简单，我们只需要在视图名称前面添加一个前缀即可，比如重定向：\n1 2 3 4 5 6 7 8 9 @RequestMapping(\u0026#34;/index\u0026#34;) public String index(){ return \u0026#34;redirect:home\u0026#34;; } @RequestMapping(\u0026#34;/home\u0026#34;) public String home(){ return \u0026#34;home\u0026#34;; } 通过添加redirect:前缀，就可以很方便地实现重定向，那么请求转发呢，其实也是一样的，使用forward:前缀表示转发给其他请求映射：\n1 2 3 4 5 6 7 8 9 @RequestMapping(\u0026#34;/index\u0026#34;) public String index(){ return \u0026#34;forward:home\u0026#34;; } @RequestMapping(\u0026#34;/home\u0026#34;) public String home(){ return \u0026#34;home\u0026#34;; } 使用SpringMVC，只需要一个前缀就可以实现重定向和请求转发，非常方便。\n10. Bean的Web作用域 在学习Spring时我们讲解了Bean的作用域，包括singleton和prototype，Bean分别会以单例和多例模式进行创建，而在SpringMVC中，它的作用域被继续细分：\nrequest：对于每次HTTP请求，使用request作用域定义的Bean都将产生一个新实例，请求结束后Bean也消失。 session：对于每一个会话，使用session作用域定义的Bean都将产生一个新实例，会话过期后Bean也消失。 global session：不常用，不做讲解。 这里我们创建一个测试类来试试看：\n1 2 3 public class TestBean { } 接着将其注册为Bean，注意这里需要添加@RequestScope或是@SessionScope表示此Bean的Web作用域：\n1 2 3 4 5 @Bean @RequestScope public TestBean testBean(){ return new TestBean(); } 接着我们将其自动注入到Controller中：\n1 2 3 4 5 6 7 8 9 10 11 12 @Controller public class MainController { @Resource TestBean bean; @RequestMapping(value = \u0026#34;/index\u0026#34;) public ModelAndView index(){ System.out.println(bean); return new ModelAndView(\u0026#34;index\u0026#34;); } } 我们发现，每次发起得到的Bean实例都不同，接着我们将其作用域修改为@SessionScope，这样作用域就上升到Session，只要清理浏览器的Cookie，那么都会被认为是同一个会话，只要是同一个会话，那么Bean实例始终不变。\n实际上，它也是通过代理实现的，我们调用Bean中的方法会被转发到真正的Bean对象去执行。\n11. RestFul风格 中文释义为**“表现层状态转换”**（名字挺高大上的），它不是一种标准，而是一种设计风格。它的主要作用是充分并正确利用HTTP协议的特性，规范资源获取的URI路径。通俗的讲，RESTful风格的设计允许将参数通过URL拼接传到服务端，目的是让URL看起来更简洁实用，并且我们可以充分使用多种HTTP请求方式（POST/GET/PUT/DELETE），来执行相同请求地址的不同类型操作。\n因此，这种风格的连接，我们就可以直接从请求路径中读取参数，比如：\n1 http://localhost:8080/mvc/index/123456 我们可以直接将index的下一级路径作为请求参数进行处理，也就是说现在的请求参数包含在了请求路径中：\n1 2 3 4 5 @RequestMapping(\u0026#34;/index/{str}\u0026#34;) public String index(@PathVariable String str) { System.out.println(str); return \u0026#34;index\u0026#34;; } 注意请求路径我们可以手动添加类似占位符一样的信息，这样占位符位置的所有内容都会被作为请求参数，而方法的形参列表中必须包括一个与占位符同名的并且添加了@PathVariable注解的参数，或是由@PathVariable注解指定为占位符名称：\n1 2 3 4 5 @RequestMapping(\u0026#34;/index/{str}\u0026#34;) public String index(@PathVariable(\u0026#34;str\u0026#34;) String text){ System.out.println(text); return \u0026#34;index\u0026#34;; } 如果没有配置正确，方法名称上会出现黄线。\n我们可以按照不同功能进行划分：\nPOST http://localhost:8080/mvc/index - 添加用户信息，携带表单数据 GET http://localhost:8080/mvc/index/{id} - 获取用户信息，id直接放在请求路径中 PUT http://localhost:8080/mvc/index - 修改用户信息，携带表单数据 DELETE http://localhost:8080/mvc/index/{id} - 删除用户信息，id直接放在请求路径中 我们分别编写四个请求映射：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @Controller public class MainController { @RequestMapping(value = \u0026#34;/index/{id}\u0026#34;, method = RequestMethod.GET) public String get(@PathVariable(\u0026#34;id\u0026#34;) String text){ System.out.println(\u0026#34;获取用户：\u0026#34;+text); return \u0026#34;index\u0026#34;; } @RequestMapping(value = \u0026#34;/index\u0026#34;, method = RequestMethod.POST) public String post(String username){ System.out.println(\u0026#34;添加用户：\u0026#34;+username); return \u0026#34;index\u0026#34;; } @RequestMapping(value = \u0026#34;/index/{id}\u0026#34;, method = RequestMethod.DELETE) public String delete(@PathVariable(\u0026#34;id\u0026#34;) String text){ System.out.println(\u0026#34;删除用户：\u0026#34;+text); return \u0026#34;index\u0026#34;; } @RequestMapping(value = \u0026#34;/index\u0026#34;, method = RequestMethod.PUT) public String put(String username){ System.out.println(\u0026#34;修改用户：\u0026#34;+username); return \u0026#34;index\u0026#34;; } } 复制代码 这只是一种设计风格而已，各位小伙伴了解即可。\n12. Interceptor拦截器 拦截器是整个SpringMVC的一个重要内容，拦截器与过滤器类似，都是用于拦截一些非法请求，但是我们之前讲解的过滤器是作用于Servlet之前，只有经过层层的拦截器才可以成功到达Servlet，而拦截器并不是在Servlet之前，它在Servlet与RequestMapping之间，相当于DispatcherServlet在将请求交给对应Controller中的方法之前进行拦截处理，它只会拦截所有Controller中定义的请求映射对应的请求（不会拦截静态资源），这里一定要区分两者的不同。\n创建拦截器 创建一个拦截器我们需要实现一个HandlerInterceptor接口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class MainInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\u0026#34;我是处理之前！\u0026#34;); return true; //只有返回true才会继续，否则直接结束 } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\u0026#34;我是处理之后！\u0026#34;); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\u0026#34;我是完成之后！\u0026#34;); } } 接着我们需要在配置类中进行注册：\n1 2 3 4 5 6 @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(new MainInterceptor()) .addPathPatterns(\u0026#34;/**\u0026#34;) //添加拦截器的匹配路径，只要匹配一律拦截 .excludePathPatterns(\u0026#34;/home\u0026#34;); //拦截器不进行拦截的路径 } 现在我们在浏览器中访问index页面，拦截器已经生效。\n得到整理拦截器的执行顺序：\n1 2 3 4 我是处理之前！ 我是处理！ 我是处理之后！ 我是完成之后！ 也就是说，处理前和处理后，包含了真正的请求映射的处理，在整个流程结束后还执行了一次afterCompletion方法，其实整个过程与我们之前所认识的Filter类似，不过在处理前，我们只需要返回true或是false表示是否被拦截即可，而不是再去使用FilterChain进行向下传递。\n那么我们就来看看，如果处理前返回false，会怎么样：\n1 2 3 4 5 6 7 8 9 我是处理之前！ 通过结果发现一旦返回false，之后的所有流程全部取消，那么如果是在处理中发生异常了呢？ 复制代码 @RequestMapping(\u0026#34;/index\u0026#34;) public String index(){ System.out.println(\u0026#34;我是处理！\u0026#34;); if(true) throw new RuntimeException(\u0026#34;\u0026#34;); return \u0026#34;index\u0026#34;; } 结果为：\n1 2 3 我是处理之前！ 我是处理！ 我是完成之后！ 我们发现如果处理过程中抛出异常，那么久不会执行处理后postHandle方法，但是会执行afterCompletion方法，我们可以在此方法中获取到抛出的异常。\n多级拦截器 前面介绍了仅仅只有一个拦截器的情况，我们接着来看如果存在多个拦截器会如何执行，我们以同样的方式创建二号拦截器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class SubInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\u0026#34;二号拦截器：我是处理之前！\u0026#34;); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\u0026#34;二号拦截器：我是处理之后！\u0026#34;); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\u0026#34;二号拦截器：我是完成之后！\u0026#34;); } } 注册二号拦截器：\n1 2 3 4 5 6 7 @Override public void addInterceptors(InterceptorRegistry registry) { //一号拦截器 registry.addInterceptor(new MainInterceptor()).addPathPatterns(\u0026#34;/**\u0026#34;).excludePathPatterns(\u0026#34;/home\u0026#34;); //二号拦截器 registry.addInterceptor(new SubInterceptor()).addPathPatterns(\u0026#34;/**\u0026#34;); } 注意拦截顺序就是注册的顺序，因此拦截器会根据注册顺序依次执行，我们可以打开浏览器运行一次：\n1 2 3 4 5 6 7 一号拦截器：我是处理之前！ 二号拦截器：我是处理之前！ 我是处理！ 二号拦截器：我是处理之后！ 一号拦截器：我是处理之后！ 二号拦截器：我是完成之后！ 一号拦截器：我是完成之后！ 和多级Filter相同，在处理之前，是按照顺序从前向后进行拦截的，但是处理完成之后，就按照倒序执行处理后方法，而完成后是在所有的postHandle执行之后再同样的以倒序方式执行。\n那么如果这时一号拦截器在处理前就返回了false呢？\n1 2 3 4 5 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\u0026#34;一号拦截器：我是处理之前！\u0026#34;); return false; } 得到结果如下：\n1 一号拦截器：我是处理之前！ 我们发现，与单个拦截器的情况一样，一旦拦截器返回false，那么之后无论有无拦截器，都不再继续。\n13. 异常处理 当我们的请求映射方法中出现异常时，会直接展示在前端页面，这是因为SpringMVC为我们提供了默认的异常处理页面，当出现异常时，我们的请求会被直接转交给专门用于异常处理的控制器进行处理。\n我们可以自定义一个异常处理控制器，一旦出现指定异常，就会转接到此控制器执行：\n1 2 3 4 5 6 7 8 9 10 @ControllerAdvice public class ErrorController { @ExceptionHandler(Exception.class) public String error(Exception e, Model model){ //可以直接添加形参来获取异常 e.printStackTrace(); model.addAttribute(\u0026#34;e\u0026#34;, e); return \u0026#34;500\u0026#34;; } } 接着我们编写一个专门显示异常的页面：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; 500 - 服务器出现了一个内部错误QAQ \u0026lt;div th:text=\u0026#34;${e}\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 接着修改：\n1 2 3 4 5 6 @RequestMapping(\u0026#34;/index\u0026#34;) public String index(){ System.out.println(\u0026#34;我是处理！\u0026#34;); if(true) throw new RuntimeException(\u0026#34;您的氪金力度不足，无法访问！\u0026#34;); return \u0026#34;index\u0026#34;; } 访问后，我们发现控制台会输出异常信息，同时页面也是我们自定义的一个页面。\n14. JSON数据格式 既然要实现前后端分离，那么我们就必须约定一种更加高效的数据传输模式，来向前端页面传输后端提供的数据。因此JSON横空出世，它非常容易理解，并且与前端的兼容性极好，因此现在比较主流的数据传输方式则是通过JSON格式承载的。\n一个JSON格式的数据长这样，以学生对象为例：\n1 {\u0026#34;name\u0026#34;: \u0026#34;杰哥\u0026#34;, \u0026#34;age\u0026#34;: 18} 多个学生可以以数组的形式表示：\n1 [{\u0026#34;name\u0026#34;: \u0026#34;杰哥\u0026#34;, \u0026#34;age\u0026#34;: 18}, {\u0026#34;name\u0026#34;: \u0026#34;阿伟\u0026#34;, \u0026#34;age\u0026#34;: 18}] 嵌套关系可以表示为：\n1 {\u0026#34;studentList\u0026#34;: [{\u0026#34;name\u0026#34;: \u0026#34;杰哥\u0026#34;, \u0026#34;age\u0026#34;: 18}, {\u0026#34;name\u0026#34;: \u0026#34;阿伟\u0026#34;, \u0026#34;age\u0026#34;: 18}], \u0026#34;count\u0026#34;: 2} 它直接包括了属性的名称和属性的值，与JavaScript的对象极为相似，它到达前端后，可以直接转换为对象，以对象的形式进行操作和内容的读取，相当于以字符串形式表示了一个JS对象，我们可以直接在控制台窗口中测试：\n1 2 3 let obj = JSON.parse(\u0026#39;{\u0026#34;studentList\u0026#34;: [{\u0026#34;name\u0026#34;: \u0026#34;杰哥\u0026#34;, \u0026#34;age\u0026#34;: 18}, {\u0026#34;name\u0026#34;: \u0026#34;阿伟\u0026#34;, \u0026#34;age\u0026#34;: 18}], \u0026#34;count\u0026#34;: 2}\u0026#39;) //将JSON格式字符串转换为JS对象 obj.studentList[0].name //直接访问第一个学生的名称 我们也可以将JS对象转换为JSON字符串：\n1 JSON.stringify(obj) 我们后端就可以以JSON字符串的形式向前端返回数据，这样前端在拿到数据之后，就可以快速获取，非常方便。\n那么后端如何快速创建一个JSON格式的数据呢？我们首先需要导入以下依赖：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.78\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; JSON解析框架有很多种，比较常用的是Jackson和FastJSON，这里我们使用阿里巴巴的FastJSON进行解析。\n首先要介绍的是JSONObject，它和Map的使用方法一样（实现了Map接口），比如我们向其中存放几个数据：\n1 2 3 4 5 6 7 8 @RequestMapping(value = \u0026#34;/index\u0026#34;) public String index(){ JSONObject object = new JSONObject(); object.put(\u0026#34;name\u0026#34;, \u0026#34;杰哥\u0026#34;); object.put(\u0026#34;age\u0026#34;, 18); System.out.println(object.toJSONString()); //以JSON格式输出JSONObject字符串 return \u0026#34;index\u0026#34;; } 最后我们得到的结果为：\n1 {\u0026#34;name\u0026#34;: \u0026#34;杰哥\u0026#34;, \u0026#34;age\u0026#34;: 18} 实际上JSONObject就是对JSON数据的一种对象表示。同样的还有JSONArray，它表示一个数组，用法和List一样，数组中可以嵌套其他的JSONObject或是JSONArray：\n1 2 3 4 5 6 7 8 9 10 @RequestMapping(value = \u0026#34;/index\u0026#34;) public String index(){ JSONObject object = new JSONObject(); object.put(\u0026#34;name\u0026#34;, \u0026#34;杰哥\u0026#34;); object.put(\u0026#34;age\u0026#34;, 18); JSONArray array = new JSONArray(); array.add(object); System.out.println(array.toJSONString()); return \u0026#34;index\u0026#34;; } 得到的结果为：\n1 [{\u0026#34;name\u0026#34;: \u0026#34;杰哥\u0026#34;, \u0026#34;age\u0026#34;: 18}] 当出现循环引用时，会按照以下语法来解析：\n我们可以也直接创建一个实体类，将实体类转换为JSON格式的数据：\n1 2 3 4 5 6 7 8 @RequestMapping(value = \u0026#34;/index\u0026#34;, produces = \u0026#34;application/json\u0026#34;) @ResponseBody public String data(){ Student student = new Student(); student.setName(\u0026#34;杰哥\u0026#34;); student.setAge(18); return JSON.toJSONString(student); } 这里我们修改了produces的值，将返回的内容类型设定为application/json，表示服务器端返回了一个JSON格式的数据（当然不设置也行，也能展示，这样是为了规范）然后我们在方法上添加一个@ResponseBody表示方法返回（也可以在类上添加@RestController表示此Controller默认返回的是字符串数据）的结果不是视图名称而是直接需要返回一个字符串作为页面数据，这样，返回给浏览器的就是我们直接返回的字符串内容。\n接着我们使用JSON工具类将其转换为JSON格式的字符串，打开浏览器，得到JSON格式数据。\nSpringMVC非常智能，我们可以直接返回一个对象类型，它会被自动转换为JSON字符串格式：\n1 2 3 4 5 6 7 8 @RequestMapping(value = \u0026#34;/data\u0026#34;, produces = \u0026#34;application/json\u0026#34;) @ResponseBody public Student data(){ Student student = new Student(); student.setName(\u0026#34;杰哥\u0026#34;); student.setAge(18); return student; } 注意需要在配置类中添加一下FastJSON转换器（默认只支持JackSon）：\n1 2 3 4 @Override public void configureMessageConverters(List\u0026lt;HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; converters) { converters.add(new FastJsonHttpMessageConverter()); } ","permalink":"https://jinchaojjj.github.io/posts/%E6%A1%86%E6%9E%B6/spring-mvc/","summary":"Spring MVC 1. 什么是Spring MVC MVC（Model–View–Controller）模式是软件工程中的一种软件架构模式，它把软件系统分为三个基本部","title":"Spring MVC"},{"content":"openAPI 常用的注解 @OpenAPIDefinition：用于定义API的全局信息，如标题、描述、版本、许可证等。 @Operation：用于定义单个操作的信息，如摘要、描述、标签、响应等。 @Parameter：用于定义操作的参数，如名称、描述、类型、是否必需等。 @RequestBody：用于定义操作的请求体，如内容类型、模式等。 @ApiResponse：用于定义操作的响应，如状态码、描述、内容等。 @Schema：用于定义模型的属性，如名称、描述、类型等。 @OpenAPIDefinition 作用：配置全局信息\n使用位置：通常在入口类上进行配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @OpenAPIDefinition( info = @Info( title = \u0026#34;Custom API title\u0026#34;, version = \u0026#34;1.0.0\u0026#34;, contact = @Contact( name = \u0026#34;King\u0026#34;, email = \u0026#34;3125545791jin@gmail.com\u0026#34; ) ), tags = { @Tag(name = \u0026#34;example\u0026#34;, description = \u0026#34;An example tag\u0026#34;) }, externalDocs = @ExternalDocumentation( description = \u0026#34;Visit my website for more details\u0026#34;, url = \u0026#34;https://baidu.com\u0026#34; ), extensions = @Extension( name = \u0026#34;x-my-extension\u0026#34;, properties = { @ExtensionProperty(name = \u0026#34;key1\u0026#34;, value = \u0026#34;value1\u0026#34;), @ExtensionProperty(name = \u0026#34;key2\u0026#34;, value = \u0026#34;value2\u0026#34;) } ), servers = { @Server( url = \u0026#34;http://localhost:8080\u0026#34;, description = \u0026#34;Local server\u0026#34; ), @Server( url = \u0026#34;https://example.com/api/v1\u0026#34;, description = \u0026#34;Production server\u0026#34; ) } ) info：用于展示代码页的信息如：标题、版本号、联系邮件等\ntags：打标签，用于对不同的请求进行分类（在OpenAPIDefinition中只是罗列具有的类型，具体接口所属的类型，需要在接口方法上使用@Tag注解）\nexternalDocs：可以添加想要的链接\nextensions：提供关键字，还没用明白\nservers：可以提供全局请求的地址信息\n@Operation 作用：配置方法信息\n使用位置：使用在接口的方法上\n1 2 3 4 5 @GetMapping(\u0026#34;/hello\u0026#34;) @Operation(summary = \u0026#34;Say hello\u0026#34;, description = \u0026#34;Returns a greeting message\u0026#34;, tags = {\u0026#34;greeting\u0026#34;}) public String hello() { return \u0026#34;Hello\u0026#34;; } summary：简要介绍\ndescription：详细介绍\ntags：所属的类型\nmethod：用于指定操作的HTTP方法，如GET、POST等。这个属性在springdoc-openapi中不是必需的，因为springdoc-openapi会根据Spring Boot项目中的@RequestMapping或@GetMapping等注解来自动推断操作的HTTP方法。但是，如果您想要覆盖默认的HTTP方法，您可以使用@Operation注解中的method属性。\nrequestBody：用于定义操作的请求体，如内容类型、模式等。这个属性在springdoc-openapi中不是必需的，因为springdoc-openapi会根据Spring Boot项目中的@RequestBody注解来自动推断操作的请求体。但是，如果您想要覆盖默认的请求体，或者添加一些额外的信息，您可以使用@Operation注解中的requestBody属性。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @RestController @RequestMapping(\u0026#34;/api\u0026#34;) public class HelloController { @PostMapping(\u0026#34;/hello\u0026#34;) @Operation(summary = \u0026#34;Say hello\u0026#34;, description = \u0026#34;Returns a greeting message\u0026#34;, tags = {\u0026#34;greeting\u0026#34;}, requestBody = @io.swagger.v3.oas.annotations.parameters.RequestBody( description = \u0026#34;The name of the person to greet\u0026#34;, content = @Content( mediaType = \u0026#34;application/json\u0026#34;, schema = @Schema(implementation = String.class) ), required = true ) ) public String hello(@RequestBody String name) { return \u0026#34;Hello, \u0026#34; + name; } } @Parameter @Parameter注解有多种用途，具体取决于它所在的上下文。一般来说，@Parameter注解是用于定义方法参数的元数据，如名称、描述、类型、约束等1。例如：\n1 2 3 4 5 6 7 8 9 10 @RestController @RequestMapping(\u0026#34;/api\u0026#34;) public class HelloController { @GetMapping(\u0026#34;/hello/{name}\u0026#34;) @Operation(summary = \u0026#34;Say hello\u0026#34;, description = \u0026#34;Returns a greeting message\u0026#34;, tags = {\u0026#34;greeting\u0026#34;}) public String hello(@PathVariable @Parameter(description = \u0026#34;The name of the person to greet\u0026#34;) String name) { return \u0026#34;Hello, \u0026#34; + name; } } @RequestBody @RequestBody注解是用于将HttpRequest的body映射到一个Java对象，实现自动反序列化。这个注解通常用于接收JSON或XML格式的请求体。例如：\n1 2 3 4 5 6 7 8 @RestController @RequestMapping(\u0026#34;/api\u0026#34;) public class HelloController { @PostMapping(\u0026#34;/hello\u0026#34;) public String hello(@RequestBody User user) { return \u0026#34;Hello, \u0026#34; + user.getName(); } } 在这个例子中，@RequestBody注解是用于将请求体中的JSON数据转换为User对象。\n@Schema @Schema注解是用于定义数据模型的元数据，如名称、描述、类型、约束等。这个注解通常用于配合@RequestBody或@ApiResponse等注解来描述请求体或响应体的结构。例如：\n1 2 3 4 5 6 7 8 9 @RestController @RequestMapping(\u0026#34;/api\u0026#34;) public class HelloController { @PostMapping(\u0026#34;/hello\u0026#34;) @Operation(summary = \u0026#34;Say hello\u0026#34;, description = \u0026#34;Returns a greeting message\u0026#34;, tags = {\u0026#34;greeting\u0026#34;}) public String hello(@RequestBody @Parameter(description = \u0026#34;The user to greet\u0026#34;) @Schema(implementation = User.class) User user) { return \u0026#34;Hello, \u0026#34; + user.getName(); } } 在这个例子中，@Schema注解是用于指定请求体的实现类为User类。\n定义实体类中字段的属性 @Schema：用于定义字段的元数据，如名称、描述、类型、约束等。例如：\n1 2 3 4 5 6 7 8 9 10 public class User { @Schema(description = \u0026#34;The unique identifier of the user\u0026#34;) private Long id; @Schema(description = \u0026#34;The name of the user\u0026#34;, example = \u0026#34;John Doe\u0026#34;) private String name; @Schema(description = \u0026#34;The email of the user\u0026#34;, format = \u0026#34;email\u0026#34;, example = \u0026#34;john.doe@example.com\u0026#34;) private String email; } 在这个例子中，@Schema注解是用于定义User类中每个字段的描述、示例和格式。\n@ApiModelProperty @ApiModelProperty：用于定义字段的属性，如是否必填、是否隐藏等3。例如：\n1 2 3 4 5 6 7 public class User { @ApiModelProperty(required = true) private Long id; @ApiModelProperty(hidden = true) private String password; }在这个例子中，@ApiModelProperty注解是用于指定id字段是必填的，password字段是隐藏的3。 @JsonFormat @JsonFormat：用于定义字段的序列化和反序列化格式，如日期、时间等3。例如：\n1 2 3 4 public class User { @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = \u0026#34;yyyy-MM-dd\u0026#34;) private LocalDate birthday; }在这个例子中，@JsonFormat注解是用于指定birthday字段的格式为字符串类型的年月日3。 @ApiResponse @ApiResponse注解是用于定义操作的响应信息，如状态码、描述、内容等。这个注解通常用于配合@Operation或@ApiResponses等注解来描述操作可能返回的不同响应。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @RestController @RequestMapping(\u0026#34;/api\u0026#34;) public class HelloController { @PostMapping(\u0026#34;/hello\u0026#34;) @Operation(summary = \u0026#34;Say hello\u0026#34;, description = \u0026#34;Returns a greeting message\u0026#34;, tags = {\u0026#34;greeting\u0026#34;}, responses = { @ApiResponse(responseCode = \u0026#34;200\u0026#34;, description = \u0026#34;Successful operation\u0026#34;), @ApiResponse(responseCode = \u0026#34;400\u0026#34;, description = \u0026#34;Invalid input\u0026#34;), @ApiResponse(responseCode = \u0026#34;500\u0026#34;, description = \u0026#34;Internal server error\u0026#34;) } ) public String hello(@RequestBody User user) { return \u0026#34;Hello, \u0026#34; + user.getName(); } } 在这个例子中，@ApiResponse注解是用于定义操作可能返回的三种状态码和对应的描述。\n","permalink":"https://jinchaojjj.github.io/posts/%E6%A1%86%E6%9E%B6/openapi/","summary":"openAPI 常用的注解 @OpenAPIDefinition：用于定义API的全局信息，如标题、描述、版本、许可证等。 @Operation：用于定义单个","title":"OpenApi"},{"content":"Spring源码阅读（1） 1. ClassPathXmlApplicationContext 该类的主要作用是根据类路径下的XML文件创建ApplicationContext对象。\n该类的主要集成图如下：\n1.1 构造方法 在类内提供了不同类型的构造方法用于构造，主要的方法有两个：一个是ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, @Nullable ApplicationContext parent)，一个是ClassPathXmlApplicationContext(String[] paths, Class\u0026lt;?\u0026gt; clazz, @Nullable ApplicationContext parent)。\n第一个方法中采用configLocation进行生成，方法内容如下：\n1 2 3 4 5 6 7 public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, @Nullable ApplicationContext parent)throws BeansException { super(parent); setConfigLocations(configLocations); if (refresh) { refresh(); } } 在通常的使用场景中parent属性为null，该属性的主要作用是设置父上下文环境（设置为null时就是没有父上下文） configLocations是用于创建上下文的XML文件的路径信息 refresh表示是否刷新应用上下文 下面逐步对构造方法中的内容进行分析，通常parent为null，并且super(parent)在null时进行初始化时并没有过多的设置操作，因此不过多深入。\nsetConfigLocations setConfigLocations方法在父类AbstractRefreshableConfigApplicationContext中实现，该方法中主要做的是判断configLocations中是否为空，在不为空时对路径信息处理后记录在变量configLocations中。处理逻辑为：this.configLocations[i] = resolvePath(locations[i]).trim();。\n其中resolvePath方法就是对路径信息进行解析，若路径中存在占位符则需要对占位符进行解析，并去除得到解析后的路径，将处理完成的路径路径信息存放在configLocations中。trim方法是删除字符串两端多余的空格。在处理完成路径信息（路径信息可以是一个数组，也就是存在多个配置文件）后，在刷新配置的情况下会调用refresh方法。\n其中关于Environment的信息可以查看这篇文章。 在resolvePath方法中首先会获取ConfigurableEnvironment对象，若该对象为空会进行初始化。初始化是创建的是ConfigurableEnvironment接口的实现类StandardEnvironment的对象。 ConfigurableEnvironment接口基础自Environment以及ConfigurablePropertyResolver，其中PropertyResolver接口的作用请看文章 refresh ","permalink":"https://jinchaojjj.github.io/posts/%E6%A1%86%E6%9E%B6/spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB1/","summary":"Spring源码阅读（1） 1. ClassPathXmlApplicationContext 该类的主要作用是根据类路径下的XML文件创建ApplicationContext对象。 该类的主要集成图如下： 1.1","title":"Spring源码1"},{"content":"Spring源码阅读（2） 本章主要讲解在Spring中非常重要的底层接口、实现类\n1. PropertySource PropertySource是一个抽象类，实现了其中的基本方法，该类是对键值对的一次封装实现，相较于Java提供的简直对提供了自己使用的更多方法。提供了如下方法：\n方法名 作用 getName () 获得PropertySource中的键 getSource () 获得PropertySource中的值 getProperty (String name) 根据键获得PropertySource中的值 containsProperty (String name) 根据name判断该PropertySource是否存在值 2. PropertySources 包含一个或多个PropertySource对象的持有者，是一个接口并且继承了Iterable\u0026lt;PropertySource\u0026lt;?\u0026gt;\u0026gt;可以使用foreach。\n接口中还定义了contains(String name)方法，用于判断持有的多个PropertySource中是否存在键为name的对象。\n3. PropertyResolver resolve指的是解析器，顾名思义指的是用于对Property进行解析的对象。在该接口中提供了四类方法：\n方法 作用 getProperty 返回与给定键关联的属性值，有多种实现的重载 getRequiredProperty 作用同上，但是不能为空 resolvePlaceholders 对形如${}占位符进行解析，无法解析则不做处理 resolveRequiredPlaceholders 作用同上，但会对每一个占位符处理，无法处理时抛出异常 4. Environment 该接口继承自3:PropertyResolver，定义了三个新方法：\n方法 作用 getActiveProfiles 返回在此环境中被明确激活的配置文件的集合。配置文件用于创建有条件注册的bean定义的逻辑分组，例如基于部署环境 getDefaultProfiles 当没有明确设置激活的配置文件时，返回默认激活的配置文件集。 acceptsProfiles 返回一个或多个给定的配置文件是否处于活动状态，或者在没有明确的活动配置文件的情况下，返回一个或多个给定的配置文件是否包含在默认配置文件的集合中。如果一个配置文件以\u0026rsquo;！\u0026lsquo;开头，则逻辑相反，也就是说，如果给定的配置文件没有活动，该方法将返回真 5. ConfigurablePropertyResolver 该接口同样继承自3:PropertyResolver，Configurable指的是可配置的，是大多数（如果不是所有）PropertyResolver类型实现的配置接口。为访问和定制将属性值从一种类型转换为另一种类型时使用的转换服务提供便利。\nConversionService接口中提供的方法主要用于判断一个类是否转化为另一个类，以及将一种类型转化为另一种类型。\nConverterRegistry接口中提供了添加转化器和删除转化器的方法。\nConfigurableConversionService接口继承自上面两个接口，用于提供一个可以动态配置的转化器\n本接口中提供了设置ConfigurableConversionService转化器的方法，同时提供了配置前后缀、间隔字符、必要属性、嵌套解析的忽略设置等。\n6. ConfigurableEnvironment 提供了设置活动和默认配置文件以及操作底层属性源的方法，继承自4、5。允许客户通过ConfigurablePropertyResolver超接口来设置和验证所需的属性，定制转换服务等。\n属性源可以被删除、重新排序或替换；还可以使用从getPropertySources()返回的MutablePropertySources实例添加额外的属性源。\n7. StandardEnvironment 是6:ConfigurableEnvironment的一种实现类，\n","permalink":"https://jinchaojjj.github.io/posts/%E6%A1%86%E6%9E%B6/spring%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB2/","summary":"Spring源码阅读（2） 本章主要讲解在Spring中非常重要的底层接口、实现类 1. PropertySource PropertySource是一个抽象类，实现了其中的基","title":"Spring源码2"},{"content":"数据库 1. 基本知识 数据库, 数据库管理系统, 数据库系统, 数据库管理员 数据库 : 数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。 数据库管理系统 : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。 数据库系统 : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。 数据库管理员 : 数据库管理员(Database Administrator, 简称 DBA)负责全面管理和控制数据库系统。 元组, 码, 候选码, 主码, 外码, 主属性, 非主属性 元组 ： 元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。 码 ：码就是能唯一标识实体的属性，对应表中的列（也叫键）。 候选码 ： 若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。 主码 : 主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。 外码 : 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。 主属性 ： 候选码中出现过的属性称为主属性。比如关系 工人（工号，身份证号，姓名，性别，部门）. 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。 非主属性： 不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。 数据库范式了解吗? 数据库范式有 3 种：\n1NF(第一范式)：属性不可再分。 2NF(第二范式)：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。 3NF(第三范式)：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。 1NF(第一范式) 属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。1NF 是所有关系型数据库的最基本要求 ，也就是说关系型数据库中创建的表一定满足第一范式。\n2NF(第二范式) 2NF 在 1NF 的基础之上，消除了非主属性对于码的部分函数依赖。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。\n一些重要的概念：\n函数依赖（functional dependency） ：若在一张表中，在属性（或属性组）X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。 部分函数依赖（partial functional dependency） ：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。比如学生基本信息表 R 中（学号，身份证号，姓名）当然学号属性取值是唯一的，在 R 关系中，（学号，身份证号）-\u0026gt;（姓名），（学号）-\u0026gt;（姓名），（身份证号）-\u0026gt;（姓名）；所以姓名部分函数依赖与（学号，身份证号）； 完全函数依赖(Full functional dependency) ：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。比如学生基本信息表 R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，（学号，班级）-\u0026gt;（姓名），但是（学号）-\u0026gt;(姓名)不成立，（班级）-\u0026gt;(姓名)不成立，所以姓名完全函数依赖与（学号，班级）； 传递函数依赖 ： 在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，（X∪Y）∩Z=空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。。 3NF(第三范式) 3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。符合 3NF 要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求。\nBCNF： 满足BC范式的关系将消除任何属性（主属性和非主属性）对码的部分函数依赖和传递函数依赖，在3NF的基础上消除了主属性对码的部分函数依赖和传递函数依赖。\n在第三范式下，举个例子：如果不存在AB–\u0026gt;C , B–\u0026gt;C 类似这样的情况，也就是说部分函数依赖。也不存在 A–\u0026gt;B , B–\u0026gt;C 这种情况，也就是传递函数依赖，不管这些ABC属性是主属性还是非主属性，反正就是不存在 “部分函数依赖和传递函数依赖” ，这就是BC范式\n4NF(第四范式) 第四范式的定义很简单：已经是BC范式，并且不包含多值依赖关系。\n多值依赖定义：设R(U)是属性集U上的一个关系模式。X,Y,Z是U的子集，并且Z=U-X-Y。关系模式R(U)中多值依赖X→→Y成立，当且仅当对R(U)的任一关系r，给定的一对(x,z)值，有一组Y的值，这组值仅仅决定于x值而与z值无关。 就是指的是一个集合分为三部分A、B、C，其中A可以决定一组B，决定这件事与C无关，则称为A-\u0026gt;-\u0026gt;B。\nER 图 我们做一个项目的时候一定要试着画 ER 图来捋清数据库设计，这个也是面试官问你项目的时候经常会被问到的。\nER 图 全称是 Entity Relationship Diagram（实体联系图），提供了表示实体类型、属性和联系的方法。\nER 图由下面 3 个要素组成：\n实体 ：通常是现实世界的业务对象，当然使用一些逻辑对象也可以。比如对于一个校园管理系统，会涉及学生、教师、课程、班级等等实体。在 ER 图中，实体使用矩形框表示。 属性 ：即某个实体拥有的属性，属性用来描述组成实体的要素，对于产品设计来说可以理解为字段。在 ER 图中，属性使用椭圆形表示。 联系 ：即实体与实体之间的关系，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。例如，一个班级会有多个学生就是一种实体间的联系。 下图是一个学生选课的 ER 图，每个学生可以选若干门课程，同一门课程也可以被若干人选择，所以它们之间的关系是多对多（M: N）。另外，还有其他两种实体之间的关系是：1 对 1（1:1）、1 对多（1: N）。\n在绘制ER图的时候需要注意确定实体之间的关系，然后关系的类型是一对一、一对多、多对多中的哪一种。并且需要确定实体的属性以及关系是否具有属性。\n主键和外键的区别 主键(主码) ：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。 外键(外码) ：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。 为什么不推荐使用外键与级联？ 对于外键和级联，阿里巴巴开发手册这样说到：\n【强制】不得使用外键与级联，一切外键概念必须在应用层解决。\n说明: 以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群; 级联更新是强阻塞，存在数据库更新风暴的风险; 外键影响数据库的插入速度\n为什么不要用外键呢？大部分人可能会这样回答：\n增加了复杂性： a. 每次做 DELETE 或者 UPDATE 都必须考虑外键约束，会导致开发的时候很痛苦, 测试数据极为不方便; b. 外键的主从关系是定的，假如那天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦。 增加了额外工作： 数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；（个人觉得这个不是不用外键的原因，因为即使你不使用外键，你在应用层面也还是要保证的。所以，我觉得这个影响可以忽略不计。） 对分库分表不友好 ：因为分库分表下外键是无法生效的。 我个人觉得上面这种回答不是特别的全面，只是说了外键存在的一个常见的问题。实际上，我们知道外键也是有很多好处的，比如：\n保证了数据库数据的一致性和完整性； 级联操作方便，减轻了程序代码量； 所以说，不要一股脑的就抛弃了外键这个概念，既然它存在就有它存在的道理，如果系统不涉及分库分表，并发量不是很高的情况还是可以考虑使用外键的。\n什么是存储过程? 我们可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程在业务比较复杂的时候是非常实用的，比如很多时候我们完成一个操作可能需要写一大串 SQL 语句，这时候我们就可以写有一个存储过程，这样也方便了我们下一次的调用。存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。\n存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。\n阿里巴巴 Java 开发手册里要求禁止使用存储过程。\ndrop、delete 与 truncate 区别？ 用法不同 drop(丢弃数据): drop table 表名 ，直接将表都删除掉，在删除表的时候使用。 truncate (清空数据) : truncate table 表名 ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。 delete（删除数据） : delete from 表名 where 列名=值，删除某一行的数据，如果不加 where 子句和truncate table 表名作用类似。 truncate 和不带 where``子句的 delete、以及 drop 都会删除表内的数据，但是 truncate 和 delete 只删除数据不删除表的结构(定义)，执行 drop 语句，此表的结构也会删除，也就是执行 drop 之后对应的表不复存在。\n属于不同的数据库语言 truncate 和 drop 属于 DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。而 delete 语句是 DML (数据库操作语言)语句，这个操作会放到 rollback segement 中，事务提交之后才生效。\nDML 语句和 DDL 语句区别：\nDML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入、更新、删除和查询，是开发人员日常使用最频繁的操作。 DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。 另外，由于select不会对表进行破坏，所以有的地方也会把select单独区分开叫做数据库查询语言 DQL（Data Query Language）。\n执行速度不同 一般来说：drop \u0026gt; truncate \u0026gt; delete（这个我没有设计测试过）。\ndelete命令执行的时候会产生数据库的binlog日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。 truncate命令执行的时候不会产生数据库日志，因此比delete要快。除此之外，还会把表的自增值重置和索引恢复到初始大小等。 drop命令会把表占用的空间全部释放掉。 Tips：你应该更多地关注在使用场景上，而不是执行效率。\n数据库设计通常分为哪几步? 需求分析 : 分析用户的需求，包括数据、功能和性能需求。 概念结构设计 : 主要采用 E-R 模型进行设计，包括画 E-R 图。 逻辑结构设计 : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。 物理结构设计 : 主要是为所设计的数据库选择合适的存储结构和存取路径。 数据库实施 : 包括编程、测试和试运行 数据库的运行和维护 : 系统的运行与数据库的日常维护。 2. SQL语法 数据库术语 数据库（database） - 保存有组织的数据的容器（通常是一个文件或一组文件）。 数据表（table） - 某种特定类型数据的结构化清单。 模式（schema） - 关于数据库和表的布局及特性的信息。模式定义了数据在表中如何存储，包含存储什么样的数据，数据如何分解，各部分信息如何命名等信息。数据库和表都有模式。 列（column） - 表中的一个字段。所有表都是由一个或多个列组成的。 行（row） - 表中的一个记录。 主键（primary key） - 一列（或一组列），其值能够唯一标识表中每一行。 SQL 语法 SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。\nSQL语法结构 SQL 语法结构包括：\n子句 - 是语句和查询的组成成分。（在某些情况下，这些都是可选的。） 表达式 - 可以产生任何标量值，或由列和行的数据库表 谓词 - 给需要评估的 SQL 三值逻辑（3VL）（true/false/unknown）或布尔真值指定条件，并限制语句和查询的效果，或改变程序流程。 查询 - 基于特定条件检索数据。这是 SQL 的一个重要组成部分。 语句 - 可以持久地影响纲要和数据，也可以控制数据库事务、程序流程、连接、会话或诊断。 SQL 语法要点 SQL 语句不区分大小写，但是数据库表名、列名和值是否区分，依赖于具体的 DBMS 以及配置。例如：SELECT 与 select 、Select 是相同的。 多条 SQL 语句必须以分号（;）分隔。 处理 SQL 语句时，所有空格都被忽略。 SQL 语句可以写成一行，也可以分写为多行。 SQL 分类 数据定义语言（DDL） 数据定义语言（Data Definition Language，DDL）是 SQL 语言集中负责数据结构定义与数据库对象定义的语言。\nDDL 的主要功能是定义数据库对象。\nDDL 的核心指令是 CREATE、ALTER、DROP。\n数据操纵语言（DML） 数据操纵语言（Data Manipulation Language, DML）是用于数据库操作，对数据库其中的对象和数据运行访问工作的编程语句。\nDML 的主要功能是 访问数据，因此其语法都是以读写数据库为主。\nDML 的核心指令是 INSERT、UPDATE、DELETE、SELECT。这四个指令合称 CRUD(Create, Read, Update, Delete)，即增删改查。\n事务控制语言（TCL） 事务控制语言 (Transaction Control Language, TCL) 用于管理数据库中的事务。这些用于管理由 DML 语句所做的更改。它还允许将语句分组为逻辑事务。\nTCL 的核心指令是 COMMIT、ROLLBACK。\n数据控制语言（DCL） 数据控制语言 (Data Control Language, DCL) 是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。\nDCL 的核心指令是 GRANT、REVOKE。\nDCL 以控制用户的访问权限为主，因此其指令作法并不复杂，可利用 DCL 控制的权限有：CONNECT、SELECT、INSERT、UPDATE、DELETE、EXECUTE、USAGE、REFERENCES。\n根据不同的 DBMS 以及不同的安全性实体，其支持的权限控制也有所不同。\na）增删改查（DML） 增删改查，又称为 CRUD，数据库基本操作中的基本操作。\n插入数据 INSERT INTO 语句用于向表中插入新记录。\n插入完整的行\n1 2 3 4 5 6 # 插入一行 INSERT INTO user VALUES (10, \u0026#39;root\u0026#39;, \u0026#39;root\u0026#39;, \u0026#39;xxxx@163.com\u0026#39;); # 插入多行 INSERT INTO user VALUES (10, \u0026#39;root\u0026#39;, \u0026#39;root\u0026#39;, \u0026#39;xxxx@163.com\u0026#39;), (12, \u0026#39;user1\u0026#39;, \u0026#39;user1\u0026#39;, \u0026#39;xxxx@163.com\u0026#39;), (18, \u0026#39;user2\u0026#39;, \u0026#39;user2\u0026#39;, \u0026#39;xxxx@163.com\u0026#39;); 插入行的一部分\n1 2 INSERT INTO user(username, password, email) VALUES (\u0026#39;admin\u0026#39;, \u0026#39;admin\u0026#39;, \u0026#39;xxxx@163.com\u0026#39;); 插入查询出来的数据\n1 2 3 INSERT INTO user(username) SELECT name FROM account; 更新数据 UPDATE 语句用于更新表中的记录。\n1 2 3 UPDATE user SET username=\u0026#39;robot\u0026#39;, password=\u0026#39;robot\u0026#39; WHERE username = \u0026#39;root\u0026#39;; 删除数据 DELETE 语句用于删除表中的记录。 TRUNCATE TABLE 可以清空表，也就是删除所有行。 删除表中的指定数据\n1 2 DELETE FROM user WHERE username = \u0026#39;robot\u0026#39;; 清空表中的数据\n1 TRUNCATE TABLE user; 查询数据 SELECT 语句用于从数据库中查询数据。\nDISTINCT 用于返回唯一不同的值。它作用于所有列，也就是说所有列的值都相同才算相同。\nLIMIT 限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。\nASC ：升序（默认） DESC ：降序 查询单列\n1 2 SELECT prod_name FROM products; 查询多列\n1 2 SELECT prod_id, prod_name, prod_price FROM products; 查询所有列\n1 2 SELECT * FROM products; 查询不同的值\n1 2 SELECT DISTINCT vend_id FROM products; 限制查询结果\n1 2 3 4 5 -- 返回前 5 行 SELECT * FROM mytable LIMIT 5; SELECT * FROM mytable LIMIT 0, 5; -- 返回第 3 ~ 5 行 SELECT * FROM mytable LIMIT 2, 3; 排序 order by 用于对结果集按照一个列或者多个列进行排序。默认按照升序对记录进行排序，如果需要按照降序对记录进行排序，可以使用 desc 关键字。\norder by 对多列排序的时候，先排序的列放前面，后排序的列放后面。并且，不同的列可以有不同的排序规则。\n1 2 SELECT * FROM products ORDER BY prod_price DESC, prod_name ASC; 分组 group by ：\ngroup by 子句将记录分组到汇总行中。 group by 为每个组返回一个记录。 group by 通常还涉及聚合count，max，sum，avg 等。 group by 可以按一列或多列进行分组。 group by 按分组字段进行排序后，order by 可以以汇总字段来进行排序。 分组\n1 2 SELECT cust_name, COUNT(cust_address) AS addr_num FROM Customers GROUP BY cust_name; 分组后排序\n1 2 3 SELECT cust_name, COUNT(cust_address) AS addr_num FROM Customers GROUP BY cust_name ORDER BY cust_name DESC; having：\nhaving 用于对汇总的 group by 结果进行过滤。 having 必须要与 group by 连用。 where 和 having 可以在相同的查询中。 使用 WHERE 和 HAVING 过滤数据\n1 2 3 4 5 SELECT cust_name, COUNT(*) AS num FROM Customers WHERE cust_email IS NOT NULL GROUP BY cust_name HAVING COUNT(*) \u0026gt;= 1; having vs where ：\nwhere：过滤过滤指定的行，后面不能加聚合函数（分组函数）。 having：过滤分组，必须要与 group by 连用，不能单独使用。 子查询 子查询是嵌套在较大查询中的 SQL 查询，也称内部查询或内部选择，包含子查询的语句也称为外部查询或外部选择。简单来说，子查询就是指将一个 select 查询（子查询）的结果作为另一个 SQL 语句（主查询）的数据来源或者判断条件。\n子查询可以嵌入 SELECT、INSERT、UPDATE 和 DELETE 语句中，也可以和 =、\u0026lt;、\u0026gt;、IN、BETWEEN、EXISTS 等运算符一起使用。\n子查询常用在 WHERE 子句和 FROM 子句后边：\n当用于 WHERE 子句时，根据不同的运算符，子查询可以返回单行单列、多行单列、单行多列数据。子查询就是要返回能够作为 WHERE 子句查询条件的值。 当用于 FROM 子句时，一般返回多行多列数据，相当于返回一张临时表，这样才符合 FROM 后面是表的规则。这种做法能够实现多表联合查询。 注意：MYSQL 数据库从 4.1 版本才开始支持子查询，早期版本是不支持的。\n用于 WHERE 子句的子查询的基本语法如下：\n1 2 3 4 5 6 select column_name [, column_name ] from table1 [, table2 ] where column_name operator (select column_name [, column_name ] from table1 [, table2 ] [where]) 子查询需要放在括号( )内。 operator 表示用于 where 子句的运算符。 用于 FROM 子句的子查询的基本语法如下：\n1 2 3 4 5 select column_name [, column_name ] from (select column_name [, column_name ] from table1 [, table2 ] [where]) as temp_table_name where condition 用于 FROM 的子查询返回的结果相当于一张临时表，所以需要使用 AS 关键字为该临时表起一个名字。\n子查询的子查询\n1 2 3 4 5 6 7 SELECT cust_name, cust_contact FROM customers WHERE cust_id IN (SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = \u0026#39;RGAN01\u0026#39;)); 内部查询首先在其父查询之前执行，以便可以将内部查询的结果传递给外部查询。\nWHERE WHERE 子句用于过滤记录，即缩小访问数据的范围。 WHERE 后跟一个返回 true 或 false 的条件。 WHERE 可以与 SELECT，UPDATE 和 DELETE 一起使用。 可以在 WHERE 子句中使用的操作符。 运算符 描述 = 等于 \u0026lt;\u0026gt; 不等于。注释：在 SQL 的一些版本中，该操作符可被写成 != \u0026gt; 大于 \u0026lt; 小于 \u0026gt;= 大于等于 \u0026lt;= 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 IN 指定针对某个列的多个可能值 SELECT 语句中的 WHERE 子句\n1 2 SELECT * FROM Customers WHERE cust_name = \u0026#39;Kids Place\u0026#39;; UPDATE 语句中的 WHERE 子句\n1 2 3 UPDATE Customers SET cust_name = \u0026#39;Jack Jones\u0026#39; WHERE cust_name = \u0026#39;Kids Place\u0026#39;; DELETE 语句中的 WHERE 子句\n1 2 DELETE FROM Customers WHERE cust_name = \u0026#39;Kids Place\u0026#39;; IN 和 BETWEEN IN 操作符在 WHERE 子句中使用，作用是在指定的几个特定值中任选一个值。 BETWEEN 操作符在 WHERE 子句中使用，作用是选取介于某个范围内的值。 IN 示例\n1 2 3 SELECT * FROM products WHERE vend_id IN (\u0026#39;DLL01\u0026#39;, \u0026#39;BRS01\u0026#39;); BETWEEN 示例\n1 2 3 SELECT * FROM products WHERE prod_price BETWEEN 3 AND 5; AND、OR、NOT AND、OR、NOT 是用于对过滤条件的逻辑处理指令。 AND 优先级高于 OR，为了明确处理顺序，可以使用 ()。 AND 操作符表示左右条件都要满足。 OR 操作符表示左右条件满足任意一个即可。 NOT 操作符用于否定一个条件。 AND 示例\n1 2 3 SELECT prod_id, prod_name, prod_price FROM products WHERE vend_id = \u0026#39;DLL01\u0026#39; AND prod_price \u0026lt;= 4; OR 示例\n1 2 3 SELECT prod_id, prod_name, prod_price FROM products WHERE vend_id = \u0026#39;DLL01\u0026#39; OR vend_id = \u0026#39;BRS01\u0026#39;; NOT 示例\n1 2 3 SELECT * FROM products WHERE prod_price NOT BETWEEN 3 AND 5; LIKE LIKE 操作符在 WHERE 子句中使用，作用是确定字符串是否匹配模式。 只有字段是文本值时才使用 LIKE。 LIKE 支持两个通配符匹配选项：% 和 _。 不要滥用通配符，通配符位于开头处匹配会非常慢。 % 表示任何字符出现任意次数。 _ 表示任何字符出现一次。 % 示例\n1 2 3 SELECT prod_id, prod_name, prod_price FROM products WHERE prod_name LIKE \u0026#39;%bean bag%\u0026#39;; _ 示例\n1 2 3 SELECT prod_id, prod_name, prod_price FROM products WHERE prod_name LIKE \u0026#39;__ inch teddy bear\u0026#39;; 连接 JOIN 是“连接”的意思，顾名思义，SQL JOIN 子句用于将两个或者多个表联合起来进行查询。\n连接表时需要在每个表中选择一个字段，并对这些字段的值进行比较，值相同的两条记录将合并为一条。连接表的本质就是将不同表的记录合并起来，形成一张新表。当然，这张新表只是临时的，它仅存在于本次查询期间。\n使用 JOIN 连接两个表的基本语法如下：\n1 2 3 4 select table1.column1, table2.column2... from table1 join table2 on table1.common_column1 = table2.common_column2; table1.common_column1 = table2.common_column2 是连接条件，只有满足此条件的记录才会合并为一行。您可以使用多个运算符来连接表，例如 =、\u0026gt;、\u0026lt;、\u0026lt;\u0026gt;、\u0026lt;=、\u0026gt;=、!=、between、like 或者 not，但是最常见的是使用 =。\n当两个表中有同名的字段时，为了帮助数据库引擎区分是哪个表的字段，在书写同名字段名时需要加上表名。当然，如果书写的字段名在两个表中是唯一的，也可以不使用以上格式，只写字段名即可。\n另外，如果两张表的关联字段名相同，也可以使用 USING子句来代替 ON，举个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 # join....on select c.cust_name, o.order_num from Customers c inner join Orders o on c.cust_id = o.cust_id order by c.cust_name; # 如果两张表的关联字段名相同，也可以使用USING子句：join....using() select c.cust_name, o.order_num from Customers c inner join Orders o using(cust_id) order by c.cust_name; ON 和 WHERE 的区别：\n连接表时，SQL 会根据连接条件生成一张新的临时表。ON 就是连接条件，它决定临时表的生成。 WHERE 是在临时表生成以后，再对临时表中的数据进行过滤，生成最终的结果集，这个时候已经没有 JOIN-ON 了。 所以总结来说就是：SQL 先根据 ON 生成一张临时表，然后再根据 WHERE 对临时表进行筛选。\nSQL 允许在 JOIN 左边加上一些修饰性的关键词，从而形成不同类型的连接，如下表所示：\n连接类型 说明 INNER JOIN 内连接 （默认连接方式）只有当两个表都存在满足条件的记录时才会返回行。 LEFT JOIN / LEFT OUTER JOIN 左(外)连接 返回左表中的所有行，即使右表中没有满足条件的行也是如此。 RIGHT JOIN / RIGHT OUTER JOIN 右(外)连接 返回右表中的所有行，即使左表中没有满足条件的行也是如此。 FULL JOIN / FULL OUTER JOIN 全(外)连接 只要其中有一个表存在满足条件的记录，就返回行。 SELF JOIN 将一个表连接到自身，就像该表是两个表一样。为了区分两个表，在 SQL 语句中需要至少重命名一个表。 CROSS JOIN 交叉连接，从两个或者多个连接表中返回记录集的笛卡尔积。 下图展示了 LEFT JOIN、RIGHT JOIN、INNER JOIN、OUTER JOIN 相关的 7 种用法。\n如果不加任何修饰词，只写 JOIN，那么默认为 INNER JOIIN\n对于 INNER JOIIN 来说，还有一种隐式的写法，称为 “隐式内连接”，也就是没有 INNER JOIIN 关键字，使用 WHERE 语句实现内连接的功能\n1 2 3 4 5 6 7 8 9 10 11 # 隐式内连接 select c.cust_name, o.order_num from Customers c, Orders o where c.cust_id = o.cust_id order by c.cust_name; # 显式内连接 select c.cust_name, o.order_num from Customers c inner join Orders o using(cust_id) order by c.cust_name; 组合 UNION 运算符将两个或更多查询的结果组合起来，并生成一个结果集，其中包含来自 UNION 中参与查询的提取行。\nUNION 基本规则：\n所有查询的列数和列顺序必须相同。 每个查询中涉及表的列的数据类型必须相同或兼容。 通常返回的列名取自第一个查询。 默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。\n1 2 3 SELECT column_name(s) FROM table1 UNION ALL SELECT column_name(s) FROM table2; UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。\nJOIN vs UNION：\nJOIN 中连接表的列可能不同，但在 UNION 中，所有查询的列数和列顺序必须相同。 UNION 将查询之后的行放在一起（垂直放置），但 JOIN 将查询之后的列放在一起（水平放置），即它构成一个笛卡尔积。 函数 不同数据库的函数往往各不相同，因此不可移植。本节主要以 MysSQL 的函数为例。\n文本处理 函数 说明 LEFT()、RIGHT() 左边或者右边的字符 LOWER()、UPPER() 转换为小写或者大写 LTRIM()、RTIM() 去除左边或者右边的空格 LENGTH() 长度 SOUNDEX() 转换为语音值 其中， SOUNDEX() 可以将一个字符串转换为描述其语音表示的字母数字模式。\n1 2 3 SELECT * FROM mytable WHERE SOUNDEX(col1) = SOUNDEX(\u0026#39;apple\u0026#39;) 日期和时间处理 日期格式：YYYY-MM-DD 时间格式：HH:MM:SS 函 数 说 明 AddDate() 增加一个日期（天、周等） AddTime() 增加一个时间（时、分等） CurDate() 返回当前日期 CurTime() 返回当前时间 Date() 返回日期时间的日期部分 DateDiff() 计算两个日期之差 Date_Add() 高度灵活的日期运算函数 Date_Format() 返回一个格式化的日期或时间串 Day() 返回一个日期的天数部分 DayOfWeek() 对于一个日期，返回对应的星期几 Hour() 返回一个时间的小时部分 Minute() 返回一个时间的分钟部分 Month() 返回一个日期的月份部分 Now() 返回当前日期和时间 Second() 返回一个时间的秒部分 Time() 返回一个日期时间的时间部分 Year() 返回一个日期的年份部分 数值处理 函数 说明 SIN() 正弦 COS() 余弦 TAN() 正切 ABS() 绝对值 SQRT() 平方根 MOD() 余数 EXP() 指数 PI() 圆周率 RAND() 随机数 汇总 函 数 说 明 AVG() 返回某列的平均值 COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 AVG() 会忽略 NULL 行。\n使用 DISTINCT 可以让汇总函数值汇总不同的值。\n1 2 SELECT AVG(DISTINCT col1) AS avg_col FROM mytable 接下来，我们来介绍 DDL 语句用法。DDL 的主要功能是定义数据库对象（如：数据库、数据表、视图、索引等）\nb）数据定义(DDL) 数据库（DATABASE） 创建数据库 1 CREATE DATABASE test; 删除数据库 1 DROP DATABASE test; 选择数据库 1 USE test; 数据表（TABLE） 创建数据表 普通创建\n1 2 3 4 5 6 CREATE TABLE user ( id int(10) unsigned NOT NULL COMMENT \u0026#39;Id\u0026#39;, username varchar(64) NOT NULL DEFAULT \u0026#39;default\u0026#39; COMMENT \u0026#39;用户名\u0026#39;, password varchar(64) NOT NULL DEFAULT \u0026#39;default\u0026#39; COMMENT \u0026#39;密码\u0026#39;, email varchar(64) NOT NULL DEFAULT \u0026#39;default\u0026#39; COMMENT \u0026#39;邮箱\u0026#39; ) COMMENT=\u0026#39;用户表\u0026#39;; 根据已有的表创建新表\n1 2 CREATE TABLE vip_user AS SELECT * FROM user; 删除数据表 1 DROP TABLE user; 修改数据表 添加列\n1 2 ALTER TABLE user ADD age int(3); 删除列\n1 2 ALTER TABLE user DROP COLUMN age; 修改列\n1 2 ALTER TABLE `user` MODIFY COLUMN age tinyint; 添加主键\n1 2 ALTER TABLE user ADD PRIMARY KEY (id); 删除主键\n1 2 ALTER TABLE user DROP PRIMARY KEY; 视图（VIEW） 定义：\n视图是基于 SQL 语句的结果集的可视化的表。 视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。对视图的操作和对普通表的操作一样。 作用：\n简化复杂的 SQL 操作，比如复杂的联结； 只使用实际表的一部分数据； 通过只给用户访问视图的权限，保证数据的安全性； 更改数据格式和表示。 创建视图 1 2 3 4 CREATE VIEW top_10_user_view AS SELECT id, username FROM user WHERE id \u0026lt; 10; 删除视图 1 DROP VIEW top_10_user_view; 索引（INDEX） 索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。\n索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。\n优点 ：\n使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 缺点 ：\n创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。 索引需要使用物理文件存储，也会耗费一定空间。 但是，使用索引一定能提高查询性能吗?\n大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。\n创建索引 1 2 CREATE INDEX user_index ON user (id); 添加索引 1 ALTER table user ADD INDEX user_index(id) 创建唯一索引 1 2 CREATE UNIQUE INDEX user_index ON user (id); 删除索引 1 2 ALTER TABLE user DROP INDEX user_index; 约束 SQL 约束用于规定表中的数据规则。\n如果存在违反约束的数据行为，行为会被约束终止。\n约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。\n约束类型：\nNOT NULL - 指示某列不能存储 NULL 值。 UNIQUE - 保证某列的每行必须有唯一的值。 PRIMARY KEY - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。 FOREIGN KEY - 保证一个表中的数据匹配另一个表中的值的参照完整性。 CHECK - 保证列中的值符合指定的条件。 DEFAULT - 规定没有给列赋值时的默认值。 创建表时使用约束条件：\n1 2 3 4 5 6 7 8 CREATE TABLE Users ( Id INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT \u0026#39;自增Id\u0026#39;, Username VARCHAR(64) NOT NULL UNIQUE DEFAULT \u0026#39;default\u0026#39; COMMENT \u0026#39;用户名\u0026#39;, Password VARCHAR(64) NOT NULL DEFAULT \u0026#39;default\u0026#39; COMMENT \u0026#39;密码\u0026#39;, Email VARCHAR(64) NOT NULL DEFAULT \u0026#39;default\u0026#39; COMMENT \u0026#39;邮箱地址\u0026#39;, Enabled TINYINT(4) DEFAULT NULL COMMENT \u0026#39;是否有效\u0026#39;, PRIMARY KEY (Id) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT=\u0026#39;用户表\u0026#39;; 接下来，我们来介绍 TCL 语句用法。TCL 的主要功能是管理数据库中的事务。\nc）事务处理（TCL） 不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。\nMySQL 默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。\n通过 set autocommit=0 可以取消自动提交，直到 set autocommit=1 才会提交；autocommit 标记是针对每个连接而不是针对服务器的。\n指令：\nSTART TRANSACTION - 指令用于标记事务的起始点。 SAVEPOINT - 指令用于创建保留点。 ROLLBACK TO - 指令用于回滚到指定的保留点；如果没有设置保留点，则回退到 START TRANSACTION 语句处。 COMMIT - 提交事务。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 -- 开始事务 START TRANSACTION; -- 插入操作 A INSERT INTO `user` VALUES (1, \u0026#39;root1\u0026#39;, \u0026#39;root1\u0026#39;, \u0026#39;xxxx@163.com\u0026#39;); -- 创建保留点 updateA SAVEPOINT updateA; -- 插入操作 B INSERT INTO `user` VALUES (2, \u0026#39;root2\u0026#39;, \u0026#39;root2\u0026#39;, \u0026#39;xxxx@163.com\u0026#39;); -- 回滚到保留点 updateA ROLLBACK TO updateA; -- 提交事务，只有操作 A 生效 COMMIT; 接下来，我们来介绍 DCL 语句用法。DCL 的主要功能是控制用户的访问权限。\nd）权限控制（DCL） 要授予用户帐户权限，可以用GRANT命令。有撤销用户的权限，可以用REVOKE命令。这里以 MySQl 为例，介绍权限控制实际应用。\nGRANT授予权限语法：\n1 2 3 4 GRANT privilege,[privilege],.. ON privilege_level TO user [IDENTIFIED BY password] [REQUIRE tsl_option] [WITH [GRANT_OPTION | resource_option]]; 简单解释一下：\n在GRANT关键字后指定一个或多个权限。如果授予用户多个权限，则每个权限由逗号分隔。 ON privilege_level 确定权限应用级别。MySQL 支持 global（*.*），database（database.*），table（database.table）和列级别。如果使用列权限级别，则必须在每个权限之后指定一个或逗号分隔列的列表。 user 是要授予权限的用户。如果用户已存在，则GRANT语句将修改其权限。否则，GRANT语句将创建一个新用户。可选子句IDENTIFIED BY允许您为用户设置新的密码。 REQUIRE tsl_option指定用户是否必须通过 SSL，X059 等安全连接连接到数据库服务器。 可选 WITH GRANT OPTION 子句允许您授予其他用户或从其他用户中删除您拥有的权限。此外，您可以使用WITH子句分配 MySQL 数据库服务器的资源，例如，设置用户每小时可以使用的连接数或语句数。这在 MySQL 共享托管等共享环境中非常有用。 REVOKE 撤销权限语法：\n1 2 3 4 REVOKE privilege_type [(column_list)] [, priv_type [(column_list)]]... ON [object_type] privilege_level FROM user [, user]... 简单解释一下：\n在 REVOKE 关键字后面指定要从用户撤消的权限列表。您需要用逗号分隔权限。 指定在 ON 子句中撤销特权的特权级别。 指定要撤消 FROM 子句中的权限的用户帐户。 GRANT 和 REVOKE 可在几个层次上控制访问权限：\n整个服务器，使用 GRANT ALL 和 REVOKE ALL； 整个数据库，使用 ON database.*； 特定的表，使用 ON database.table； 特定的列； 特定的存储过程。 新创建的账户没有任何权限。账户用 username@host 的形式定义，username@% 使用的是默认主机名。MySQL 的账户信息保存在 mysql 这个数据库中。\n1 2 USE mysql; SELECT user FROM user; 下表说明了可用于GRANT和REVOKE语句的所有允许权限：\n特权 说明 级别 全局 数据库 表 列 程序 代理 ALL [PRIVILEGES] 授予除 GRANT OPTION 之外的指定访问级别的所有权限 ALTER 允许用户使用 ALTER TABLE 语句 X X X ALTER ROUTINE 允许用户更改或删除存储的例程 X X X CREATE 允许用户创建数据库和表 X X X CREATE ROUTINE 允许用户创建存储的例程 X X CREATE TABLESPACE 允许用户创建，更改或删除表空间和日志文件组 X CREATE TEMPORARY TABLES 允许用户使用 CREATE TEMPORARY TABLE 创建临时表 X X CREATE USER 允许用户使用 CREATE USER，DROP USER，RENAME USER 和 REVOKE ALL PRIVILEGES 语句。 X CREATE VIEW 允许用户创建或修改视图。 X X X DELETE 允许用户使用 DELETE X X X DROP 允许用户删除数据库，表和视图 X X X EVENT 启用事件计划程序的事件使用。 X X EXECUTE 允许用户执行存储的例程 X X X FILE 允许用户读取数据库目录中的任何文件。 X GRANT OPTION 允许用户拥有授予或撤消其他帐户权限的权限。 X X X X X INDEX 允许用户创建或删除索引。 X X X INSERT 允许用户使用 INSERT 语句 X X X X LOCK TABLES 允许用户对具有 SELECT 权限的表使用 LOCK TABLES X X PROCESS 允许用户使用 SHOW PROCESSLIST 语句查看所有进程。 X PROXY 启用用户代理。 REFERENCES 允许用户创建外键 X X X X RELOAD 允许用户使用 FLUSH 操作 X REPLICATION CLIENT 允许用户查询以查看主服务器或从属服务器的位置 X REPLICATION SLAVE 允许用户使用复制从属从主服务器读取二进制日志事件。 X SELECT 允许用户使用 SELECT 语句 X X X X SHOW DATABASES 允许用户显示所有数据库 X SHOW VIEW 允许用户使用 SHOW CREATE VIEW 语句 X X X SHUTDOWN 允许用户使用 mysqladmin shutdown 命令 X SUPER 允许用户使用其他管理操作，例如 CHANGE MASTER TO，KILL，PURGE BINARY LOGS，SET GLOBAL 和 mysqladmin 命令 X TRIGGER 允许用户使用 TRIGGER 操作。 X X X UPDATE 允许用户使用 UPDATE 语句 X X X X USAGE 相当于“没有特权” 创建账户 1 CREATE USER myuser IDENTIFIED BY \u0026#39;mypassword\u0026#39;; 修改账户名 1 2 UPDATE user SET user=\u0026#39;newuser\u0026#39; WHERE user=\u0026#39;myuser\u0026#39;; FLUSH PRIVILEGES; 删除账户 1 DROP USER myuser; 查看权限 1 SHOW GRANTS FOR myuser; 授予权限 1 GRANT SELECT, INSERT ON *.* TO myuser; 删除权限 1 REVOKE SELECT, INSERT ON *.* FROM myuser; 更改密码 1 SET PASSWORD FOR myuser = \u0026#39;mypass\u0026#39;; ","permalink":"https://jinchaojjj.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/","summary":"数据库 1. 基本知识 数据库, 数据库管理系统, 数据库系统, 数据库管理员 数据库 : 数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据","title":"数据库基础"},{"content":"a. SELCET 作用：用于从数据库中选取数据。结果被存储在一个结果表中，称为结果集。\n语法：\n1 2 3 4 SELECT column1, column2, ... FROM table_name; # 或者 SELECT * FROM table_name; 参数含义：\ncolumn1, column2, \u0026hellip;：要选择的字段名称，可以为多个字段。如果不指定字段名称，则会选择所有字段。 table_name：要查询的表名称。 1. DISTINCT 作用：在表中，一个列可能会包含多个重复值，有时您也许希望仅仅列出不同（distinct）的值。DISTINCT 关键词用于返回唯一不同的值。\n语法：\n1 2 SELECT DISTINCT column1, column2, ... FROM table_name; 参数含义：\ncolumn1, column2, \u0026hellip;：要选择的字段名称，可以为多个字段。如果不指定字段名称，则会选择所有字段。 table_name：要查询的表名称。 注意：需要选择的所有字段都不一样才是不一样，例如选择了两个数据a和b，需要两条数据中a和b都组合不同，a相同是没关系的\n2. WHERE 作用：WHERE 子句用于提取那些满足指定条件的记录。\n语法：\n1 2 3 SELECT column1, column2, ... FROM table_name WHERE condition; 参数含义：\ncolumn1, column2, \u0026hellip;：要选择的字段名称，可以为多个字段。如果不指定字段名称，则会选择所有字段。 table_name：要查询的表名称。 WHERE中可以使用的运算符 运算符 描述 = 等于 \u0026lt;\u0026gt; 不等于。**注释：**在 SQL 的一些版本中，该操作符可被写成 != \u0026gt; 大于 \u0026lt; 小于 \u0026gt;= 大于等于 \u0026lt;= 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 IN 指定针对某个列的多个可能值 AND \u0026amp; OR 运算符 作用：AND \u0026amp; OR 运算符用于基于一个以上的条件对记录进行过滤。\n如果第一个条件和第二个条件都成立，则 AND 运算符显示一条记录。\n如果第一个条件和第二个条件中只要有一个成立，则 OR 运算符显示一条记录。\nLIKE 作用：LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。\n语法：\n1 2 3 SELECT column1, column2, ... FROM table_name WHERE column LIKE pattern; 参数含义：\ncolumn1, column2, \u0026hellip;：要选择的字段名称，可以为多个字段。如果不指定字段名称，则会选择所有字段。 table_name：要查询的表名称。 column：要搜索的字段名称。 pattern：搜索模式。 通配符 通配符 描述 % 替代 0 个或多个字符 _ 替代一个字符 [charlist] 字符列中的任何单一字符 [^charlist] 或 [!charlist] 不在字符列中的任何单一字符 MySQL 中使用 REGEXP 或 NOT REGEXP 运算符 (或 RLIKE 和 NOT RLIKE) 来操作正则表达式。 IN 作用：IN 操作符允许您在 WHERE 子句中规定多个值。\n语法：\n1 2 3 SELECT column1, column2, ... FROM table_name WHERE column IN (value1, value2, ...); 参数含义：\ncolumn1, column2, \u0026hellip;：要选择的字段名称，可以为多个字段。如果不指定字段名称，则会选择所有字段。 table_name：要查询的表名称。 column：要查询的字段名称。 value1, value2, \u0026hellip;：要查询的值，可以为多个值。 BETWEEN 作用：BETWEEN 操作符选取介于两个值之间的数据范围内的值。这些值可以是数值、文本或者日期。\n语法：\n1 2 3 4 SELECT column1, column2, ... FROM table_name WHERE column BETWEEN value1 AND value2; # 前闭后闭 参数含义：\ncolumn1, column2, \u0026hellip;：要选择的字段名称，可以为多个字段。如果不指定字段名称，则会选择所有字段。 table_name：要查询的表名称。 column：要查询的字段名称。 value1：范围的起始值。 value2：范围的结束值。 EXISTS EXISTS 运算符用于判断查询子句是否有记录，如果有一条或多条记录存在返回 True，否则返回 False。\n1 2 3 4 SELECT column_name(s) FROM table_name WHERE EXISTS (SELECT column_name FROM table_name WHERE condition); 通常外部查询与子查询建立关系后查询 NULL NOT NULL 需要使用is判断是否为null，同时也可以使用not is\n3. 别名 作用：通过使用 SQL，可以为表名称或列名称指定别名。基本上，创建别名是为了让列名称的可读性更强。\n语法：\n1 2 3 4 5 6 7 # 列的别名 SELECT column_name AS alias_name FROM table_name; # 表的别名 SELECT column_name(s) FROM table_name AS alias_name; 4. JOIN 上图展示了七种不同的JOIN语法。其中最常用的INNER JOIN简称JOIN。\n作用：SQL JOIN 子句用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段。\n最常见的 JOIN 类型：SQL INNER JOIN（简单的 JOIN）。 SQL INNER JOIN 从多个表中返回满足 JOIN 条件的所有行。\n语法：\n1 2 3 SELECT column1, column2, ... FROM table1 JOIN table2 ON condition; 参数含义：\ncolumn1, column2, \u0026hellip;：要选择的字段名称，可以为多个字段。如果不指定字段名称，则会选择所有字段。 table1：要连接的第一个表。 table2：要连接的第二个表。 condition：连接条件，用于指定连接方式。使用关键字ON对连接进行约束。 LEFT JOIN 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。\nRIGHT JOIN 关键字从右表（table2）返回所有的行，即使左表（table1）中没有匹配。如果左表中没有匹配，则结果为 NULL。\nFULL OUTER JOIN 关键字只要左表（table1）和右表（table2）其中一个表中存在匹配，则返回行.\nFULL OUTER JOIN 关键字结合了 LEFT JOIN 和 RIGHT JOIN 的结果（MySQL不支持该功能）\n5. ORDER BY 作用：ORDER BY 关键字用于对结果集按照一个列或者多个列进行排序。\nORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，您可以使用 DESC 关键字。\n语法：\n1 2 3 SELECT column1, column2, ... FROM table_name ORDER BY column1, column2, ... ASC|DESC; 参数含义：\ncolumn1, column2, \u0026hellip;：要排序的字段名称，可以为多个字段。 ASC：表示按升序排序。 DESC：表示按降序排序。 6. TOP, LIMIT, ROWNUM 作用：SELECT TOP 子句用于规定要返回的记录的数目。\nSELECT TOP 子句对于拥有数千条记录的大型表来说，是非常有用的。\n语法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 # MySQL 使用LIMIT SELECT column_name(s) FROM table_name LIMIT number; # Oracle 使用ROWNUM SELECT column_name(s) FROM table_name WHERE ROWNUM \u0026lt;= number; # SQL Server 使用TOP SELECT TOP number|percent column_name(s) FROM table_name; 7. UNION 作用：SQL UNION 操作符合并两个或多个 SELECT 语句的结果。\n语法：\n1 2 3 4 5 6 7 8 # 默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。 SELECT column_name(s) FROM table1 UNION SELECT column_name(s) FROM table2; # UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。 SELECT column_name(s) FROM table1 UNION ALL SELECT column_name(s) FROM table2; 注意：两个查询语句的结果列数需要相同\n8. SELECT INTO 通过 SQL，您可以从一个表复制信息到另一个表。\nSELECT INTO 语句从一个表复制数据，然后把数据插入到另一个新表中。\nMySQL不支持该功能 9. GROUP BY GROUP BY 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。\n语法 1 2 3 4 SELECT column_name, aggregate_function(column_name) FROM table_name WHERE column_name operator value GROUP BY column_name; HAVING 在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。\nHAVING 子句可以让我们筛选分组后的各组数据。\n1 2 3 4 5 SELECT column_name, aggregate_function(column_name) FROM table_name WHERE column_name operator value GROUP BY column_name HAVING aggregate_function(column_name) operator value; SQL ANY 和 ALL 运算符 ANY 和 ALL 运算符与 WHERE 或 HAVING 子句一起使用。\n如果任何子查询值满足条件，则 ANY 运算符返回 true。\n如果所有子查询值都满足条件，则 ALL 运算符返回 true。\nANY 语法 1 2 3 4 SELECT *column_name(s)* FROM *table_name* WHERE *column_name operator* ANY (SELECT *column_name* FROM *table_name* WHERE *condition*); ALL 语法 1 2 3 4 SELECT *column_name(s)* FROM *table_name* WHERE *column_name operator* ALL (SELECT *column_name* FROM *table_name* WHERE *condition*); 注释: 运算符必须是标准比较运算符 (=, \u0026lt;\u0026gt;, !=, \u0026gt;, \u0026gt;=, \u0026lt;, or \u0026lt;=).\nb. INSERT INTO 作用：INSERT INTO 语句用于向表中插入新记录。\n语法：\n1 2 3 4 5 INSERT INTO table_name VALUES (value1,value2,value3,...); # 或 INSERT INTO table_name (column1,column2,column3,...) VALUES (value1,value2,value3,...); 参数含义：\ntable_name：需要插入新记录的表名。 column1, column2, \u0026hellip;：需要插入的字段名。 value1, value2, \u0026hellip;：需要插入的字段值。 INSERT INTO SELECT 作用：INSERT INTO SELECT 语句从一个表复制数据，然后把数据插入到一个已存在的表中。目标表中任何已存在的行都不会受影响。\n语法：\n1 2 3 4 5 6 7 INSERT INTO table2 SELECT * FROM table1; INSERT INTO table2 (column_name(s)) SELECT column_name(s) FROM table1; 注意：两个查询语句的结果列数需要相同\nc. UPDATE 作用：UPDATE 语句用于更新表中已存在的记录。\n语法：\n1 2 3 UPDATE table_name SET column1 = value1, column2 = value2, ... WHERE condition; 参数含义：\ntable_name：要修改的表名称。 column1, column2, \u0026hellip;：要修改的字段名称，可以为多个字段。 value1, value2, \u0026hellip;：要修改的值，可以为多个值。 condition：修改条件，用于指定哪些数据要修改。 注意：WHERE 子句规定哪条记录或者哪些记录需要更新。如果您省略了 WHERE 子句，所有的记录都将被更新！\nd. DELETE 作用：DELETE 语句用于删除表中的行。\n语法：\n1 2 DELETE FROM table_name WHERE condition; 参数含义：\ntable_name：要删除的表名称。 condition：删除条件，用于指定哪些数据要删除。 注意：WHERE 子句规定哪条记录或者哪些记录需要删除。如果您省略了 WHERE 子句，所有的记录都将被删除！\ne. CREATE CREATE DATABASE 作用：CREATE DATABASE 语句用于创建数据库。\n语法：\n1 CREATE DATABASE dbname; CREATE TABLE 作用：CREATE TABLE 语句用于创建数据库中的表。\n表由行和列组成，每个表都必须有个表名。\n语法：\n1 2 3 4 5 6 7 CREATE TABLE table_name ( column_name1 data_type(size), column_name2 data_type(size), column_name3 data_type(size), .... ); column_name 参数规定表中列的名称。\ndata_type 参数规定列的数据类型（例如 varchar、integer、decimal、date 等等）。\nsize 参数规定表中列的最大长度。\nf. SQL 约束（Constraints） SQL 约束用于规定表中的数据规则。\n如果存在违反约束的数据行为，行为会被约束终止。\n约束可以在创建表时规定（通过 CREATE TABLE 语句），或者在表创建之后规定（通过 ALTER TABLE 语句）。\nCREATE TABLE + CONSTRAINT 语法 1 2 3 4 5 6 7 CREATE TABLE table_name ( column_name1 data_type(size) constraint_name, column_name2 data_type(size) constraint_name, column_name3 data_type(size) constraint_name, .... ); 在 SQL 中，我们有如下约束：\nNOT NULL - 指示某列不能存储 NULL 值。 UNIQUE - 保证某列的每行必须有唯一的值。 PRIMARY KEY - NOT NULL 和 UNIQUE 的结合。确保某列（或两个列多个列的结合）有唯一标识，有助于更容易更快速地找到表中的一个特定的记录。 FOREIGN KEY - 保证一个表中的数据匹配另一个表中的值的参照完整性。 CHECK - 保证列中的值符合指定的条件。 DEFAULT - 规定没有给列赋值时的默认值。 NOT NULL 约束 NOT NULL 约束强制列不接受 NULL 值。\nNOT NULL 约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。\n添加 NOT NULL 约束 在一个已创建的表的 \u0026ldquo;Age\u0026rdquo; 字段中添加 NOT NULL 约束如下所示：\n1 2 # 例子 ALTER TABLE Persons MODIFY Age int NOT NULL; 删除 NOT NULL 约束 在一个已创建的表的 \u0026ldquo;Age\u0026rdquo; 字段中删除 NOT NULL 约束如下所示：\n1 ALTER TABLE Persons MODIFY Age int NULL; SQL UNIQUE 约束 UNIQUE 约束唯一标识数据库表中的每条记录。\nUNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。\nPRIMARY KEY 约束拥有自动定义的 UNIQUE 约束。\n请注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 创建表示的语法 CREATE TABLE Persons ( P_Id int NOT NULL, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255), UNIQUE (P_Id) ); # 已创建表的语法 ## 当表已被创建时，如需在 \u0026#34;P_Id\u0026#34; 列创建 UNIQUE 约束，请使用下面的 SQL： ALTER TABLE Persons ADD UNIQUE (P_Id) ## 如需命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束，请使用下面的 SQL 语法： ALTER TABLE Persons ADD CONSTRAINT uc_PersonID UNIQUE (P_Id,LastName) # 如需撤销 UNIQUE 约束，请使用下面的 SQL： ALTER TABLE Persons DROP INDEX uc_PersonID PRIMARY KEY 约束 PRIMARY KEY 约束唯一标识数据库表中的每条记录。\n主键必须包含唯一的值。\n主键列不能包含 NULL 值。\n每个表都应该有一个主键，并且每个表只能有一个主键。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # MySQL语法 CREATE TABLE Persons ( P_Id int NOT NULL, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255), PRIMARY KEY (P_Id) ) # 当表已被创建时，如需在 \u0026#34;P_Id\u0026#34; 列创建 PRIMARY KEY 约束，请使用下面的 SQL： ALTER TABLE Persons ADD PRIMARY KEY (P_Id) # 如需命名 PRIMARY KEY 约束，并定义多个列的 PRIMARY KEY 约束，请使用下面的 SQL 语法： ALTER TABLE Persons ADD CONSTRAINT pk_PersonID PRIMARY KEY (P_Id,LastName) # 撤销 ALTER TABLE Persons DROP PRIMARY KEY FOREIGN KEY 约束 一个表中的 FOREIGN KEY 指向另一个表中的 UNIQUE KEY(唯一约束的键)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 CREATE TABLE Orders ( O_Id int NOT NULL, OrderNo int NOT NULL, P_Id int, PRIMARY KEY (O_Id), FOREIGN KEY (P_Id) REFERENCES Persons(P_Id) ) # 当 \u0026#34;Orders\u0026#34; 表已被创建时，如需在 \u0026#34;P_Id\u0026#34; 列创建 FOREIGN KEY 约束，请使用下面的 SQL： ALTER TABLE Orders ADD FOREIGN KEY (P_Id) REFERENCES Persons(P_Id) # 如需命名 FOREIGN KEY 约束，并定义多个列的 FOREIGN KEY 约束，请使用下面的 SQL 语法： ALTER TABLE Orders ADD CONSTRAINT fk_PerOrders FOREIGN KEY (P_Id) REFERENCES Persons(P_Id) # 撤销 FOREIGN KEY 约束 ALTER TABLE Orders DROP FOREIGN KEY fk_PerOrders CHECK 约束 CHECK 约束用于限制列中的值的范围。\n如果对单个列定义 CHECK 约束，那么该列只允许特定的值。\n如果对一个表定义 CHECK 约束，那么此约束会基于行中其他列的值在特定的列中对值进行限制。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 CREATE TABLE Persons ( P_Id int NOT NULL, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255), CHECK (P_Id\u0026gt;0) ) # 当表已被创建时，如需在 \u0026#34;P_Id\u0026#34; 列创建 CHECK 约束，请使用下面的 SQL： ALTER TABLE Persons ADD CHECK (P_Id\u0026gt;0) # 如需命名 CHECK 约束，并定义多个列的 CHECK 约束，请使用下面的 SQL 语法： ALTER TABLE Persons ADD CONSTRAINT chk_Person CHECK (P_Id\u0026gt;0 AND City=\u0026#39;Sandnes\u0026#39;) # 如需撤销 CHECK 约束，请使用下面的 SQL： ALTER TABLE Persons DROP CHECK chk_Person DEFAULT 约束 DEFAULT 约束用于向列中插入默认值。\n如果没有规定其他的值，那么会将默认值添加到所有的新记录。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 CREATE TABLE Persons ( P_Id int NOT NULL, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255) DEFAULT \u0026#39;Sandnes\u0026#39; ) # 当表已被创建时，如需在 \u0026#34;City\u0026#34; 列创建 DEFAULT 约束，请使用下面的 SQL： ALTER TABLE Persons ALTER City SET DEFAULT \u0026#39;SANDNES\u0026#39; # 如需撤销 DEFAULT 约束，请使用下面的 SQL： ALTER TABLE Persons ALTER City DROP DEFAULT g. 索引 您可以在表中创建索引，以便更加快速高效地查询数据。\n用户无法看到索引，它们只能被用来加速搜索/查询。\n**注释：**更新一个包含索引的表需要比更新一个没有索引的表花费更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。\nCREATE INDEX 在表上创建一个简单的索引。允许使用重复的值：\n1 2 CREATE INDEX index_name ON table_name (column_name) CREATE UNIQUE INDEX 在表上创建一个唯一的索引。不允许使用重复的值：唯一的索引意味着两个行不能拥有相同的索引值。Creates a unique index on a table. Duplicate values are not allowed:\n1 2 CREATE UNIQUE INDEX index_name ON table_name (column_name) h. DROP 通过使用 DROP 语句，可以轻松地删除索引、表和数据库。\nDROP INDEX 1 ALTER TABLE table_name DROP INDEX index_name DROP TABLE DROP TABLE 语句用于删除表。\n1 DROP TABLE table_name DROP DATABASE DROP DATABASE 语句用于删除数据库。\n1 DROP DATABASE database_name TRUNCATE TABLE 如果我们仅仅需要删除表内的数据，但并不删除表本身，那么我们该如何做呢？\n请使用 TRUNCATE TABLE 语句：\n1 TRUNCATE TABLE table_name i. ALTER TABLE ALTER TABLE 语句用于在已有的表中添加、删除或修改列。\nADD 如需在表中添加列，请使用下面的语法:\n1 2 ALTER TABLE table_name ADD column_name datatype DROP 如需删除表中的列，请使用下面的语法（请注意，某些数据库系统不允许这种在数据库表中删除列的方式）：\n1 2 ALTER TABLE table_name DROP COLUMN column_name MODIFY 要改变表中列的数据类型，请使用下面的语法：\n1 2 ALTER TABLE table_name MODIFY COLUMN column_name datatype j. AUTO INCREMENT 我们通常希望在每次插入新记录时，自动地创建主键字段的值。\n我们可以在表中创建一个 auto-increment 字段。\n下面的 SQL 语句把 \u0026ldquo;Persons\u0026rdquo; 表中的 \u0026ldquo;ID\u0026rdquo; 列定义为 auto-increment 主键字段：\n1 2 3 4 5 6 7 8 9 CREATE TABLE Persons ( ID int NOT NULL AUTO_INCREMENT, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255), PRIMARY KEY (ID) ) MySQL 使用 AUTO_INCREMENT 关键字来执行 auto-increment 任务。\nk. CREATE VIEW 在 SQL 中，视图是基于 SQL 语句的结果集的可视化的表。\n视图包含行和列，就像一个真实的表。视图中的字段就是来自一个或多个数据库中的真实的表中的字段。\n您可以向视图添加 SQL 函数、WHERE 以及 JOIN 语句，也可以呈现数据，就像这些数据来自于某个单一的表一样。\n1 2 3 4 CREATE VIEW view_name AS SELECT column_name(s) FROM table_name WHERE condition l. MySQL Date 函数 下面的表格列出了 MySQL 中最重要的内建日期函数：\n函数 描述 NOW() 返回当前的日期和时间 CURDATE() 返回当前的日期 CURTIME() 返回当前的时间 DATE() 提取日期或日期/时间表达式的日期部分 EXTRACT() 返回日期/时间的单独部分 DATE_ADD() 向日期添加指定的时间间隔 DATE_SUB() 从日期减去指定的时间间隔 DATEDIFF() 返回两个日期之间的天数 DATE_FORMAT() 用不同的格式显示日期/时间 m. MySQL 数据类型 在 MySQL 中，有三种主要的类型：Text（文本）、Number（数字）和 Date/Time（日期/时间）类型。\nText 类型：\n数据类型 描述 CHAR(size) 保存固定长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的长度。最多 255 个字符。 VARCHAR(size) 保存可变长度的字符串（可包含字母、数字以及特殊字符）。在括号中指定字符串的最大长度。最多 255 个字符。**注释：**如果值的长度大于 255，则被转换为 TEXT 类型。 TINYTEXT 存放最大长度为 255 个字符的字符串。 TEXT 存放最大长度为 65,535 个字符的字符串。 BLOB 用于 BLOBs（Binary Large OBjects）。存放最多 65,535 字节的数据。 MEDIUMTEXT 存放最大长度为 16,777,215 个字符的字符串。 MEDIUMBLOB 用于 BLOBs（Binary Large OBjects）。存放最多 16,777,215 字节的数据。 LONGTEXT 存放最大长度为 4,294,967,295 个字符的字符串。 LONGBLOB 用于 BLOBs (Binary Large OBjects)。存放最多 4,294,967,295 字节的数据。 ENUM(x,y,z,etc.) 允许您输入可能值的列表。可以在 ENUM 列表中列出最大 65535 个值。如果列表中不存在插入的值，则插入空值。**注释：**这些值是按照您输入的顺序排序的。可以按照此格式输入可能的值： ENUM(\u0026lsquo;X\u0026rsquo;,\u0026lsquo;Y\u0026rsquo;,\u0026lsquo;Z\u0026rsquo;) SET 与 ENUM 类似，不同的是，SET 最多只能包含 64 个列表项且 SET 可存储一个以上的选择。 Number 类型：\n数据类型 描述 TINYINT(size) 带符号-128到127 ，无符号0到255。 SMALLINT(size) 带符号范围-32768到32767，无符号0到65535, size 默认为 6。 MEDIUMINT(size) 带符号范围-8388608到8388607，无符号的范围是0到16777215。 size 默认为9 INT(size) 带符号范围-2147483648到2147483647，无符号的范围是0到4294967295。 size 默认为 11 BIGINT(size) 带符号的范围是-9223372036854775808到9223372036854775807，无符号的范围是0到18446744073709551615。size 默认为 20 FLOAT(size,d) 带有浮动小数点的小数字。在 size 参数中规定显示最大位数。在 d 参数中规定小数点右侧的最大位数。 DOUBLE(size,d) 带有浮动小数点的大数字。在 size 参数中规显示定最大位数。在 d 参数中规定小数点右侧的最大位数。 DECIMAL(size,d) 作为字符串存储的 DOUBLE 类型，允许固定的小数点。在 size 参数中规定显示最大位数。在 d 参数中规定小数点右侧的最大位数。 n. SQL 函数 SQL 拥有很多可用于计数和计算的内建函数。\nSQL Aggregate 函数 SQL Aggregate 函数计算从列中取得的值，返回一个单一的值。\n有用的 Aggregate 函数：\nAVG() - 返回平均值 COUNT() - 返回行数 FIRST() - 返回第一个记录的值 LAST() - 返回最后一个记录的值 MAX() - 返回最大值 MIN() - 返回最小值 SUM() - 返回总和 MOD() - 余数 SQL Scalar 函数 SQL Scalar 函数基于输入值，返回一个单一的值。\n有用的 Scalar 函数：\nUCASE() - 将某个字段转换为大写 LCASE() - 将某个字段转换为小写 MID() - 从某个文本字段提取字符，MySql 中使用 SubString(字段，1，end) - 从某个文本字段提取字符 LEN() - 返回某个文本字段的长度 ROUND() - 对某个数值字段进行指定小数位数的四舍五入 NOW() - 返回当前的系统日期和时间 FORMAT() - 格式化某个字段的显示方式 o. CASE 语句 CASE语句遍历条件并在满足第一个条件时返回一个值（如IF-THEN-ELSE语句）。因此，一旦条件为真，它将停止读取并返回结果。如果没有条件为 true，则返回 ELSE 子句中的值。\n如果没有其他部分，并且没有条件为 true，则返回 NULL。\n语法 1 2 3 4 5 6 CASE WHEN *condition1* THEN *result1* WHEN *condition2* THEN *result2* WHEN *conditionN* THEN *resultN* ELSE *result* END; ","permalink":"https://jinchaojjj.github.io/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/%E8%AF%AD%E6%B3%95/","summary":"a. SELCET 作用：用于从数据库中选取数据。结果被存储在一个结果表中，称为结果集。 语法： 1 2 3 4 SELECT column1, column2, ... FROM table_name; # 或者 SELECT * FROM table_name; 参数含义： column1, column2, \u0026hellip","title":"MySQL数据库"},{"content":"关于我\n英文名: King 职业: 程序员 运动: 羽毛球、F1、足球 ","permalink":"https://jinchaojjj.github.io/about/","summary":"关于我 英文名: King 职业: 程序员 运动: 羽毛球、F1、足球","title":"🙋🏻‍♂️关于"}]